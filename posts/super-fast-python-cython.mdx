---
title: "Super fast Python (Part-4): Cython"
description: "Convert slow Python code to run as fast as C/C++ using Cython."
imgName: "super-fast-python-cython/super-fast-python-cython.jpg"
date: "Nov 18, 2022"
tags: ["python-performance", "python"]
keywords:
  [
    "cython",
    "python-performance",
    "python-optimize",
    "python",
    "fast-python",
    "speed",
  ]
---

![Super fast Python: Cython](super-fast-python-cython/super-fast-python-cython.jpg)

###### Published on: **Nov 18, 2022**

# Super fast Python (Part-4): Cython

This is the fourth post in the series on Python performance and Optimization. The series points out the utilization of inbuilt libraries, low-level code conversions, and other Python implementations to speed-up Python. The other posts included in this series are

- (Part-1): [Why Python is slow?](https://santhalakshminarayana.github.io/blog/super-fast-python-why-python-slow)
- (Part-2): [Good practices to write fast Python code](https://santhalakshminarayana.github.io/blog/super-fast-python-good-practices)
- (Part-3): [Multi-processing in Python](https://santhalakshminarayana.github.io/blog/super-fast-python-multi-processing)
- (Part-4): Use Cython to get speed as fast as C (this post)
- (Part-5): [Use Numba to speed up Python Functions and Numeric calculations](https://santhalakshminarayana.github.io/blog/super-fast-python-numba)

In the last post, we discussed **multiprocessing** to optimize Python code by utilizing parallel computing with multiple CPU cores. Multi-processing is useful when we can split certain parts of code into parallel tasks and then execute them parallelly.

Imagine when we don't have any parallelizable code and it is taking huge time in Python compared to **C/C++**, how to optimize the code then? One thing we can do is to convert the Python code into a low-level programming language like C/C++ and [embed that C/C++ code in Python](https://docs.python.org/3/extending/extending.html). Understanding and writing C/C++ code is hard for someone who is not familiar with C/C++. Fortunately, we can get the performance speed as fast as C/C++ by writing the Python code in [Cython](https://cython.org/) which is a superset of Python that provides functionality to write C-Extensions for Python.

## How Cython can improve Speed?

In our previous discussion on [Why Python is slow?](https://santhalakshminarayana.github.io/blog/super-fast-python-why-python-slow), we learned that the major speed issues arise in Python due to

- interpretation of generated bytecode
- dynamic types and their management

With Cython, we can take care of the above problems with both compiled code instead of interpretation and static typing instead of dynamic typing.

Cython translates the Python code into C extension code and compiles the C code into an object code that can be imported directly into Python. Also, we can make some changes like adding static types that improve the execution speed drastically over dynamic typing. Cython also supports the usage of C/C++ libraries and functions that are super-fast compared to Python libraries and functions.

### Install Cython

[Install the Cython](https://cython.readthedocs.io/en/stable/src/quickstart/install.html) with Pip as follows

```bash
pip install Cython
```

> To compile the C code into an object file, we need a C compiler. Ubuntu comes with **gcc** by default. For other platforms like Windows, install the C compiler if not installed previously.

---

## Cython usage

There are multiple ways to use Cython like building manually, using in Jupyter as an extension, or importing directly like a Python module without compilation using _pyximport_.

### Build a Cython module manually

We write the Cython code in a file with the extension _.pyx_ instead of the normal Python extension _.py_.

The compiler translates '.pyx' Cython file into a '.c' C file and then compiles that C file to a sharable object file '.so' (or '.pyd' on Windows). We tell the compiler those build instructions and compilation options by writing a [setup.py](https://cython.readthedocs.io/en/stable/src/userguide/source_files_and_compilation.html#basic-setup-py) file.

### Cython compilation

- Translate the _.pyx_ source code to a _.c_ file with additional wrappers of Python extension code.
- Compile the _.c_ file with a C compiler to a platform-specific shared object file _.so_ that can be imported directly into Python.

```python:calculate_y_cython.pyx
def fx(x, a, b, c):
    d = (a + b) * c
    return a*x + b*(x**2) + c*(x**3) + d

def y(x, n, a, b, c):
    af = fx(x, a, b, c)**2
    k = abs(n//2 - x)
    bf = fx(k, a, b, c)
    return (af-bf)/(n-1 + 1e-12)

def calculate_y_cython(n):
    ys = []
    a, b, c = 2, 5, -4
    for i in range(n):
        ys.append(y(i, n, a, b, c))

    return ys
```

The above file _calculate_y.pyx_ contains Cython code that looks the same as Python without any optimizations. Now to compile the above file, write a _setup.py_ file as following

```python:setup.py
from distutils.core import setup
from Cython.Build import cythonize

setup(
    name='Calculate Expression Y',
    ext_modules=cythonize(
        "calculate_y_cython.pyx",
        compiler_directives={"language_level": "3"},
    )
)
```

In the above _setup.py_, for the **setup()**, we have passed the optional name to our Cython module for _name_ and the path to the _.pyx_ file for the _ext_module_ parameter.

Build the sharable object file '.so' using the following command in the terminal

```bash
python setup.py build_ext --inplace
or
python setup.py build_ext --inplace --quiet
```

This will generate a translated '.c' C file and a compiled '.so' file.

We can import the above compiled _calculate_y_cython_ module directly into Python runtime.

```python:main.py
from time import perf_counter
from calculate_y_cython import calculate_y_cython

def fx(x, a, b, c):
    d = (a + b) * c
    return a*x + b*(x**2) + c*(x**3) + d

def y(x, n, a, b, c):
    af = fx(x, a, b, c)**2
    k = abs(n//2 - x)
    bf = fx(k, a, b, c)
    return (af-bf)/(n-1 + 1e-12)

def calculate_y_py(n):
    ys = []
    a, b, c = 2, 5, -4
    for i in range(n):
        ys.append(y(i, n, a, b, c))

    return ys

def main():
    n = 100000
    # Python implementation
    atime = perf_counter()
    res = calculate_y_py(n)
    print(f'Python Time: {perf_counter()-atime:.2}')

    atime = perf_counter()
    res = calculate_y_cython(n)
    print(f'Cython Time: {perf_counter()-atime:.2}')

if __name__=="__main__":
    main()

"""Output:
Python Time: 0.19
Cython Time: 0.16
"""
```

> At the time of writing, the latest Python version is Python 3.11 which is incredibly faster (30-60% in some cases) than earlier versions. So, to understand the Cython potential, I'm running the scripts in Python 3.8.10 on my old system with 8GB Intel(R) i5-8250U 1.60GHz CPU on HP Laptop 15-da0xxx.

In the above _main.py_, we have imported the _calculate_y_cython_ module at line 2. If we look at the output to check the time taken for normal Python implementation and Cython version, they are **0.19** and **0.16** seconds respectively. The time difference is very low and we didn't gain much from Cython because we haven't done any optimization steps like

- static typing
- limit calling Python's libraries
- reducing Python's PyObject usage

### Cython Annotations

Cython provides an easy way to check where we can optimize our Cython code by using Cython annotate feature. With the following command (_-a_ denotes annotate and _-3_ denotes **language_level** which is Python3), cython generates an HTML file that we can open in the browser to check for optimizable code. Another option is to pass the **annotate=True** parameter to _cythonize()_ function call in **ext_modules** in _setup_.

```bash
cython -a calculate_y_cython.pyx -3
```

If we open the generated HTML file in the browser, it will look like this

![Cython Annotation:=:80](super-fast-python-cython/cython-annotations.png)

The more yellow lines the more interaction with the Python interpreter. Our goal should be converting as many yellow lines as to white lines that denote pure Cython code. We discuss the optimization part in a later section.

### Cython as an extension in Jupyter

Cython can be imported and used in Jupyter directly as an extension without the need for any additional build/compilation steps.

First load the Cython extension using _%load_ext cython_, and then, for the cell that is to be Cythonized, use the magic command _%%cython_ at the top of that cell as shown in the following image.

![Cython Jupyter:=:40](super-fast-python-cython/cython-jupyter.png)

We can show the interactive Cython annotations in Jupyter just like we have generated the HTML file above. To show annotations, pass annotate option to _%%cython -a_ magic command.

### Import '.pyx' using pyximport

While developing or debugging, for each change in the '.pyx' file, running _setup.py_ is a repetitive task and cumbersome. Instead, we can dynamically import '.pyx' to Python directly using [pyximport](https://cython.readthedocs.io/en/stable/src/userguide/source_files_and_compilation.html#pyximport) without any external build and compilation. _pyximport_ takes care of compiling and building in the background without calling _cythonize()_ internally. So, while importing the '.pyx' file, it will take some time to be imported as a regular Python module.

```python
import pyximport
pyximport.install(language_level=3)

from calculate_y_cython import calculate_y_cython
```

Though it is easy to work with Cython using **pyximport**, there are some [limitations with pyximport](https://cython.readthedocs.io/en/stable/src/userguide/source_files_and_compilation.html#limitations) and it is also not flexible as normal setup.

> It is not recommended to use **pyximport** while distributing Python packages and modules.

---

## Optimize Cython

In the previous section, we have seen in the Cython annotations HTML file that many areas in the code need to be optimized for more speed. There are several ways to improve speed like

- define static types
- use C-libraries and functions
- utilize OpenMP for parallel computing

### Define static types to variables

Since Python is a dynamic typing language, we can define C-like data types for Python variables in Cython. To declare C variables, prefix the **cdef** keyword to the variable declaration which is the same as declaring variables in C.

The syntax for variable declaration is

```python
cdef type variable_name = initilization_value {optional}
```

The **type** can be any of the acceptable C data types.

### Define function definitions

Python functions are defined using **def** and [C functions in Cython](https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#python-functions-vs-c-functions) are defined with the keyword **cdef**. The difference between **def** and **cdef** is that with the former declaration, it can be called from anywhere both local and external modules where as **cdef** functions are only module level. Also, Cython wraps the **def** function that is defined inside '.pyx' into a Python object. There is another declaration called **cpdef** which behaves as **def** when called from outside the module and behaves as **cdef** inside the module, so it is faster inside the same module function call.

Cython also provides support for writing function definitions just like C. We can define parameter types and return types.

```python
cdef(or cpdef) type function_name(type parameter1, ...)
```

If no type is specified, the parameters and return values are treated as Python objects which need Python interpretation and they are slow.

Now, make some changes to _calculate_y_cython.pyx_ with static type declarations and function definitions as,

> [Call the C functions in Cython](https://cython.readthedocs.io/en/stable/src/tutorial/external.html) inplace of Python functions that reduces the Python interaction.

```python:calculate_y_cython.pyx
ctypedef long int li
ctypedef long long int lli

cdef lli fx(li x, int a, int b, int c):
    cdef int d = (a + b) * c
    return a*x + b*(x**2) + c*(x**3) + d

cdef double y(li x, li n, int a, int b, int c):
    cdef:
        lli af = fx(x, a, b, c)**2
        li k = abs(n//2 - x)
        lli bf = fx(k, a, b, c)
    return (af-bf)/(n-1 + 1e-12)

cpdef calculate_y_cython(li n):
    ys = []
    cdef:
        int a = 2, b = 5, c = -4
        li i = 0
    for i in range(n):
        ys.append(y(i, n, a, b, c))

    return ys
```

> speed can be improved further by disabling bound checking(@cython.boundscheck(False)) and negative indexing(@cython.wraparound(False)) [compiler directive instructions](https://cython.readthedocs.io/en/stable/src/userguide/source_files_and_compilation.html#compiler-directives).

Check the annotations for the Cython code, most of the yellow lines are now changed to white and only list operations are dark yellow because lists are Python objects. In a later section, we discuss optimizing lists using C arrays.

![Optimized Cython Annotation:=:70](super-fast-python-cython/optimized_cython.jpg)

If we check the time for the optimized Cython code,

```python
%%timeit -n 100
n = 100000
res = calculate_y_cython(n)

"""Output:
2.04 ms ± 166 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
"""
```

it takes **0.002** seconds which is approximately **100x** times faster than the normal Python version that takes **0.19** seconds. By adding only static type and some tweaks, we made Python 100x faster. The powers of Cython are not limited to only static typing. We can further speed up the code with Numpy.

---

## 1000x times faster with MemoryView and Numpy

In the Cython annotation snippet above, we see that the list operations of **ys** are still yellow as _list()_ is a python object and Cython cannot optimize Python objects interaction.

To solve this, we can convert the list type to [memoryview arrays](https://cython.readthedocs.io/en/stable/src/tutorial/array.html), and operations like _append()_ to indexing just like looping in C.

```python:calculate_y_cython.pyx
cimport cython
import numpy as np
cimport numpy as np

ctypedef long int li
ctypedef long long int lli

@cython.boundscheck(False)  # Deactivate bounds checking
@cython.wraparound(False)   # Deactivate negative indexing
cdef lli fx(li x, int a, int b, int c):
    cdef int d = (a + b) * c
    return a*x + b*(x**2) + c*(x**3) + d

@cython.boundscheck(False)
@cython.wraparound(False)
cdef double y(li x, li n, int a, int b, int c):
    cdef:
        lli af = fx(x, a, b, c)**2
        li k = abs(n//2 - x)
        lli bf = fx(k, a, b, c)
    return (af-bf)/(n-1 + 1e-12)

@cython.boundscheck(False)
@cython.wraparound(False)
cpdef calculate_y_cython(li n):
    cdef double[:] ys = np.empty(n, dtype=np.float64)
    cdef:
        int a = 2, b = 5, c = -4
        li i = 0
    for i in range(n):
        ys[i] = y(i, n, a, b, c)
    return ys
```

Before building the object code, we need to change [build instructions to link Numpy](https://cython.readthedocs.io/en/stable/src/tutorial/numpy.html) as a dependency like following

```python:setup.py
from distutils.core import setup
from distutils.extension import Extension
from Cython.Build import cythonize
import numpy

ext_modules = [
    Extension("calculate_y_function",
              sources=["calculate_y_cython.pyx"],
              libraries=["m"],
              compiler_directives={"language_level": "3"},
              )
]

setup(name="calculate Y function",
      ext_modules=cythonize(ext_modules),
      include_dirs=[numpy.get_include()])
```

The parameter _include_dirs_ includes external libraries like Numpy here.

```python
%%timeit -n 1000
n = 100000
res = calculate_y_cython(n)

"""Output:
208 µs ± 11.3 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
"""
```

The fully optimized version of Cython runs at **0.0002** seconds which is approximately **1000x** faster than the normal Python code.

The usage of Numpy and MemoryViews in Cython needs separate discussion and I will write about Classes, C-math, Numpy, MemoryViews, and OpenMP in the Advanced Cython series later.

---

Cython is a very powerful extension that we can use to speed up Python code. Sometimes it may not be possible to convert Python objects straight away like dictionaries (use C++ maps), so it's better to use Cython for repetitive tasks like loops, general functions with simple statements (like declaration and usage only), and math operations.

Learn more about Cython by referencing

- [Speeding up basic object operations in Cython
  ](http://blog.behnel.de/posts/tuning-basic-object-operations-in-cython.html)
- [Faster Python made easier with Cython’s pure Python mode](https://www.infoworld.com/article/3648539/faster-python-made-easier-with-cythons-pure-python-mode.html)
- [An Introduction to Just Enough Cython to be Useful](https://www.peterbaumgartner.com/blog/intro-to-just-enough-cython-to-be-useful/)
- [Cython notes and tips](https://nicolas-hug.com/blog/cython_notes)
- [(Github Issue) Improve cython interface with a more user-friendly compiling interface](https://github.com/cython/cython/issues/3974)
