{"pageProps":{"postsMetaData":[{"metadata":{"title":"Build Blog with Next.js and MDX & Deploy to Github Pages","description":"Create a blog with Next.js as Static Site Generator, MDX for writing content, Github Pages for deploying the static website. Also add SEO and Image optimization.","imgName":"nextjs.jpeg","date":"Dec 31, 2020","tags":["react","next-js"],"keywords":["react'","next.js","blog","mdx","markdown","gh-pages","github-pages"],"id":"build-blog-with-nextjs-mdx-and-deploy-to-github-pages"},"content":"\n![Build Blog with Next.js & MDX and Deploy to Github Pages](nextjs.jpeg)\n\n# Build Blog with Next.js & MDX and Deploy to Github Pages\n\nIn this post, we will discuss how to create and publish a blog with [Next.js](https://nextjs.org/), write content with [MDX](https://mdxjs.com/), deploy static site to Github Pages, Image optimization to reduce the page load time and SEO for better page ranking.\n\n> Pre-requisites: Basic understanding of React and Markdown. \n\nBuilding a blog with Next.js is very easy and it is simple to understand, develop, and maintain the dynamic websites and credit goes to Next.js dynamic paging which lets the creation of dynamic URLs and routing. When I decided to start my blog then I searched and read about many frameworks like Vanilla React, Gatsby, Hugo, etc., After reading many blogs, comments, and reviews I felt Next.js would be the option I was looking for. \n\nNext.js offers everything need to create a blog:\n- Static site export support\n- Dynamic routing\n- MDX (markdown with JSX) support\n- Image optimization\n- SEO\n\nNow dive in to create a simple blog\n\n## Setup Next.js and MDX\nNext.js is a React framework to create SPA (single page applications) and enables both static websites and server-side rendering. Here we'll focus only on static website generation.\n\n### Install Next.js\n\n[Install Next.js](https://nextjs.org/docs/getting-started#setup) by typing any of the following commands\n\n```bash\nnpx create-next-app\n# or\nyarn create next-app\n```\n\n_create-next-app_ installs everything needed to start with. \n\nThe most important thing in Next.js is the _pages_ directory. Every component exported from _.js_, _.jsx_, _.ts_, or _.tsx_ in the pages folder is treated as a page and each page associates with a route based on its file name. In the pages folder, the **App** component from _\\_app.js_ serves as the initialization of pages that can be edited for custom use like global style declaration, CDN's, etc., _index.js_ is the starting point for adding content.\n\nTo write content in articles we use MDX, which lets us write JSX in Markdown (_.mdx_ file). Writing in markdown is as beautiful as it is like writing in a text file and can render as HTML tags. Besides easy export and maintenance of articles, we can also reuse these files in another framework/platform which supports MDX without rewriting.\n\n### Install MDX\n\nInstall necessary plugins for MDX\n\n```bash\nyarn add @next/mdx gray-matter next-mdx-remote\n```\n\nWe installed _@next/mdx_ to handle _.mdx_ files in pages directory, _gray-matter_ is to parse content from markdown and _next-mdx-remote_ for rendering markdown as HTML.\n\nNow create / open _next.config.js_ (configuration file for Next.js) at the project root level and add the following to configure MDX and handle _.mdx_ page extensions in the pages folder.\n\n```js\nconst withMDX = require('@next/mdx')({\n  extension: /\\.mdx?$/,\n})\nmodule.exports = withMDX({\n  pageExtensions: ['js', 'jsx', 'mdx'],\n  target: 'serverless',\n})\n``` \nAs Next.js only looks for _.js_ or _.jsx_ files and gives routing to these pages, the above configuration tells Next.js to treat _.md_ or _.mdx_ files as pages and provide routing.\n\nAs we are creating a static site, **target: 'serverless'** notifies Next.js to generate static files for us.\n\nOpen _package.json_ file in the root directory and add **deploy** command to export all static files as a folder as _out_ (can have a different name) at the root level. After installing plugins and adding values _package.json_ might look like this\n\n```json\n{\n  \"name\": \"blog\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"export\": \"next export\",\n    \"deploy\": \"npm run build && npm run export\"\n  },\n  \"dependencies\": {\n    \"@next/mdx\": \"^10.0.4\",\n    \"gray-matter\": \"^4.0.2\",\n    \"imagemin-mozjpeg\": \"^9.0.0\",\n    \"imagemin-optipng\": \"^8.0.0\",\n    \"next\": \"10.0.4\",\n    \"next-mdx-remote\": \"^2.0.1\",\n    \"next-optimized-images\": \"^2.6.2\",\n    \"react\": \"17.0.1\",\n    \"react-dom\": \"17.0.1\",\n    \"webp-loader\": \"^0.6.0\"\n  }\n}\n\n```\n\nLet's give some break to configuration and take a turn to add some content.\n\n## Home Page\n\nAs said earlier _index.js_ is the pivot file and also the Home page for our website. So let's edit our Home page and customize it like below.\n\n```js:pages/index.js\nexport default function Home() {\n  return (\n    <div className = 'info-container'>\n      <img src = 'batman.png' alt = 'Batman Logo'/>\n      <p className = 'info-description'>Hi I'm Batman, the saviour of Gotham City and I like to roam in nights to bash the bad guys.</p>\n      <p className = 'info-description'>But please don't call me as a source for <b>Corona Virus</b> and it could be the <b>Joker</b> who \n      might have started this mess.</p>\n\n      <style jsx>{`\n        .info-container {\n          margin: 0 5% 0 5%;\n        }\n\n        img {\n          width: 20%;\n          max-width: 20%;\n          height: auto;\n          margin-left: 40%;\n        }\n\n        .info-description {\n          font-size: 20px;\n        }\n      `}</style>\n    </div>\n  )\n}\n```\n\nIn the above snippet, _CSS_ styles are provided inside the component. This is called **CSS-In-JS**, which is possible as Next.js bundles **styled-jsx**. There are many ways to add [CSS in Next.js](https://nextjs.org/docs/basic-features/built-in-css-support).\n\nIn the _img_ tag above, **src** is provided with the name of the image only but not relative/absolute path. In Next.js we don't need to provide complete paths if we place any assets (like images, videos) in the _public_ folder. Next.js automatically prepends the path at build time for assets in the public folder.\n\nNow to see changes, start localhost (default port is 3000) as a dev server\n```bash\n# starts localhost at port 8000\nyarn dev -p 8000\n```\n\nOpen any desktop browser and type URL http://localhost:port/ to see changes.\nFor the above code, the display is like below\n\n![First preview](nextjs-blog-display.jpg)\n\nWe have a home page with a welcome message. Now some create blog posts with MDX.\n\n## Write Blog Content with MDX\n\nCreate a directory to store our markdown posts at the root level or any accessible place. \n\n```shell\nmkdir posts\n```\n\nWrite some content in a markdown file and save it as '.mdx' inside the _posts_ directory. I have created two posts and saved them as _batman-vs-superman.mdx_ and _justice-league.mdx_.\n\n```markdown:posts/batman-vs-superman.mdx\n---\ntitle: \"Batman VS Superman\"\ndescription: \"An intense fight between two superheroes, me and Superman.\"\ndate: \"Mar 25, 2016\"\n---\n\n# Batman VS Superman\n\nI and Superman accidentally met (fight) and later realized there was a culprit (Lex Luthor) who we should fight.\n\nAs usual, it cost a whopping $250 million for this high-action story.\n```\n\n```markdown:posts/justice-league.mdx\n---\ntitle: \"Justice League\"\ndescription: \"Grand union with fellow superheroes which costs $300 million but received face slap from the audience.\"\ndate: \"Nov 17, 2017\"\n---\n\n# Justice League\n\nSuperheroes from the DC universe consisting of Superman, Wonder Woman, The Flash, Aquaman, and Cyborg and I met in 2017 to spoil the party plans of Steppenwolf who tried to steal Mother Boxes on Earth.\n\nIt's a very long story of how we met each other and all thanks to Avengers who had inspired me to search for other superheroes.\n```\n\nIn the above snippet content inside **---** is used as metadata to make routing for this _.mdx_ file. We'll discuss this later.\n\n## Show blog posts on the Home page\n\n### Fetch posts data\n\nTo show our blog posts on the Home page, we have to fetch the _.mdx_ files and parse content. We can also provide routing from the home page to any blog post. We write the logic to fetch the _.mdx_ files to read the content inside and extract metadata useful to display posts on the Home page. These files should be separated from routing, so at the root level create a folder called _lib_ where we store all program files to extract _.mdx_ content. Inside _lib_ create a file with name _getPostsData.js_ which returns posts data like markdown content, title, path, etc.,\n\n```js:lib/getPostsData.js\nconst fs = require('fs');\nconst path = require('path');\nconst matter = require(\"gray-matter\");\n\n// current 'posts' directory\nconst postsDirectory = path.join(process.cwd(), 'posts');\nconst mdx_file_extention = '.mdx';\n\nfunction getAllFilesInDirectory() {\n  const fileNames = fs.readdirSync(postsDirectory);\n  return fileNames.map((fileName) => {\n    return path.parse(fileName)\n  })\n}\n\nfunction getMdxFiles() {\n  const allFiles = getAllFilesInDirectory();\n  return allFiles.filter(parsedFile => parsedFile.ext == mdx_file_extention);\n}\n\nexport function getAllPostsPath() {\n  const allMdxFiles = getMdxFiles();\n  return allMdxFiles.map((parsedFile) => {\n    return {\n      params: {\n        id: parsedFile.name\n      }\n    }\n  })\n}\n\nexport function getPostsMetaData() {\n  const allMdxFiles = getMdxFiles();\n\n  const postsMetaData = allMdxFiles.map((parsedFile) => {\n    const fullPath = path.join(postsDirectory, parsedFile.base);\n\n    // get MDX metadata and content\n    const fileContents = fs.readFileSync(fullPath, 'utf8');\n    // get metadata, content\n    const { data, content } = matter(fileContents);\n    let metadata = data;\n    metadata['id'] = parsedFile.name;\n    return metadata;\n  });\n  return postsMetaData;\n}\n\nexport function getPostData(id) {\n  const fullPath = path.join(postsDirectory, id + mdx_file_extention);\n\n  // get MDX metadata and content\n  const fileContents = fs.readFileSync(fullPath, 'utf8');\n  // get metadata, content\n  const { data, content } = matter(fileContents);\n\n  let metadata = data;\n  metadata['id'] = id;\n\n  return {'metadata': metadata, 'content': content};\n}\n```\n\n**getAllPostsPath** function returns all _.mdx_ files path names to serve as URLs for dynamic routing of a page.\n\n**getPostsMetaData** function returns all _.mdx_ files metadata (data inside **---**) which we use to gather information like title, description, etc., and function **getPostsData** returns both metadata and markdown content to render for a particular file we request through argument **id**. **gray-matter** parses the markdown file into metadata (data inside **---**) and markdown content to render.\n\nIf encountered error while accessing **fs** add the following to _next.config.js_\n\n```js:next.config.js\nconst withMDX = require('@next/mdx')({\n  extension: /\\.mdx?$/,\n})\n\nmodule.exports = withMDX({\n\twebpack: (config, { isServer }) => {\n\t\tif (!isServer) {\n\t  \tconfig.node = {\n\t    fs: 'empty'\n\t \t\t}\n\t\t}\n\treturn config\n\t},\n  pageExtensions: ['js', 'jsx', 'mdx'],\n  target: 'serverless',\n})\n```\n### Provide posts data to Home page\n\nWe have to call the **getallPostsData** function to get data. But how can we pass this data to the component in _pages/index.js_? Don't worry we can pass data as **props** to the component before rendering using the [getStaticProps](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation) function. **getStaticProps** allows us to fetch any dynamic data to provide before rendering the component. Change _pages/index.js_ as \n\n```js:pages/index.js\nimport { getPostsMetaData } from '../lib/getPostsData.js';\n\nexport default function Home({ postsData }) {\n  return (\n    <div className = 'info-container'>\n      <img src = 'batman.png' alt = 'Batman Logo'/>\n      <p className = 'info-description'>Hi I'm Batman, the saviour of Gotham City and I like to roam in nights to bash the bad guys.</p>\n      <p className = 'info-description'>But please don't call me as a source for <b>Corona Virus</b> and it could be the <b>Joker</b> who \n      might have started this mess.</p>\n      <hr/>\n      {postsData.map((metadata) => {\n        return (\n          <div key = {metadata.id}>\n            <h2 className = 'post-title'>{metadata.title}</h2>\n            <p className = 'post-description'>{metadata.description}</p>\n          </div>\n          )\n        })}\n\n      <style jsx>{`\n        .info-container {\n          margin: 0 5% 0 5%;\n        }\n\n        img {\n          width: 20%;\n          max-width: 20%;\n          height: auto;\n          margin-left: 40%;\n        }\n\n        .info-description {\n          font-size: 20px;\n        }\n\n        .post-title {\n          font-size: 24px;\n          color: black;\n        }\n\n        .post-description {\n          font-size: 16px;\n          color: #000000e6;\n        }\n      `}</style>\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  const postsData = getPostsMetaData();\n  return {\n    props: {\n      postsData: postsData,\n    }\n  }\n}\n```\n\nWhich displays as \n\n![MDX blog posts display on Home page](blog-posts-display-on-home-page.jpg)\n\n## Rendering MDX and providing dynamic routing\n\nSo far so good until we want to display _.mdx_ files as individual webpages. Right now it is not possible because Next.js only treats components exported inside the _pages_ folder as webpages and provides routing, to provide routing for our posts we must export content from the _posts_ directory to the _pages_ folder. This is where we should spend some time to serve markdown files as webpages. \n\nThe beauty of Next.js is that we can dynamically serve pages by fetching these _.mdx_ files and provide routing inside the _pages_ directory with having dynamic pages.\n\nCreate _blog_ folder inside the _pages_ folder and inside this _blog_ folder create a file with name _[id].js_. Dynamic routes in Next.js are identified by _[]_ (square brackets) in the filename. We can provide any query parameter to this _[]_ page component which will end up as **http://localhost:8000/blog/post-name** for _post-name.js_. Now add following code to _pages/blog/_[id]_.js_\n\n```js:pages/blog/[id].js\nimport renderToString from 'next-mdx-remote/render-to-string';\nimport hydrate from 'next-mdx-remote/hydrate';\nimport { getAllPostsPath, getPostData } from '../../lib/getPostsData.js';\n\nconst components = {\n\th1: props => <h1 style = {{ \n\t\tfontSize: 'calc(1rem + 1.5vw)', \n\t\tcolor: 'black',\n\t\tmargin: '1vh 0 1vh 0', }} \n\t\t{...props} />,\n\n\tp: props => <p style = {{ \n\t\tfontSize: 'calc(1rem + 0.1vw)', \n\t\tcolor: '#000000e6',\n\t\tmargin: '0vh 0 1vh 0' }} \n\t\t{...props} />,\n}\n\nexport default function Blog({ postMetadata, postContent }) {\n\tconst content = hydrate(postContent, { components });\n\n\treturn (\n\t\t<div>\n\t\t\t<div className = 'blog-content'>\n\t\t\t\t{content}\n\t\t\t</div>\n\n\t\t\t<style jsx>{`\n\t\t\t\t.blog-content {\n\t\t\t\t\tdisplay: flex;\n\t\t\t\t\tflex: 100%;\n\t\t\t\t\tflex-direction: column;\n\t\t\t\t\tmargin: 1vw 25vw 1vw 25vw;\n\t\t\t\t\twidth: 50vw;\n\t\t\t\t\tmax-width: 50vw;\n\t\t\t\t}\n\t\t  `}</style>\n\t\t\t\n\t\t</div>\n\t)\n}\n\nexport async function getStaticPaths() {\n\tconst paths = getAllPostsPath();\n\treturn {\n\t\tpaths,\n\t\tfallback: false,\n\t}\n}\n\nexport async function getStaticProps({ params }) {\n\tconst postData = await getPostData(params.id);\n\tconst mdxSource = await renderToString(postData.content, { components });\n\treturn {\n\t\tprops: {\n\t\t\tpostMetadata: postData.metadata,\n\t\t\tpostContent: mdxSource,\n\t\t\tid: params.id,\n\t\t}\n\t}\n}\n```\n\nIf any page provides dynamic routing we must provide all dynamic paths we want to serve to this page through the [getStaticPaths](https://nextjs.org/docs/basic-features/data-fetching#getstaticpaths-static-generation) function.\n\nWith **renderToString** and **hydrate** we parse markdown content to HTML string and render as plain HTML. To style the HTML tags in markdown, we pass custom tags as components to the MDX loader which maps tags automatically. In the above file two tags, **h1** and **p** are customized and combined as components.\n\nNow in the browser hit URL **http://localhost:3000/blog/batman-vs-superman** or **http://localhost:3000/blog/justice-league** to see the post. You might see output similar to below\n\n![MDX Post Display](mdx-post-display.jpg)\n\n## Navigation from the Home page\n\nWhat if we want to navigate from the Home page to blog posts by clicking on the title of the post? For this Next.js provides a [next/link](https://nextjs.org/docs/api-reference/next/link) component that takes care of dynamic routing from any page to another by pre-pending the necessary path before the page to navigate like navigation to **batman-vs-superman** results as **http://localhost:3000/blog/batman-vs-superman**. We must navigate like this only if we are not pre-pending the base URL manually inside the website. Now change _pages/index.js_ to get dynamic navigation\n\n```js\nimport Link from 'next/link';\n{ ... }\n\n{postsData.map((metadata) => {\n  return (\n    <div key = {metadata.id}>\n      <Link href={`/blog/${metadata.id}`} key = {metadata.title} >\n        <a className = 'post-title'>{metadata.title}</a>\n      </Link>\n      <p className = 'post-description'>{metadata.description}</p>\n    </div>\n    )\n  })}\n\n { ... }\n```\n\n## Image Optimization\n\nImages take a lot of space in a webpage which reduces page loading time results in poor performance if the user has a poor internet connection. Images can be optimized many ways like converting all PNG/JPEG files to Webp/JPEG2000 format, [responsive images](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images) for different screen dimensions by rescaling images, lazy loading, etc.,\n\nNext.js provides [next/image](https://nextjs.org/docs/api-reference/next/image) API for image optimization. But it needs the **next start** that runs on the node server which is not possible for static site generation. So we will use another plugin [next-optimized-images](https://github.com/cyrilwanner/next-optimized-images) which provides many options to optimize images.\n\nHere we will optimize images to serve in Webp format, to do so install **next-optimized-images**\n\n```shell\nnpm install next-optimized-images\n```\n\nBesides this install some additional plugins to convert PNG/JPEG to Webp format and loading Webp images.\n\n```shell\nnpm install imagemin-mozjpeg imagemin-optipng webp-loader\n```\n\nand change _next.config.js_ as\n\n```js:next.config.js\nconst withNextOptimizedImages = require('next-optimized-images');\n\nconst withMDX = require('@next/mdx')({\n  extension: /\\.mdx?$/,\n})\n\nmodule.exports = withNextOptimizedImages(\n\twithMDX({\n\t\twebpack: (config, { isServer }) => {\n\t\t\t\tif (!isServer) {\n\t\t  \t\tconfig.node = {\n\t\t    \tfs: 'empty'\n\t\t \t\t}\n\t\t\t}\n\t\t\treturn config\n\t\t},\n\t  pageExtensions: ['js', 'jsx', 'mdx'],\n\t  target: 'serverless',\n\t})\n)\n```\n\nIn build time **next-optimized-images** exports optimized images to _images_ (custom name) folder inside _out/_next/static_. So create _images_ directory at the root level and move images to this folder which needs optimization and provide relative paths now which were previously not required because of the _public_ folder.\n\nChange the **img** tag in _pages/index.js_ to\n\n```jsx\n<picture>\n  <source srcSet={require('../images/batman.png?webp')} type=\"image/webp\" />\n  <source srcSet={require('../images/batman.png')} type=\"image/png\" />\n  <img src={require('../images/batman.png')} alt = 'Batman Logo' />\n</picture>\n```\n\nThis will convert a PNG image to Webp format and loads Webp images. If the browser doesn't support Webp images **<picture\\>** will automatically load the normal PNG image.\n\nYou can more than this by exploring more about this plugin.\n\n## SEO in Next.js\n\nFor Single Application Websites (SPA) SEO is a major problem which Next.js takes care of this by providing API [next/head](https://nextjs.org/docs/api-reference/next/head) which behaves exactly like **<head\\>** in HTML. We can wrap meta properties, title, description, Open Graph (OG) properties, Twitter cards, etc., inside the **Head** component. For our Home page we can set title and description as \n\n![Seo in Next.js,80](seo-in-nextjs.jpg)\n\nIf you don't want to set meta properties, title, description, and others there are so many plugins like [next-seo](https://www.npmjs.com/package/next-seo) available which handle all of these manual adding for you.\n\n---\n\n## Deploy to Github pages\n\n### Export static files to deploy\n\nNow our website is ready to move from development to production. To host our site we can use the static-site-generator of Next.js to generate all pre-render pages bundled inside the _out_ directory. Build and generate _out_ directory by typing the below command in the terminal\n\n```shell\nyarn deploy\n```\n\nYou can find a new directory _out_ at the root level which contains all dynamic pages pre-rendered and ready to serve as HTML pages on the client-side. We will use this folder to host our website on Github pages.\n\n### Set up Github Pages\n\nGithub Pages is a very great place to host static sites. But we need to push and configure deployment changes every time we add content to the website. This is where we utilize Github Actions which automates deployment actions according to the configuration file we provide. But first, create a repository in Github to store our code files and push source code to this repository on the **main** branch. We use the **gh-pages** branch to which Github Actions deploy static files for hosting. \n\nTo do this we must provide access for Github Actions to this repository to access source files. To provide access, go to [Github Settings -> tokens](https://github.com/settings/tokens) and create a new **personal access token** by checking **repo** scopes and others if you need and save as **GITHUB_TOKEN** (or any other name). Copy this **access code** and in the repository, move to the **secretes** tab in the **Settings** section and create a new secrete and copy this code. Remember the name of the secrete token you created in this repo for future purposes. \n\n![Github Repository Secretes Token,80](github-repo-secretes-token.jpg)\n\nIt's time to configure GitHub Actions. Create a directory called _.github/workflows_ at the root level locally. Create a file _integrate.yml_ inside _.github/workflows_ and add the following configuration\n\n```yaml:.github/workflows/integrate.yml\nname: Build and Deploy\non: \n  push:\n    branches:\n      - master\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2.3.1\n        with:\n          persist-credentials: false\n\n      - name: Cache\n        uses: actions/cache@v2\n        with:\n          path: ${{ github.workspace }}/.next/cache\n          key: ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}\n\n      - name: Install and Build\n        uses: actions/setup-node@v1\n      - run: npm install\n      - run: npm run build\n      - run: npm run export\n        env:\n            CI: true\n      - run: touch out/.nojekyll\n\n      - name: Deploy\n        uses: JamesIves/github-pages-deploy-action@3.7.1\n        with:\n          ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }}\n          BRANCH: gh-pages \n          FOLDER: out\n          CLEAN: true\n```\nYou may have to replace **ACCESS_TOKEN** with your custom name. This is what we configured\n\n1. Execute workflow action on every push to the **master** branch.\n2. Run commands **npm install && npm run build && npm run export** to build and export static version of our website.\n3. Deploy contents inside _out_ folder to the **gh-pages** branch.\n4. Added **touch out/.nojekyll** to **gh-pages** because Github pages **Jekyll** to render static sites. **Jekyll** ignores files in the directory starting with **_** and it is an issue for us because all our static assets are created in _\\_next_ folder. _.nojekyll_ tells Github Pages not to run published files through **Jekyll**.\n\nPush all changes to Github repo\n\n```shell\ngit add .\ngit commit -m \"initial deployment of the blog\"\ngit push -u origin master\n```\n\nThis will push all your working source files to the Github repo and Github Actions starts a workflow to deploy static files in the _out_ folder to **gh-pages**.\n\nYou can monitor the status of the Github Actions workflow after every push to the **master** branch in the **Actions** tab.\n\nEnable Github Pages in the **Settings** section of the repo and for source select the **gh-pages** branch.\n\nIf everything worked properly you can have your website hosted at _https://<username\\>.github.io/<repo\\>_. Here _<repo\\>_ name is _blog_. \n\n---\n\n## Manage CSS, assets, and page links to work properly\n\nIf you host the website at _https://<username\\>.github.io/<repo\\>_ you can observe CSS or other static assets and routing not working properly. This is because Next.js assumes _out_ directory hosted at root level as _https://<username\\>.github.io/_ and directs all routing, replaces assets and everything to this basepath. But we have hosted the _out_ folder in _blog/out_, so we must add **subpath** _blog_ to the **basepath** to manage assets linking and routing. We can do this by changing the configuration in _next.config.js_\n\n```js:next.config.js\nconst ghPages = process.env.DEPLOY_TARGET === 'gh-pages';\n\nconst withNextOptimizedImages = require('next-optimized-images');\n\nconst withMDX = require('@next/mdx')({\n  extension: /\\.mdx?$/,\n})\n\nmodule.exports = withNextOptimizedImages(\n\twithMDX({\n\t\twebpack: (config, { isServer }) => {\n\t\t\tif (!isServer) {\n\t\t  \tconfig.node = {\n\t\t    fs: 'empty'\n\t\t \t\t}\n\t\t\t}\n\t\t\treturn config\n\t\t},\n\t  pageExtensions: ['js', 'jsx', 'mdx'],\n\t  target: 'serverless',\n\t\tbasePath: ghPages? '/blog/' : '',\n\t\tassetPrefix: ghPages ? '/blog/' : '',\n\t})\n)\n```\n\nWhile developing it works fine everything, so we check the environment phase we are processing with **process.env** and **process.env.DEPLOY_TARGET** tells the current hosted environment. In local development, we run on the **node** server hosted on our machine so we don't need to manage any **basepath** or **subpath**. \n\n**basePath** specifies the base path of the application to manage linking pages. If we are on the **gh-pages**, the base path **/blog/** resolves to **username.github.io/blog/** where **/** is the home path.\n\n**assetPrefix** specifies where to look for assets (CSS, Images, etc.,).\n\n---\n\nAnd here we are with our personal blog on the internet and we can take our blog to next level by adding fancy CSS, custom components, and other pages like **about**, **contact**... Only sky is the limit for human creativity and I hope you will create your website better than mine. In the end, I hope you got some useful information from this article to build your own blog. If you are curious to check the source code of this website, you can find it on [github.com/santhalakshminarayana/santhalakshminarayana.github.io](https://github.com/santhalakshminarayana/santhalakshminarayana.github.io)."}]},"__N_SSG":true}