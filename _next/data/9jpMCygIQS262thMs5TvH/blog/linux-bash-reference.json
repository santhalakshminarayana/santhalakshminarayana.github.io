{"pageProps":{"postMetadata":{"title":"Linux Bash reference","description":"Linux Bash reference for bash scripting with comprehensive list of helpful features.","imgName":"linux-bash-reference/linux-bash-reference.jpg","date":"Apr 22, 2025","tags":["linux"],"keywords":["linux","linux-bash","bash","bash-scripting"],"id":"linux-bash-reference"},"postContent":{"compiledSource":"var c=Object.defineProperty,u=Object.defineProperties;var h=Object.getOwnPropertyDescriptors;var i=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,o=Object.prototype.propertyIsEnumerable;var l=(t,a,n)=>a in t?c(t,a,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[a]=n,e=(t,a)=>{for(var n in a||(a={}))s.call(a,n)&&l(t,n,a[n]);if(i)for(var n of i(a))o.call(a,n)&&l(t,n,a[n]);return t},p=(t,a)=>u(t,h(a));var m=(t,a)=>{var n={};for(var r in t)s.call(t,r)&&a.indexOf(r)<0&&(n[r]=t[r]);if(t!=null&&i)for(var r of i(t))a.indexOf(r)<0&&o.call(t,r)&&(n[r]=t[r]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var r=n,{components:t}=r,a=m(r,[\"components\"]);return mdx(MDXLayout,p(e(e({},layoutProps),a),{components:t,mdxType:\"MDXLayout\"}),mdx(\"p\",null,mdx(\"img\",e({parentName:\"p\"},{src:\"linux-bash-reference/linux-bash-reference.jpg\",alt:\"Linux Bash reference for bash scripting\"}))),mdx(\"h6\",null,\"Published on: \",mdx(\"strong\",{parentName:\"h6\"},\"Apr 22, 2025\")),mdx(\"h1\",null,\"Linux Bash Scripting\"),mdx(\"p\",null,\"Bash scripting is like general programming language and is basically writing Linux commands in a file and executing them in one go. This is very helpful in executing a series of commands in a single file where each step depends on the previous operation. Bash supports almost all features that normal programming language supports. Bash scripting is widely used in system admin tasks, system configuration, server automation, etc. \"),mdx(\"p\",null,\"The following sections describe the bash features and they are more like a reference than an actual tutorial or something.\"),mdx(\"h3\",null,\"Running bash script\"),mdx(\"p\",null,\"Save the file with .sh extension and give necessary permissions to execute like \",mdx(\"em\",{parentName:\"p\"},\"chmod +x script.sh\"),\". And execute the shell script as \",mdx(\"em\",{parentName:\"p\"},\"bash script.sh\"),\" or \",mdx(\"em\",{parentName:\"p\"},\"./script.sh\"),\".\"),mdx(\"p\",null,\"The bash script runs in a new subshell. So, the custom system configuration won't be applied in the script execution.\"),mdx(\"p\",null,\"Use \",mdx(\"em\",{parentName:\"p\"},\"set -ueo pipefail\"),\" at the start of the script to exit when an error occurs in the pipeline, and also if there are any unset variables.\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-shell\"}),`#!/bin/bash\n\nset -ueo pipeline\n\n...\n`)),mdx(\"h3\",null,\"Subshell\"),mdx(\"p\",null,\"A subshell is another shell/process spawned within the current shell that inherits all environment, variables, and current config from its parent process. The subshell runs in an isolated environment compared to the parent. A subshell is created when the following syntax is used\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Parenthesis: \",mdx(\"em\",{parentName:\"li\"},\"()\")),mdx(\"li\",{parentName:\"ul\"},\"Command substitution: \",mdx(\"em\",{parentName:\"li\"},\"$()\"))),mdx(\"h3\",null,\"I/O Redirection\"),mdx(\"p\",null,\"Redirection controls where to get input and where to send output.\"),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"Standard File Descriptors (FD)\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"0: Standard Input (stdin)\"),mdx(\"li\",{parentName:\"ul\"},\"1: Standard Output (stdout)\"),mdx(\"li\",{parentName:\"ul\"},\"2: Standard Error (stderr)\")),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"Input Redirection\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Send stdin to a command from a file as: \",mdx(\"em\",{parentName:\"li\"},\"command < input.txt\")),mdx(\"li\",{parentName:\"ul\"},\"| (Pipe): Pipe connects the stdout of the command on the left to the stdin of the command on the right.\"),mdx(\"li\",{parentName:\"ul\"},\"Process substitution: Process substitution passes outputs of multiple passes to stdin for another command. Ex: \",mdx(\"em\",{parentName:\"li\"},\"cat <(ls -l) <(ls -la)\")),mdx(\"li\",{parentName:\"ul\"},mdx(\"strong\",{parentName:\"li\"},\"herestring\"),\": Here-string (<<<) passes string directly to standard input for a command. Instead of \",mdx(\"em\",{parentName:\"li\"},'echo \"abc def\" | wc -w'),\", use \",mdx(\"em\",{parentName:\"li\"},'wc -w <<< \"abc def')),mdx(\"li\",{parentName:\"ul\"},mdx(\"strong\",{parentName:\"li\"},\"heredocs\"),\": Here documents pass multi-line input/strings to a command. The command should be anything that accepts the standard input. \")),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-shell\"}),`# Syntax\n<command> <<'DELIMETER' \nmulti-line input/text\nDELIMETER\n\n# example, send the heredoc input to sys.conf\ncat <<'CONF' > sys.conf\nPORT=$port\nENV=$env\nCONF\n`)),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"Output Redirection\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"For saving output to a file from a command, using the \",mdx(\"em\",{parentName:\"li\"},\">\"),\" operator will create a new file and write to it. If the file doesn't exist it will create a new file. \"),mdx(\"li\",{parentName:\"ul\"},mdx(\"em\",{parentName:\"li\"},\">>\"),\" will append to the existing file.\"),mdx(\"li\",{parentName:\"ul\"},\"Redirect stderr to a file: \",mdx(\"em\",{parentName:\"li\"},\"command 2> error.log\")),mdx(\"li\",{parentName:\"ul\"},\"Redirect stdout and stderr: \",mdx(\"em\",{parentName:\"li\"},\"commmand > res.txt 2> err.txt\")),mdx(\"li\",{parentName:\"ul\"},\"Redirect both stdout and stderr to the same file: \",mdx(\"em\",{parentName:\"li\"},\"command &> log.txt\"),\" or \",mdx(\"em\",{parentName:\"li\"},\"command > log.txt 2>&1\"))),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"Special Files\"),`\nSpecial files expose hardware devices as files in the system. Character special files (listed below) are helpful in redirecting the I/O.`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"/dev/stdin: Symlink to file descriptor 0 (standard input)\"),mdx(\"li\",{parentName:\"ul\"},\"/dev/stdout: Symlink to file descriptor 1 (standard output)\"),mdx(\"li\",{parentName:\"ul\"},\"/dev/stderr: Symlink to file descriptor 2 (standard error)\"),mdx(\"li\",{parentName:\"ul\"},\"/dev/tty: Represents the terminal connected to the current process\"),mdx(\"li\",{parentName:\"ul\"},\"/dev/null: Discards all data written to it\")),mdx(\"h3\",null,\"Command-line arguments & Pre-pending variables\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-shell\"}),`#!/bin/bash\n\n: <<'MCOMMENT'\nAssume for this script, command line arguments are passed as:\n> ./script.sh \"a\" \"b\" \"c\"\n\nCommand line arguments follow the same rules as bash variables. So, passing \narguments as \"a b\" or '$var' will be expanded just like as bash variables.\nMCOMMENT\n\n# Access command line argument as\necho \"$1\", \"$2\" # a b\n# For argument greater than '9', enclose the number with {}\necho \"\\${13}\"\n\n# '$#' is for no.of arguments, '$@' is for all arguments\necho \"$#\" # 3\necho \"$@\" # a b c\n\n# Read all arguments to array\narr=()\nfor arg in \"$@\"; do\n    arr[i]=$arg\n    i=$((i + 1))\ndone\n\necho \"$arr\"\n\n: <<'MCOMMENT'\nPre-pending variables as\n> ENV_MODE=\"DEV\" DEPLOY_MODE=\"STAGING\" ./script.sh \"arg1\" \"arg2\"\n\nThese variables are only scoped to the current script context.\nMCOMMENT\n\necho \"$ENV_MODE\"    # DEV\necho \"$DEPLOY_MODE\" # STAGING\n`)),mdx(\"h3\",null,\"Variables inside strings\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-shell\"}),`#!/bin/bash\n\nname_msg=\"Hi Nomina\"\necho $name_msg. Welcome. # Hi Nomina. Welcome.\n\n# Single quotes\necho '$name_msg' # $name_msg\n\n# Backquotes or Command Substitution\nusr_name=\"uname\"\necho \\`$usr_name\\` # Linux\necho $($usr_name) # Linux\n\n# Without curly brackets\ndir_name=\"/usr/bin\"\necho \"$dir_name_prod/env\" # /env\n\n# With curly brackets\necho \\${dir_name}_prod/env # /usr/bin_prod/env\n`)),mdx(\"h3\",null,\"Expressions\"),mdx(\"p\",null,\"For expressions: \"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Use \",mdx(\"em\",{parentName:\"li\"},\"$((x + y))\")),mdx(\"li\",{parentName:\"ul\"},\"Or \",mdx(\"em\",{parentName:\"li\"},\"$((\",\"$\",\"x + \",\"$\",\"y))\")),mdx(\"li\",{parentName:\"ul\"},\"Or \",mdx(\"em\",{parentName:\"li\"},\"(( x += 1))\"),mdx(\"blockquote\",{parentName:\"li\"},mdx(\"p\",{parentName:\"blockquote\"},\"Note: This will concat the numbers: \",mdx(\"em\",{parentName:\"p\"},\"z=\",\"$\",\"x+\",\"$\",\"y\"))))),mdx(\"p\",null,\"Command substitution: capture output of a command to another command\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"em\",{parentName:\"li\"},\"x=\",\"`\",'echo \"Hi \"$name',\"`\")),mdx(\"li\",{parentName:\"ul\"},mdx(\"em\",{parentName:\"li\"},'x=$(echo \"Hi \"',\"$\",\"name)\"))),mdx(\"p\",null,\"For arithmetic operations natural results use \",mdx(\"em\",{parentName:\"p\"},'bc -l <<< \"',\"$\",\"x/\",\"$\",'y\"')),mdx(\"h3\",null,\"Conditional statements\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"The \",mdx(\"em\",{parentName:\"li\"},\"test\"),\" command takes an expression and evaluates it. Successful test returns with status code 0.\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"em\",{parentName:\"li\"},\"[]\"),\" is an alternative for the test command. It requires at least a single space after opening and before closing.\"),mdx(\"li\",{parentName:\"ul\"},\"Use \",mdx(\"em\",{parentName:\"li\"},\"[[]]\"),\" instead of \",mdx(\"em\",{parentName:\"li\"},\"[]\"),\" in conditions for better and advanced behaviour.\")),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"Equality and Pattern Matching\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Use \",mdx(\"em\",{parentName:\"li\"},\"= or ==\"),\" to compare match globs like \",mdx(\"em\",{parentName:\"li\"},\"if [\",'[ \"$file\" = ',\"*\",\".txt ]\",\"]\")),mdx(\"li\",{parentName:\"ul\"},mdx(\"em\",{parentName:\"li\"},\"=~\"),\" is a condition to match the pattern like \",mdx(\"em\",{parentName:\"li\"},\"if [\",'[ \"$x\" =~ \"\\\\<pattern',\">\",'\" ]',\"]\"),\" \"),mdx(\"li\",{parentName:\"ul\"},\"For substring check, \",mdx(\"em\",{parentName:\"li\"},\"if [\",'[ \"$x\" == ',\"*\",\"substring\",\"*\",\" ]\",\"]\")),mdx(\"li\",{parentName:\"ul\"},\"Capture regex group matches with \",mdx(\"em\",{parentName:\"li\"},\"$\",\"{BASH_REMATCH\",\"[n]\",\"}\"))),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"Word based operators with \",mdx(\"em\",{parentName:\"strong\"},\"[]\"),\" and Symbols with \",mdx(\"em\",{parentName:\"strong\"},\"[[]]\")),\":\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-text\"}),`-a &&\n-o ||\n-eq = or ==\n-ne !=\n-gt >\n-ge >=\n-lt <\n-le <=\n-z (true if string is empty or null)\n-n (true if string is not null)\n=~ (to use regex like [[ ... =~ ... ]])\n`)),mdx(\"p\",null,\"Some file operators\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-text\"}),`-e (true if file exists)\n-f (true if the variable is file)\n-d (true if the variable is directory)\n-t (true if file associates with terminal device)\n-r (true if file has read permissions for effective user id (EUID))\n-w (true if file has write permissions)\n-x (true if file has execute permissions)\n`)),mdx(\"hr\",null),mdx(\"h3\",null,\"Control flow\"),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"Conditionals\"),\" \"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-shell\"}),`#!/bin/bash\n\n# if\nif [[ : ]]; then\n    :\nfi\n\n# if-else\nif [[ : ]]; then\n    :\nelse\n    :\nfi\n\n# if-elif-else\nif [[ : ]]; then\n    :\nelif [[ : ]]; then\n    :\nelse\n    :\nfi\n\n# nested-if\nif [[ : ]]; then\n    :\n    if [[ : ]]; then\n        :\n    fi\nfi\n`)),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"Case Pattern Matching\")),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-shell\"}),`#!/bin/bash\n\n# case\nx=\"1\"\ncase $x in\n0) echo \"0\" ;;\n1) echo \"1\" ;;\n*) echo \"none\" ;; # default case\nesac\n\n\n# case, match multiple patterns\nx=\"3\"\ncase $x in\n0|1|2) echo \"<= 2\" ;;\n3|4|5) echo \"<=5\" ;;\n*) echo \"none\" ;; # default case\nesac\n\n# case with \";&\" to go to the next statement even if it doesn't match\nx=\"3\"\ncase $x in\n3) echo \"matched\" ;&\n5) echo \"this will also print\" ;;\nesac\n\n# case with \";;&\" to go to next only if matches\nx=\"3\"\ncase $x in\n3) echo \"matched\" ;;&\n5) echo \"this will not print\" ;;&\n[0-9]) echo \"but this will\" ;;\nesac\n`)),mdx(\"p\",null,mdx(\"strong\",{parentName:\"p\"},\"Loops\")),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-shell\"}),`#!/bin/bash\n\n# c-style for loop\nfor (( i=0; i<\"$#\"; i++ )); do\n  :\ndone\n\n# loop over a range\n# where 100 is in the inclusive range\nfor i in {1..100}; do\n  :\ndone\n\n# loop for multiple elements\n# this will loop over all files with a pattern\nfor file in *.txt; do\n  :\ndone\n\n# example\nIFS=',' read -ra arr <<< \"1,2,3\"\nfor i in \"\\${arr[@]}\"; do\n  echo \"$i\"\ndone\n\n# while loop\ni=0\nwhile [[ $i <= 3 ]]; do\n  (( i++ ))\ndone\n\n# while until loop\nwhile read -r line; do\n  echo \"read: $line\"\ndone < file.txt\n\n# unitl: loop over condition becomes true (differ to while)\ni=0\nuntil [[ $i >= 3 ]]; do\n  (( i++ ))\ndone\n`)),mdx(\"hr\",null),mdx(\"h3\",null,\"Arrays\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-shell\"}),`#!/bin/bash\n# IFS is mostly \" \\\\t\\\\n\" i.e., space, tab, or new line\narr=()\nx=\"abc def\"\n# If variables are not quoted, the value split into multiple based on IFS\narr+=($x)\necho \\${#arr[@]} # 2\n\n# If quoted\narr=()\narr+=(\"$x\")\necho \\${#arr[@]} # 1\n\n# Without \"\", array values split for each element based on IFS\narr=(\"abc\" \"abc def\" \"def\")\narr2=()\nfor i in \\${arr[@]}; do\n  arr2+=(\"$i\")\ndone\necho \\${#arr2[@]} # 4\npIFS=$IFS\nIFS=','\necho \"\\${arr2[*]}\" # abc,abc,def,def\nIFS=$pIFS\n\n# With \"\"\narr2=()\nfor i in \"\\${arr[@]}\"; do\n  arr2+=(\"$i\")\ndone\necho \\${#arr2[@]} # 3\npIFS=$IFS\nIFS=','\necho \"\\${arr2[*]}\" # abc,abc def,def\nIFS=$pIFS\n`)),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},\"Use Associative Arrays for more advanced array behavior.\")),mdx(\"hr\",null),mdx(\"h3\",null,\"Strings\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-shell\"}),`#!/usr/bin/env bash\n\n# Concatenation\nx=\"\"\nx+=\"1\"\nx+=\"2 3\"\necho \"$x\" # 12 3\n\nx=\"1\"\ny=\"2 3\"\nz=\"$x $y\" # 1 2 3\necho \"$z\"\n\n# Length\necho \\${#z} # 5\n\n# Slicing\nx=\"1 2 3 4 5\"\n# \\${str:pos} from starting position to end\necho \\${x:2} # 2 3 4 5\n# \\${str:pos:len} sub-string from that position with length\necho \\${x:2:5} # 2 3 4\n# \\${str:(-n)} from last 'n' character\necho \"\\${x:(-3)}\" # 4 5\n# \\${str:pos:\\${#str}-n} sub-string from position to last 'n'th position\necho \"\\${x:2:\\${#x}-4}\" # 2 3 4\n\n`)),mdx(\"hr\",null),mdx(\"h3\",null,\"Functions\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-shell\"}),`#!/bin/bash\n\n# A function can be defined as\nfunction f1 {\n    :\n}\n\n# or\n\nf2() {\n    :\n}\n\n# there is no explicit declaration for function parameters, as the\n# arguments are passed to function just like script command line arguments\n# function is invoked with its name and any arguments\nf1 \"a\" \"b\"\n\n# function can access the arguments the same as the script with $1, $2, ... or $@\nf3() {\n    echo \"received arguments for func \\${FUNCNAME[0]}:\" \"$@\"\n}\n\nf3 \"a\" \"b\" # received arguments for func f3: a b\n\n# function can return values or exit status (only numerics)\nf4() {\n    if [[ $# == 2 ]]; then\n        return 0\n    else\n        return 1\n    fi\n}\n\nf4 1 2\necho $? # 2\n\n# if the functions called in the same shell,\n# outside function scope, those variables can be assessed\nf5() {\n    x=10\n}\n\nf5\necho $x # 10\n`)),mdx(\"p\",null,\"To return/access other types, store the standard output of the function with command substitution/sub-shell\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-shell\"}),`#!/bin/bash\n\n# capture stdout by calling a function inside sub-shell\nf() {\n    echo $(($1 + $2))\n}\n\necho \"Sum is $(f 1 2)\" # Sum is 3\n\n# as the function is called inside the sub-shell,\n# the variables declared inside the function can't be accessed outside\nf() {\n    x=10\n    echo \"Value is $x\"\n}\n\necho $(f)                   # Value is 10\necho \"function value is $x\" # function value is\n`)),mdx(\"p\",null,\"If functions are called inside command substitution like \",mdx(\"inlineCode\",{parentName:\"p\"},\"$(func1 par1 par2)\"),\" and the stdout is captured, then every function statements stdout will be returned like\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-shell\"}),`#!/bin/bash\n\nf() {\n    printf \"received %s, %s\" $1 $2\n    echo $(($1 + $2))\n}\n\nres=$(f 1 2)\necho \"Sum is $res\" # Output: Sum is received 1, 23\n`)),mdx(\"p\",null,\"To avoid this, redirect the stdout and stderr of each statement (if any) to the terminal output\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-shell\"}),`#!/bin/bash\n\nf() {\n    printf \"received %s, %s\\\\n\" $1 $2 >/dev/tty\n    echo $(($1 + $2))\n}\n\nres=$(f 1 2)\necho \"Sum is $res\" # Output: Sum is 3\n`)),mdx(\"hr\",null),mdx(\"h3\",null,mdx(\"em\",{parentName:\"h3\"},\":\"),\" null command\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"em\",{parentName:\"li\"},\":\"),\" command does nothing and returns status 0\"),mdx(\"li\",{parentName:\"ul\"},\"Use the \",mdx(\"em\",{parentName:\"li\"},\":\"),\" (null or no-op) command to avoid syntax errors when the block is empty like\")),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-shell\"}),`if [[ <condition> ]]; then\n  :\nelse\n  echo \"Condition failed\"\nfi\n\n# or\n\nfor :; do\n  echo \"Continuous loop\"\ndone\n\n# or, for parameter expansion if unset like below instead of x=\\${x:=\"default\"}\n: \"\\${x:=\"default\"}\"\n`)),mdx(\"hr\",null),mdx(\"p\",null,\"These are all building blocks for writing bash scripts, combine these with other linux commands to build advanced scripts.\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"id":"linux-bash-reference"},"__N_SSG":true}