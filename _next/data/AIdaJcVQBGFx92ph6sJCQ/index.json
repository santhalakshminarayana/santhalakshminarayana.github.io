{"pageProps":{"postsMetaData":[{"metadata":{"title":"Super fast Python (Part-5): Numba","description":"Speed up Numerical computations and functions in Python with Numba and Numpy.","imgName":"super-fast-python-numba/super-fast-python-numba.jpg","date":"Dec 25, 2022","tags":["python-performance"],"keywords":["numba","python-performance'","python-optimize","python","fast-python","speed","jit","numba-numpy"],"id":"super-fast-python-numba"},"content":"\n![Super fast Python: Numba](super-fast-python-numba/super-fast-python-numba.jpg)\n\n# Super fast Python (Part-5): Numba\n\nThis is the fifth and last post in the series on Python performance and Optimization. The series points out the utilization of inbuilt libraries, low-level code conversions, and other Python implementations to speed-up Python. The other posts included in this series are \n\n- (Part-1): [Why Python is slow?](https://santhalakshminarayana.github.io/blog/super-fast-python-why-python-slow)\n- (Part-2): [Good practices to write fast Python code](https://santhalakshminarayana.github.io/blog/super-fast-python-good-practices)\n- (Part-3): [Multi-processing in Python](https://santhalakshminarayana.github.io/blog/super-fast-python-multi-processing)\n- (Part-4): [Use Cython to get speed as fast as C](https://santhalakshminarayana.github.io/blog/super-fast-python-cython)\n- (Part-5): Use Numba to speed up Python Functions (this post)\n\nIn the last post about [Cython to speed-up Python code](https://santhalakshminarayana.github.io/blog/super-fast-python-cython), we discussed writing Python code in C-style, compiling that code separately into an object file, and using that generated file as an import directly into Python. But, not all people would feel comfortable writing C-style code or even some might not know C at all. So, to deal with such cases and get the performant efficient code to speed-up Python, one can use [Numba](https://numba.pydata.org/) instead. Numba translates Python code to machine code that executes almost as fast as C/C++ if optimized correctly.\n\n## What is Numba?\n\nNumba is a JIT (just-in-time) compiler that takes Python byte code and compiles it into machine code directly using [LLVM](https://llvm.org/) compiling mechanism. JIT is a type of interpreter that compiles frequently called code into machine code and caches that generated machine code to be used later for faster execution type. Here, Numba also takes Python code and generated machine code which the Python interpreter calls directly instead of interpreting and converting to machine code each time. Numba works best for numerical calculations, Array and Numpy operations, and loops. With Numba, we can write vectorized operations and parallelized loops to run on either CPU or GPU. \n\nNumba decorators are one of the many ways to invoke the JIT compilation. Numba provides different decorators to compile code in different modes and types, the common decorators used in Numba are:\n- @jit - invoke JIT compilation for the provided function\n- @njit - @jit decorator with enabling strict no-python mode\n- @vectorize - convert normal functions into Numpy like **ufuncs**\n- @guvectorize - generalized **ufuncs** for higher dimensional arrays\n- @stencil - make a function behave as a kernel for a **stencil** like operation\n\nNumba also provides different options to pass for some of these decorators to configure the JIT compilation behavior\n- nopython\n- parallel\n- cache\n- nogil\n- fastmath\n- boundscheck\n- error_model\n- cuda\n\n## Numba @jit\n\n**@jit** decorator takes the Python function that needs to machine code compiled. When we make a call to the function we provided to **@jit**, upon the first time calling, Numba compiles the function, caches the machine code, and this machine code is directly used for the execution. As compilation takes time, the first-time call to the function gives some latency. But, for consecutive function calls in the same runtime, just the cached machine code is used instead of re-compiling every time. \n\nLet's consider the following simple function *solve_expression* as an example. *solve_expression* takes some arguments, checks some conditions, and calculates the final polynomial expression. \n\n```python\ndef solve_expression(x, a, b, c, d):\n    A, B, C, D = a, b, c, d\n    if a > 10.1:\n        A = 2 * a\n    if 2.6 <= b < 8.3:\n        B = b - 1/b\n    if c > 4.5:\n        C = 4\n    if d < 9.0:\n        D = d ** 2\n    \n    return A*(x**3) + B*(x**2) + C*(x) + D\n```\n\nNow, use the **@jit** decorator to compile this function into machine code as \n\n```python\nfrom numba import jit\n\n@jit\ndef solve_expression(x, a, b, c, d):\n    A, B, C, D = a, b, c, d\n    if a > 10.1:\n        A = 2 * a\n    if 2.6 <= b < 8.3:\n        B = b - 1/b\n    if c > 4.5:\n        C = 4\n    if d < 9.0:\n        D = d ** 2\n    \n    return A*(x**3) + B*(x**2) + C*(x) + D\n```\n\nIn the code snippet, we have imported the **jit** function decorator and decorated *solve_expression* with it.\n\n```python\nx, a, b, c, d = 2, 13, 1.2, 4, 7\n\nres = solve_expression(x, a, b, c, d)\n``` \n\n> Inspect the Intermediate Representation (IR) of the function using solve_expression.inspect_types()\n\nAs Numba **@jit** defers the JIT compilation until it encounters the first call to the function, the function call with arguments *solve_expression(x, a, b, c, d)* takes some time for executions. But, function calls later at this point will be fast. \n\nNow compare the speeds of the normal Python function and Numba JIT decorated function. Using *solve_expression.py_func()*, we can invoke the normal python function of this JIT decorated function.\n\n```python\n%% timeit\nres = solve_expression.py_func(x, a, b, c, d)\n\n'''Output\n912 ns ± 3.47 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)\n'''\n```\n\nThe normal Python function takes approx. 900 nanoseconds. \n\n```python\n%%timeit\nres = solve_expression(x, a, b, c, d)\n\n'''Output\n277 ns ± 1.36 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)\n'''\n```\n\nAnd the Numba version takes approx. 280 nanoseconds. The Numba version is 3x times faster than the pure Python function.\n\n### Compilation options\n\nFor **@jit** decorator, we can pass multiple options to configure the compilation behavior\n\n- **nopython**: if True, enables no-python mode making code execution without Python interpreter interference\n- **nogil**: if True, releases the GIL (only when *nopython=True*) inside the compiled function, useful for concurrent execution such as threads\n- **cache**: if True, store the compiled code in local storage and use this code whenever the function is called instead of re-compiling for every runtime\n- **parallel**: if True, enables automatic parallelization\n- **fastmath**: if True, uses faster math operations but less safe floating-point operations\n\nApart from these, there are some more options available. You can check all options at [@jit reference](https://numba.readthedocs.io/en/stable/reference/jit-compilation.html#jit-functions).\n\n## Lazy and Eager compilation\n\nNote that, as Python function arguments can take any time of arguments, Numba compiles the function for that specific type of the argument passed. If a new type of argument is passed to the function while calling, Numba re-compiles the code for that specific type.\n\n### Lazy compilation\n\nThe above *solve_expression()* function takes any type of argument. If we provide a function like this Numba calculates the optimization steps to be done based on the argument types provided at the first function call. In this way, Numba infers the argument types and compiles the specific version of the same function for different types. \n\nEx: if we change the argument types like this\n\n```python\n# previous values, x, a, b, c, d = 2, 13, 1.2, 4, 7\n# new values\nx, a, b, c, d = 3.9, 12, 5, 9.1, 14\n\nres = solve_expression(x, a, b, c, d)\n```\n\nAs the previous compiled function expects types for *x=int, a=int, b=float, c=int, d=int*, and in the latest function call we have changed some argument types. So, Numba re-compiles the function for new argument types. This mode of the compilation of code is called lazy compilation because Numba compiles for specific argument types only if it encounters them.\n\n### Eager compilation\n\nFor function overloading, we can specify function signatures with argument types and return types in a list with the least significant precision at the top. [Numba types](https://numba.readthedocs.io/en/stable/reference/types.html) follow Numpy convention types with different precision levels.\n\n```python\n@jit(['int32(int32, int32)',\n      'i4(int32, int64)', \n      '(f4, f8)',\n      'f8(f4, f4)'])\ndef func1(a, b):\n    return a + b\n```\n\nIn the above function, we passed function signatures as a list of strings. The syntax is return type is specified first and argument types are specified after. It is allowed to have no return type specified. Numba will infer the return type automatically and use that specification. Calling the function with argument types not provided in the list raises an error.\n\n## @njit or @jit(nopython=True)\n\nNumba **@jit** operates in two modes *nopython* and *object*. In **nopython** mode, no interference of the Python interpreter is required and execution is very fast compared to normal mode. **object** mode is the same as calling function without **@jit**. \n\nNormally with the **@jit** decorator, Numba tries to compile in **nopython** mode. If any part of the code cannot be compiled due to the presence of code that is not supported by Numba like a heterogenous dictionary, some string methods, etc, then Numba fallbacks to **object** or normal Python mode for compilation. But still, it will improve the performance when loops are involved. If there is no code to optimize, **@jit** in object mode runs slower than the normal Python version as Numba compilation involves several function call overheads.\n\nWe can enable the strict *nopython* mode by passing the option to **@jit** as *@jit(nopython=True)*. Numba also provides a separate decorator for this option. *@njit* decorator is an alias for *@jit(nopython=True)*.\n\n```python\n@jit(nopython=True)\ndef f(a, b):\n\treturn a + b\n\n# or\n\n@njit\ndef f(a, b):\n\treturn a + b\n```\n\nWith **nopython** mode, if any code is present that requires object mode compilation, Numba will raise an error. The primary goal is to write functions that can be implemented in strict no-python mode.\n\n---\n\n## Numba and Numpy\n\nNumba is best for Numpy arrays and supports some [Numpy features](https://numba.readthedocs.io/en/stable/reference/numpysupported.html) in no-python mode.\n\n```python\n@njit(['int64[:](int64[:, :], int64[:, :])'])\ndef f(a, b):\n    c = np.empty(a.shape[0], dtype='int64')\n    \n    for i in range(a.shape[0]):\n        c[i] = a[i].sum() * b[i].sum()\n    \n    return c\n```\n\nThe function takes 2 2D Numpy int64 arrays as arguments with the return type as an array of float64. The function calculates the sum of the product of the sum of each row of *a* and *b*.\n\n```python\nx, y, n = 1000, 1000, 1_000_000\nl, h = 0, 100\na = np.random.randint(l, h, n).reshape(x, y)\nb = np.random.randint(l, h, n).reshape(x, y)\n```\n\nIf we compare both normal Numpy calculation of the above function and Numba compiled code, \n\n```python\n%%timeit\n# normal Python calculation\nres = a.sum(axis=1) * b.sum(axis=1)\n\n'''Output:\n1.4 ms ± 7.1 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)\n'''\n```\n\n```python\n%%timeit \n# Numba compiled function\nres = f(a, b)\n\n'''Output:\n1.19 ms ± 15.4 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)\n'''\n```\n\nNumba compiled version takes **1.19 ms** which is slightly faster than normal calculation with Numpy **1.4ms**.\n\n## @vectorize decorator\n\nOne of the main reasons for Numpy speed is that most of the Numpy functions are [ufunc](https://numpy.org/doc/stable/user/basics.ufuncs.html)s (universal functions) that are vectorized and implemented inside compiled layer of Numpy and hence the speed. We might run into a situation where we cannot find any existing Numpy functions for use and write a workaround by combining Numpy functions into a single operation. This new operation is not optimized and we might lose the speed that Numpy provides due to custom loops. To solve this problem, we can make any function as **ufunc** that comes with vectorization and speed. \n\nWith [@vectorize](https://numba.readthedocs.io/en/stable/user/vectorize.html), Numba provides functionality to create custom vectorized universal functions. The universal function takes scalar values and returns a scalar value and these functions are applied over any Numpy arrays where array values are passed as single scalar values and an outside loop is automatically generated.\n\n```python\n@vectorize(['float64(int64, int64)'])\ndef v_expr(a, b):\n    return (a**2) + (a*3) + (b/2) + 10\n```\n\nHere, we created a simple universal function that takes two scalar values and returns a calculated expression. \n\n```python\nn = 1_000_000\nl, h = 0, 100\na = np.random.randint(l, h, n)\nb = np.random.randint(l, h, n)\n```\n\nThe speed comparison of the Numpy expression and vectorized ufunc function gives \n\n```python\n%%timeit\n# general way of calculating Numpy expression\nres = (a**2) + (a*3) + (b/2) + 10\n\n'''Output:\n8.66 ms ± 71.9 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n'''\n```\n\n```python\n%%timeit\n# calculate expression with ufunc\nres = v_expr(a, b)\n\n'''Output:\n2.17 ms ± 96.5 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n'''\n```\n\nthe optimized function **v_expr** takes **2.17 ms** which is 4x faster than the normal calculation with Numpy.\n\n---\n\nIn this blog, we discussed basic Numba decorators and compared Numba compiled functions with normal Python functions. Explore other features of Numba like \n- [automatic parallelization](https://numba.readthedocs.io/en/stable/user/parallel.html)\n- [loop parallelization with prange](https://numba.readthedocs.io/en/stable/user/parallel.html#explicit-parallel-loops)\n- [stencil kernel implementation for arrays](https://numba.readthedocs.io/en/stable/user/stencil.html)\n- [ahead-of-time compilation](https://numba.readthedocs.io/en/stable/user/pycc.html)\n\nRemember that not every function can be passed to Numba as there are some limitations like \n- Numba only supports a subset of Python code like classes, multi-dimensional dictionaries, etc, which are not supported yet. \n- As object mode compilation takes more time than the normal Python mode in some cases, it is better to check the speed of both normal and compiled code execution speed.\n- Support for external libraries like Pandas is not supported.\n- As Numba re-implements some Numpy APIs, there may be different behavior expected.\n\n---\n\n### References\n- [https://github.com/ContinuumIO/gtc2020-numba](https://github.com/ContinuumIO/gtc2020-numba)\n- [https://www.nvidia.com/en-us/glossary/data-science/numba/](https://www.nvidia.com/en-us/glossary/data-science/numba/)\n- [https://www.chrisvoncsefalvay.com/2019/03/23/jit-fast/](https://www.chrisvoncsefalvay.com/2019/03/23/jit-fast/)\n- [https://towardsdatascience.com/numba-weapon-of-mass-optimization-43cdeb76c7da](https://towardsdatascience.com/numba-weapon-of-mass-optimization-43cdeb76c7da)\n- [https://www.infoworld.com/article/3622013/speed-up-your-python-with-numba.html](https://www.infoworld.com/article/3622013/speed-up-your-python-with-numba.html)\n- [https://coderzcolumn.com/tutorials/python/numba](https://coderzcolumn.com/tutorials/python/numba)\n- [https://towardsdatascience.com/numpy-ufuncs-the-magic-behind-vectorized-functions-8cc3ba56aa2c](https://towardsdatascience.com/numpy-ufuncs-the-magic-behind-vectorized-functions-8cc3ba56aa2c)"},{"metadata":{"title":"Super fast Python (Part-4): Cython","description":"Convert slow Python code to run as fast as C/C++ using Cython.","imgName":"super-fast-python-cython/super-fast-python-cython.jpg","date":"Nov 18, 2022","tags":["python-performance"],"keywords":["cython","python-performance'","python-optimize","python","fast-python","speed","python"],"id":"super-fast-python-cython"},"content":"\n![Super fast Python: Cython](super-fast-python-cython/super-fast-python-cython.jpg)\n\n# Super fast Python (Part-4): Cython\n\nThis is the fourth post in the series on Python performance and Optimization. The series points out the utilization of inbuilt libraries, low-level code conversions, and other Python implementations to speed-up Python. The other posts included in this series are \n\n- (Part-1): [Why Python is slow?](https://santhalakshminarayana.github.io/blog/super-fast-python-why-python-slow)\n- (Part-2): [Good practices to write fast Python code](https://santhalakshminarayana.github.io/blog/super-fast-python-good-practices)\n- (Part-3): [Multi-processing in Python](https://santhalakshminarayana.github.io/blog/super-fast-python-multi-processing)\n- (Part-4): Use Cython to get speed as fast as C (this post)\n- (Part-5): [Use Numba to speed up Python Functions and Numeric calculations](https://santhalakshminarayana.github.io/blog/super-fast-python-numba)\n\nIn the last post, we discussed **multiprocessing** to optimize Python code by utilizing parallel computing with multiple CPU cores. Multi-processing is useful when we can split certain parts of code into parallel tasks and then execute them parallelly. \n\nImagine when we don't have any parallelizable code and it is taking huge time in Python compared to **C/C++**, how to optimize the code then? One thing we can do is to convert the Python code into a low-level programming language like C/C++ and [embed that C/C++ code in Python](https://docs.python.org/3/extending/extending.html). Understanding and writing C/C++ code is hard for someone who is not familiar with C/C++. Fortunately, we can get the performance speed as fast as C/C++ by writing the Python code in [Cython](https://cython.org/) which is a superset of Python that provides functionality to write C-Extensions for Python.\n\n## How Cython can improve Speed?\n\nIn our previous discussion on [Why Python is slow?](https://santhalakshminarayana.github.io/blog/super-fast-python-why-python-slow), we learned that the major speed issues arise in Python due to\n\n- interpretation of generated bytecode\n- dynamic types and their management\n\nWith Cython, we can take care of the above problems with both compiled code instead of interpretation and static typing instead of dynamic typing. \n\nCython translates the Python code into C extension code and compiles the C code into an object code that can be imported directly into Python. Also, we can make some changes like adding static types that improve the execution speed drastically over dynamic typing. Cython also supports the usage of C/C++ libraries and functions that are super-fast compared to Python libraries and functions.\n\n### Install Cython\n\n[Install the Cython](https://cython.readthedocs.io/en/stable/src/quickstart/install.html) with Pip as follows\n\n```bash\npip install Cython\n```\n\n> To compile the C code into an object file, we need a C compiler. Ubuntu comes with **gcc** by default. For other platforms like Windows, install the C compiler if not installed previously.\n\n---\n\n## Cython usage\n\nThere are multiple ways to use Cython like building manually,  using in Jupyter as an extension, or importing directly like a Python module without compilation using *pyximport*.\n\n### Build a Cython module manually\n\nWe write the Cython code in a file with the extension *.pyx* instead of the normal Python extension *.py*.\n\nThe compiler translates '.pyx' Cython file into a '.c' C file and then compiles that C file to a sharable object file '.so' (or '.pyd' on Windows). We tell the compiler those build instructions and compilation options by writing a [setup.py](https://cython.readthedocs.io/en/stable/src/userguide/source_files_and_compilation.html#basic-setup-py) file.\n\n### Cython compilation\n\n- Translate the *.pyx* source code to a *.c* file with additional wrappers of Python extension code.\n- Compile the *.c* file with a C compiler to a platform-specific shared object file *.so* that can be imported directly into Python.\n\n```python:calculate_y_cython.pyx\ndef fx(x, a, b, c):\n    d = (a + b) * c\n    return a*x + b*(x**2) + c*(x**3) + d\n\ndef y(x, n, a, b, c):\n    af = fx(x, a, b, c)**2\n    k = abs(n//2 - x)\n    bf = fx(k, a, b, c)\n    return (af-bf)/(n-1 + 1e-12)\n\ndef calculate_y_cython(n):\n    ys = []\n    a, b, c = 2, 5, -4\n    for i in range(n):\n        ys.append(y(i, n, a, b, c))\n    \n    return ys\n```\n\nThe above file *calculate_y.pyx* contains Cython code that looks the same as Python without any optimizations. Now to compile the above file, write a *setup.py* file as following\n\n```python:setup.py\nfrom distutils.core import setup\nfrom Cython.Build import cythonize\n\nsetup(\n    name='Calculate Expression Y',\n    ext_modules=cythonize(\n        \"calculate_y_cython.pyx\", \n        compiler_directives={\"language_level\": \"3\"},\n    )\n)\n```\n\nIn the above *setup.py*, for the **setup()**, we have passed the optional name to our Cython module for *name* and the path to the *.pyx* file for the *ext_module* parameter.\n\nBuild the sharable object file '.so' using the following command in the terminal\n\n```bash\npython setup.py build_ext --inplace\nor\npython setup.py build_ext --inplace --quiet\n```\n\nThis will generate a translated '.c' C file and a compiled '.so' file.\n\nWe can import the above compiled *calculate_y_cython* module directly into Python runtime.\n\n```python:main.py\nfrom time import perf_counter\nfrom calculate_y_cython import calculate_y_cython\n\ndef fx(x, a, b, c):\n    d = (a + b) * c\n    return a*x + b*(x**2) + c*(x**3) + d\n\ndef y(x, n, a, b, c):\n    af = fx(x, a, b, c)**2\n    k = abs(n//2 - x)\n    bf = fx(k, a, b, c)\n    return (af-bf)/(n-1 + 1e-12)\n\ndef calculate_y_py(n):\n    ys = []\n    a, b, c = 2, 5, -4\n    for i in range(n):\n        ys.append(y(i, n, a, b, c))\n    \n    return ys\n\ndef main():\n    n = 100000\n    # Python implementation\n    atime = perf_counter()\n    res = calculate_y_py(n)\n    print(f'Python Time: {perf_counter()-atime:.2}')\n    \n    atime = perf_counter()\n    res = calculate_y_cython(n)\n    print(f'Cython Time: {perf_counter()-atime:.2}')\n    \nif __name__==\"__main__\":\n    main()\n\n\"\"\"Output:\nPython Time: 0.19\nCython Time: 0.16\n\"\"\"\n```\n\n> At the time of writing, the latest Python version is Python 3.11 which is incredibly faster (30-60% in some cases) than earlier versions. So, to understand the Cython potential, I'm running the scripts in Python 3.8.10 on my old system with 8GB Intel(R) i5-8250U 1.60GHz CPU on HP Laptop 15-da0xxx.\n\nIn the above *main.py*, we have imported the *calculate_y_cython* module at line 2. If we look at the output to check the time taken for normal Python implementation and Cython version, they are **0.19** and **0.16** seconds respectively. The time difference is very low and we didn't gain much from Cython because we haven't done any optimization steps like \n\n- static typing\n- limit calling Python's libraries\n- reducing Python's PyObject usage\n\n### Cython Annotations\n\nCython provides an easy way to check where we can optimize our Cython code by using Cython annotate feature. With the following command (*-a* denotes annotate and *-3* denotes **language_level** which is Python3), cython generates an HTML file that we can open in the browser to check for optimizable code. Another option is to pass the **annotate=True** parameter to *cythonize()* function call in **ext_modules** in *setup*.\n\n```bash\ncython -a calculate_y_cython.pyx -3\n```\n\nIf we open the generated HTML file in the browser, it will look like this\n\n![Cython Annotation:=:80](super-fast-python-cython/cython-annotations.png)\n\nThe more yellow lines the more interaction with the Python interpreter. Our goal should be converting as many yellow lines as to white lines that denote pure Cython code. We discuss the optimization part in a later section.\n\n### Cython as an extension in Jupyter\n\nCython can be imported and used in Jupyter directly as an extension without the need for any additional build/compilation steps. \n\nFirst load the Cython extension using *%load_ext cython*, and then, for the cell that is to be Cythonized, use the magic command *%%cython* at the top of that cell as shown in the following image.\n\n![Cython Jupyter:=:40](super-fast-python-cython/cython-jupyter.png)\n\nWe can show the interactive Cython annotations in Jupyter just like we have generated the HTML file above. To show annotations, pass annotate option to *%%cython -a* magic command.\n\n### Import '.pyx' using pyximport\n\nWhile developing or debugging, for each change in the '.pyx' file, running *setup.py* is a repetitive task and cumbersome. Instead, we can dynamically import '.pyx' to Python directly using [pyximport](https://cython.readthedocs.io/en/stable/src/userguide/source_files_and_compilation.html#pyximport) without any external build and compilation. *pyximport* takes care of compiling and building in the background without calling *cythonize()* internally. So, while importing the '.pyx' file, it will take some time to be imported as a regular Python module.\n\n```python\nimport pyximport\npyximport.install(language_level=3)\n\nfrom calculate_y_cython import calculate_y_cython\n```\n\nThough it is easy to work with Cython using **pyximport**, there are some [limitations with pyximport](https://cython.readthedocs.io/en/stable/src/userguide/source_files_and_compilation.html#limitations) and it is also not flexible as normal setup.\n\n> It is not recommended to use **pyximport** while distributing Python packages and modules.\n\n---\n\n## Optimize Cython\n\nIn the previous section, we have seen in the Cython annotations HTML file that many areas in the code need to be optimized for more speed. There are several ways to improve speed like\n\n- define static types\n- use C-libraries and functions\n- utilize OpenMP for parallel computing\n\n### Define static types to variables\n\nSince Python is a dynamic typing language, we can define C-like data types for Python variables in Cython. To declare C variables, prefix the **cdef** keyword to the variable declaration which is the same as declaring variables in C.\n\nThe syntax for variable declaration is\n\n```python\ncdef type variable_name = initilization_value {optional}\n```\n\nThe **type** can be any of the acceptable C data types.\n\n### Define function definitions\n\nPython functions are defined using **def** and [C functions in Cython](https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#python-functions-vs-c-functions) are defined with the keyword **cdef**. The difference between **def** and **cdef** is that with the former declaration, it can be called from anywhere both local and external modules where as **cdef** functions are only module level. Also, Cython wraps the **def** function that is defined inside '.pyx' into a Python object. There is another declaration called **cpdef** which behaves as **def** when called from outside the module and behaves as **cdef** inside the module, so it is faster inside the same module function call.\n\nCython also provides support for writing function definitions just like C. We can define parameter types and return types. \n\n```python\ncdef(or cpdef) type function_name(type parameter1, ...)\n```\n\nIf no type is specified, the parameters and return values are treated as Python objects which need Python interpretation and they are slow.\n\nNow, make some changes to *calculate_y_cython.pyx* with static type declarations and function definitions as,\n\n> [Call the C functions in Cython](https://cython.readthedocs.io/en/stable/src/tutorial/external.html) inplace of Python functions that reduces the Python interaction.\n\n```python:calculate_y_cython.pyx\nctypedef long int li\nctypedef long long int lli\n\ncdef lli fx(li x, int a, int b, int c):\n    cdef int d = (a + b) * c\n    return a*x + b*(x**2) + c*(x**3) + d\n\ncdef double y(li x, li n, int a, int b, int c):\n    cdef:\n        lli af = fx(x, a, b, c)**2\n        li k = abs(n//2 - x)\n        lli bf = fx(k, a, b, c)\n    return (af-bf)/(n-1 + 1e-12)\n\ncpdef calculate_y_cython(li n):\n    ys = []\n    cdef:\n        int a = 2, b = 5, c = -4\n        li i = 0\n    for i in range(n):\n        ys.append(y(i, n, a, b, c))\n    \n    return ys\n```\n\n> speed can be improved further by disabling bound checking(@cython.boundscheck(False)) and negative indexing(@cython.wraparound(False)) [compiler directive instructions](https://cython.readthedocs.io/en/stable/src/userguide/source_files_and_compilation.html#compiler-directives).\n\nCheck the annotations for the Cython code, most of the yellow lines are now changed to white and only list operations are dark yellow because lists are Python objects. In a later section, we discuss optimizing lists using C arrays.\n\n![Optimized Cython Annotation:=:70](super-fast-python-cython/optimized_cython.jpg)\n\nIf we check the time for the optimized Cython code,\n\n```python\n%%timeit -n 100\nn = 100000\nres = calculate_y_cython(n)\n\n\"\"\"Output:\n2.04 ms ± 166 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\"\"\"\n```\n\nit takes **0.002** seconds which is approximately **100x** times faster than the normal Python version that takes **0.19** seconds. By adding only static type and some tweaks, we made Python 100x faster. The powers of Cython are not limited to only static typing. We can further speed up the code with Numpy.\n\n---\n\n## 1000x times faster with MemoryView and Numpy\n\nIn the Cython annotation snippet above, we see that the list operations of **ys** are still yellow as *list()* is a python object and Cython cannot optimize Python objects interaction. \n\nTo solve this, we can convert the list type to [memoryview arrays](https://cython.readthedocs.io/en/stable/src/tutorial/array.html), and operations like *append()* to indexing just like looping in C.\n\n```python:calculate_y_cython.pyx\ncimport cython\nimport numpy as np\ncimport numpy as np\n\nctypedef long int li\nctypedef long long int lli\n\n@cython.boundscheck(False)  # Deactivate bounds checking\n@cython.wraparound(False)   # Deactivate negative indexing\ncdef lli fx(li x, int a, int b, int c):\n    cdef int d = (a + b) * c\n    return a*x + b*(x**2) + c*(x**3) + d\n\n@cython.boundscheck(False)\n@cython.wraparound(False)\ncdef double y(li x, li n, int a, int b, int c):\n    cdef:\n        lli af = fx(x, a, b, c)**2\n        li k = abs(n//2 - x)\n        lli bf = fx(k, a, b, c)\n    return (af-bf)/(n-1 + 1e-12)\n\n@cython.boundscheck(False)\n@cython.wraparound(False)\ncpdef calculate_y_cython(li n):\n    cdef double[:] ys = np.empty(n, dtype=np.float64)\n    cdef:\n        int a = 2, b = 5, c = -4\n        li i = 0\n    for i in range(n):\n        ys[i] = y(i, n, a, b, c)\n    return ys\n```\n\nBefore building the object code, we need to change [build instructions to link Numpy](https://cython.readthedocs.io/en/stable/src/tutorial/numpy.html) as a dependency like following\n\n```python:setup.py\nfrom distutils.core import setup\nfrom distutils.extension import Extension\nfrom Cython.Build import cythonize\nimport numpy\n\next_modules = [\n    Extension(\"calculate_y_function\",\n              sources=[\"calculate_y_cython.pyx\"],\n              libraries=[\"m\"],\n              compiler_directives={\"language_level\": \"3\"},\n              )\n]\n\nsetup(name=\"calculate Y function\",\n      ext_modules=cythonize(ext_modules),\n      include_dirs=[numpy.get_include()])\n```\n\nThe parameter *include_dirs* includes external libraries like Numpy here.\n\n```python\n%%timeit -n 1000\nn = 100000\nres = calculate_y_cython(n)\n\n\"\"\"Output:\n208 µs ± 11.3 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)\n\"\"\"\n```\n\nThe fully optimized version of Cython runs at **0.0002** seconds which is approximately **1000x** faster than the normal Python code. \n\nThe usage of Numpy and MemoryViews in Cython needs separate discussion and I will write about Classes, C-math, Numpy, MemoryViews, and OpenMP in the Advanced Cython series later.\n\n---\n\nCython is a very powerful extension that we can use to speed up Python code. Sometimes it may not be possible to convert Python objects straight away like dictionaries (use C++ maps), so it's better to use Cython for repetitive tasks like loops, general functions with simple statements (like declaration and usage only), and math operations.\n\nLearn more about Cython by referencing\n\n- [Speeding up basic object operations in Cython\n](http://blog.behnel.de/posts/tuning-basic-object-operations-in-cython.html)\n- [Faster Python made easier with Cython’s pure Python mode](https://www.infoworld.com/article/3648539/faster-python-made-easier-with-cythons-pure-python-mode.html)\n- [An Introduction to Just Enough Cython to be Useful](https://www.peterbaumgartner.com/blog/intro-to-just-enough-cython-to-be-useful/)\n- [Cython notes and tips](https://nicolas-hug.com/blog/cython_notes)\n- [(Github Issue) Improve cython interface with a more user-friendly compiling interface](https://github.com/cython/cython/issues/3974)"},{"metadata":{"title":"Super fast Python (Part-3): Multi-processing","description":"Make computations in Python faster with Multi-processing .","imgName":"super-fast-python-multi-processing/super-fast-python-multi-processing.jpg","date":"Nov 12, 2022","tags":["python-performance"],"keywords":["python-multiprocessing","python-performance'","python-optimize","python","fast-python","speed","python"],"id":"super-fast-python-multi-processing"},"content":"\n![Super fast Python: Multi-processing](super-fast-python-multi-processing/super-fast-python-multi-processing.jpg)\n\n# Super fast Python (Part-3): Multi-processing\n\nThis is the third post in the series on Python performance and Optimization. The series points out the utilization of inbuilt libraries, low-level code conversions, and other Python implementations to speed-up Python. The other posts included in this series are \n\n- (Part-1): [Why Python is slow?](https://santhalakshminarayana.github.io/blog/super-fast-python-why-python-slow)\n- (Part-2): [Good practices to write fast Python code](https://santhalakshminarayana.github.io/blog/super-fast-python-good-practices)\n- (Part-3): Multi-processing in Python (this post)\n- (Part-4): [Use Cython to get speed as fast as C](https://santhalakshminarayana.github.io/blog/super-fast-python-cython)\n- (Part-5): [Use Numba to speed up Python Functions and Numeric calculations](https://santhalakshminarayana.github.io/blog/super-fast-python-numba)\n\n## Problems with GIL\n\nIn the previous post on [why python is slow?](https://santhalakshminarayana.github.io/blog/super-fast-python-why-python-slow), we discussed that the problems with [Global Interpreter Lock (GIL) in Python](https://santhalakshminarayana.github.io/blog/super-fast-python-why-python-slow#gil-good-and-bad). [GIL](https://realpython.com/python-gil/) is part of Python's design that ensures thread-safe in Python. But, GIL only allows the interpreter to run with only one thread which makes multi-threading hard and slow in Python.\n\nThis makes multi-threading confined to use in cases like where [system releases the GIL](https://tenthousandmeters.com/blog/python-behind-the-scenes-13-the-gil-and-its-effects-on-python-multithreading/) for tasks where it waits for external processes to complete and return result/status like I/O operations, network requests, etc. To achieve better concurrency in Python, use [coroutines with asyncio](https://docs.python.org/3/library/asyncio-task.html).\n\nSo, even if the system has multiple cores and supports 1000s of threads, multi-threading is not suitable for CPU-intensive tasks. But, how to do [parallel computing](https://hpc.llnl.gov/documentation/tutorials/introduction-parallel-computing-tutorial) in Python? The answer is Multi-programming. Multi-programming creates multiple sub-processes (maximum processes can be created = no.of cores) where each process will have its interpreter with GIL and independent memory space. In processes, GIL won't be a problem because each one will have its interpreter to run the bytecode and the CPython manages multiple sub-processes. But, there are some overheads with processes like spawning/forking a process with its own memory space is slower than creating a thread and each process is separate which makes inter-process communication slow.\n\nAlso, there are external libraries like Numpy that release GIL and compute the tasks faster. [Numpy releases GIL](https://iotespresso.com/numpy-releases-gil-what-does-that-mean/) - means most of the Numpy computations are executed in C-libraries that don't require an interpreter which makes Numpy can release the GIL for that particular C-library.\n\n---\n\n[multiprocessing](https://docs.python.org/3/library/multiprocessing.html) module in Python offers a variety of APIs for achieving multiprocessing. In this blog, we discuss [mulitprocessing.Pool](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool) class that takes multiple numbers of tasks and executes them parallelly by distributing tasks among multiple cores/workers.\n\n> [concurrent.futures.ProcessPoolExecutor](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor) provides a higher level interface on top of **multiprocessing** and offers additonal functions to  control the process pool.\n\n## Multiprocessing Pool\n\n### Why and what is a pool?\n\nImagine we have an 8-cores CPU and create a process by allocating each process to each core for every task and executing them parallelly. If no.of tasks is <= no.of cores, then the parallel computing works smoothly. If we increase the no.of tasks to let's say 100 and create a process for each task and then execute them parallelly, the system has to manage the lifecycle of each process and ensure that processes don't hang up or reach a deadlock state. If we have numerous processes that the system can't handle we run into problems like system crash or hang.\n\nA pool is like a strategy in parallel computing to make sure that only a certain number of workers (or cores in the CPU) are allocated to run tasks given in any number. A pool is really helpful to prevent the system from the crash while serving a very huge number of processes that may overkill the CPU if not properly managed. We create a maximum of n-workers for a system with n-cores and distribute the task to every worker to run parallelly. The main difference is that in normal execution, for every task we create a separate process, but in pool processing, first, we create a pool of processes, then distribute the tasks among the processes in the pool.\n\nIf we have 100 tasks and a pool with 5 processes, distribute the 100 tasks to the process pool by running a batch of 20 tasks per process.\n\nConsider a function that takes around **1-second** to complete. And we have to call the function for 10 different input parameters.\n\nThe following example shows **fun_1()** as a function that takes a parameter **a**, sleeps for 1 second, and then returns the square of **a**.\n\n> Why prefer [time.perf_counter()](https://peps.python.org/pep-0418/) over time.time()? time.time() is not monotonic - which means that the system can change the clock time with synchronization to the internet or other update. Where time.perf_counter() is system-wide and the reference point is unknown so only the results between consecutive calls are considered.\n\nNow, call the function 10 times by passing the elements in the range(0..10). If we call the function without parallel processing, the total time will be around 10 seconds because every function call takes 1 second, and for 10 function calls it will be around 10 seconds.\n\n```python\nfrom os import getpid\nfrom time import perf_counter, sleep\nfrom multiprocessing import Pool, cpu_count\n\n# function that sleeps for 1 second\ndef fun_1(a):\n    print('WORKER ID:', getpid())\n    sleep(1)\n    return a * a\n\n# call fun_1 for elements in range(0..10)\n\n# without multiprocessing\natime = perf_counter()\nprint('without multiprocessing')\n\nres = [fun_1(i) for i in range(10)]\n\nprint(f\"time taken without multiprocessing: {perf_counter()-atime}\\n\")\n\n# with multiprocessing\natime = perf_counter()\nprint('with multiprocessing')\n\nwith Pool(processes=cpu_count()) as pool:\n    res = pool.map(fun_1, range(10))\n\nprint(f\"time taken with multiprocessing: {perf_counter()-atime}\")\n```\n```markdown:output\nwithout multiprocessing\nWORKER ID: 32093\nWORKER ID: 32093\nWORKER ID: 32093\nWORKER ID: 32093\nWORKER ID: 32093\nWORKER ID: 32093\nWORKER ID: 32093\nWORKER ID: 32093\nWORKER ID: 32093\nWORKER ID: 32093\ntime taken without multiprocessing: 10.019481873001496\n\nwith multiprocessing\nWORKER ID: 33097\nWORKER ID: 33099\nWORKER ID: 33098\nWORKER ID: 33100\nWORKER ID: 33101\nWORKER ID: 33103\nWORKER ID: 33102\nWORKER ID: 33096\nWORKER ID: 33098\nWORKER ID: 33101\ntime taken with multiprocessing: 2.077159455002402\n```\n\nIn the above code, we applied parallel computing by passing tasks (calling **fun_()**) to the multiprocessing pool. \n\nThe pool class constructor takes the following arguments and returns the pool object\n\n- **processes**: no.of workers, default is all cores available in the system. We can check the available cores by calling *multiprocessing.cpu_count()* (mine is 8)\n- **initializer**: initializer function that will be called by every worker when it starts\n- **initargs**: arguments to the initializer function above\n- **maxtasksperchild**: max. no.of tasks a worker should execute before being replaced by another worker process. This behavior releases the workers that are using system resources for a very long time\n\nWe discuss **initializer** and **initargs** in the later section on sharing data between processes.\n\nThe pool object has several methods like apply, map, starmap, imap, etc, that serves different purpose for applying parallel computing. In the above snippet, we used Pool.map() function (same as normal map()) that takes a function and an iterable and calls the function by passing each element in the iterable as an argument. The function should accept only an argument. The Pool.map() is a blocking call and it distributes the tasks among the available cores by dividing the tasks into chunks.\n\nPool.map() takes the following arguments\n\n- **func**: the function to be executed parallelly that takes one argument\n- **iterable**: an iterable whose elements are passed as arguments to the function above \n- **chunksize**: chunk size number that used to divide the tasks\n\n> based on the nature of tasks, different **chunksize** numbers [schedules tasks differently](https://stackoverflow.com/questions/53751050/multiprocessing-understanding-logic-behind-chunksize)\n\n> In UNIX and such systems, [multiprocessing creates processes](https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods) using a fork, and in windows, it starts processes using spawn. There are some [additional restrictions](https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods) one should be aware of when the process start method is other than fork like protecting the entry point of the program by creating processes inside *if \\_\\_name\\_\\_==\\_\\_main\\_\\_* because spawn creates new python interpreter for each process.\n\nAs we have 8 cores available and 10 tasks at hand, Pool.map() distributes the tasks among the 8 workers by dividing tasks into chunks like [2, 2, 1, 1, 1, 1, 1, 1] and pass them to workers.\n\nThe total time taken with multiprocessing is 2 seconds which is 5x times faster than without multiprocessing (10 seconds).\n\n> for large iterable size use Pool.imap() with chunksize for better efficiency\n\n> for multiple parameters function, use Pool.starmap() or Pool.map() with partial functions\n\n### Process vs Pool\n\nUse process, when there is a small number of tasks and each task takes a large amount of time. Use a pool, when there is a large number of tasks and each task takes a small amount of time.\n\n---\n\n## Sharing data between processes\n\n> It is strongly recommended to not share data between processes\n\n### Share data with global variables (copy-on-write)\n\nProcesses created using multiprocessing run independently with their own memory space and they don't have access to the parent process's local data but they [inherit the global data of the parent](https://superfastpython.com/multiprocessing-inherit-global-variables-in-python/) (only when fork start method used). \n\nSince child processes get a snapshot of the parent process's global data, we can utilize this behavior in a way such that we can make sharable data available to child processes by making the data global.\n\nFor the following example, we will share an integer value **x** and an array of integers **a** to calculate the sum of the product of each element in **a** with an element in the list of numbers from 0..n, n = 100000. And then compute the product of **x** and the whole sum.\n\n```python\n# function to be applied for each element\ndef sum_product(e):\n    w_sum = sum([x*i for i in a])\n    return w_sum * e\n\n# pool initializer function\ndef pool_initializer(X, A):\n    global x\n    x = X\n    global a\n    a = A\n\nn = 100000\nX = 3\nA = [2, 4, 6, 8, 10, 12]\n\nwith Pool(processes=cpu_count(), initializer=pool_initializer, initargs=(X, A)) as pool:\n    res = pool.map(sum_product, range(n))\n```\n\nIn the above snippet, we initialized the pool with the *pool_initializer* function, this function will be called for every worker after they start and any data globalized inside this initialization function is available to all child processes. \n\n> Even though we don't need the initializer function here to share data as we can make data global at the top level and all child processes would get a snapshot of the global data, there are other cases where the initializer function is useful. Like reading a file and sharing data, making a database connection, etc, which might work on variable parameters that we can pass in pool **initargs**.\n\nSharing data by leveraging global variables and copy-on-write data is only useful for read-only data. If any child process changes the global variable value, they don't reflect in the parent process.\n\n```python\nfrom random import randint\n\ndef random_increment(i):\n    rand_n = randint(0, i)\n    a[rand_n] += 1\n    print(f'child {i}: {a}')\n    \nn = 10\na = list(range(n))\n\nwith Pool(processes=cpu_count()) as pool:\n    pool.map(random_increment, range(n))\n\nprint(f'parent {a}')\n``` \n\nIn the above program, we have initialized a global variable **a** which is a list. We applied the function *random_increment()* for **n** tasks, and, *random_increment()* function takes the number **i** and increments the list **a** at the index generated randomly in the range(0..i).\n\nAs **a** is global, we expect the list **a** change in the parent process too, but it is not true as each child process is created by copying a snapshot of the parent data and each child will have their own memory.\n\nLook at the output of the above program below to check that, in the parent process, the value of **a** has not changed.\n\n```markdown:Output\nchild 2: [1, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nchild 1: [1, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nchild 3: [0, 2, 2, 3, 4, 5, 6, 7, 8, 9]\nchild 8: [1, 1, 3, 3, 4, 5, 6, 7, 8, 9]\nchild 7: [1, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nchild 6: [0, 1, 2, 3, 5, 5, 6, 7, 8, 9]\nchild 0: [1, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nchild 4: [0, 2, 2, 3, 4, 5, 6, 7, 8, 9]\nchild 9: [1, 2, 2, 3, 4, 5, 6, 7, 8, 9]\nchild 5: [0, 1, 2, 4, 4, 5, 6, 7, 8, 9]\nparent [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\nThis is because, the data sharing happens here by following a mechanism called **copy-on-write** where the OS instead of copying and creating the new memory for the global data, just facilitates access to the parent processes memory as long as the child process doesn't change the data. As we have seen in the above example, when the child process tries to change the data, OS just allocates the new memory by copying the shared data and then writes the changes to it. So, the child's process data changes are not reflected in the parent's process because both memory locations are different. This mechanism is vice-versa means that, after forking, when the data in the parent's process changes, they are not reflected in the child's process.\n\n### Share data using shared memory\n\nTo avoid the problems like above, **multiprocessing** provides a mechanism to share data. To share the data between child processes, one must use sockets or shared files. But, to share simple values or arrays, multiprocessing provides a mechanism called **shared ctypes** to share data safely between processes.\n\nWith [multiprocessing.sharedctypes](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.sharedctypes), we can allocate the **ctypes** object from the shared memory and then the child processes can inherit them. [cytpes](https://docs.python.org/3/library/ctypes.html#fundamental-data-types) are nothing but primitive **C** compatible data types and **ctypes** module provides a wrapper around these data types to use in Python. The shared memory here is nothing but the underlying memory buffer and we will discuss later how can utilize this fact to share large Numpy arrays.\n\nMultiprocessing provides two types of shared ctypes, one for read-and-write values and arrays, and the other one for read-only values and arrays.\n\nTo manipulate data in child processes, use \n\n- **multiprocessing.Value**: to share only single value variables such as numbers or strings\n- **multiprocessing.Array**: to share an array of values of the same data type in **C**\n\nTo share read-only data, use\n\n- **multiprocessing.RawValue**: to share only single value variables\n- **multiprocessing.RawArray**: to share array of values\n\nThe main difference between raw type and normal type is that the latter provides an automatic synchronization mechanism with locks to provide process-safe data sharing.\n\n```python\nfrom multiprocessing import Array\n\ndef random_increment(i):\n    rand_n = randint(0, i)\n    a[rand_n] += 1\n\n    print(f'child {i}: {list(a)}')\n    \ndef initializer_func(A):\n    global a\n    a = A\n\nn = 10\nA = Array('i', range(n))\n\nwith Pool(processes=cpu_count(), initializer=initializer_func, initargs=(A,)) as pool:\n    pool.map(random_increment, range(n))\n\nprint(f'parent: {list(A)}')\n```\n\nIn the above code, we have passed **multiprocessing.Array** instead of the normal list. **Array** is initialized with the data type ('i') and the iterable. We can also initialize the **Array** in other ways like defining the size first and assign later.  \n\n```python\nA = Array('i', 10)\nA = range(10)\n```\n\nWith **Array**, we can now see that the global variable **A** is updated and reflected in the parent process. Also with **Array**, we can get automatic synchronization with locks that manage by multiprocessing so that the shared data is process-safe and only one process can access the data.\n\n```markdown:Output\nchild 3: [2, 1, 3, 4, 4, 5, 6, 7, 8, 9]\nchild 7: [2, 1, 3, 5, 5, 7, 6, 7, 8, 9]\nchild 5: [2, 1, 3, 5, 5, 5, 6, 7, 8, 9]\nchild 2: [2, 1, 3, 3, 4, 5, 6, 7, 8, 9]\nchild 0: [1, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nchild 1: [2, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nchild 4: [2, 1, 3, 5, 4, 5, 6, 7, 8, 9]\nchild 8: [2, 1, 3, 5, 5, 8, 6, 7, 8, 9]\nchild 9: [2, 1, 3, 5, 5, 8, 6, 8, 8, 9]\nchild 6: [2, 1, 3, 5, 5, 6, 6, 7, 8, 9]\nparent: [2, 1, 3, 5, 5, 8, 6, 8, 8, 9]\n```\n\n---\n\n## Share large Numpy arrays between child processes\n\nFor each task, as we pass data as arguments to the processes, the data will be pickled so that it can be sent from one process to other. If we pass large amounts of data, pickling involves a huge amount of memory and consumes more time. So, it is better to [share large data between child processes](https://research.wmz.ninja/articles/2018/03/on-sharing-large-arrays-when-using-pythons-multiprocessing.html) instead of passing the data individually. \n\nAs we have seen in the above approach that copy-on-write sharing is good for read-only and to work with data that changes inside the child process, we have to share the data using a shared array. In this section, we will discuss sharing large Numpy arrays using a shared array.\n\nWe know that shared arrays only support primitive **C** data types and mainly 1D objects. But, how to share the Numpy arrays which are multidimensional in general to the child processes as shared ctypes do not directly support Numpy arrays? We can share Numpy arrays with some work around that is explained below.\n\nThe shared ctypes objects we get are allocated from [buffer memory](https://docs.python.org/3/c-api/buffer.html) memory. A [buffer protocol](http://jakevdp.github.io/blog/2014/05/05/introduction-to-the-python-buffer-protocol/) is a framework in Python designed to provide a mechanism for Python objects to share their data among objects. Any Python objects that are implemented in C-APIs can export a set of functions called the **buffer interface**. With this buffer interface, [any object can expose its data to other objects](https://towardsdatascience.com/loading-binary-data-to-numpy-pandas-9caa03eb0672) directly without the need for copying.\n\nAs shared ctypes objects are just wrappers around the C data types whose memory was allocated from buffer memory. This is the reason why the child process's changes reflect in the parent process because the shared memory passed to child processes are implemented as [memoryview](https://docs.python.org/3/library/stdtypes.html#memoryview) objects.\n\nConsider the following example where we first create a large Numpy array of shape (1000, 1000), and using the process pool we assign the row number to every element in that row. As shared array doesn't support multidimensional and custom data types, a common approach is to pass the Numpy array to every worker and assign the row with a row number. But, passing the large arrays between processes take huge memory and latency. So, we utilize the buffer protocol here. Since shared array objects are provided with a buffer interface, we can rely on this shared memory and make it global so that there is no need to pass Numpy arrays as arguments to each process.\n\n```python\ndef assign_int(i):\n    arr = np.frombuffer(np_x.get_obj(), dtype=np.int32).reshape(np_x_shape)\n    arr[i, :] = i\n\ndef pool_initializer(X, X_shape):\n    global np_x\n    np_x = X\n    global np_x_shape\n    np_x_shape = X_shape\n\nX_shape = (1000, 1000)\ndata = np.zeros(X_shape, dtype=np.int32)\nX = Array('i', X_shape[0] * X_shape[1])\n# X as a Numpy array\nX_np = np.frombuffer(X.get_obj(), dtype=np.int32).reshape(X_shape)\n# copy data to the shared array\nnp.copyto(X_np, data)\n\nwith Pool(processes=cpu_count(), initializer=pool_initializer, initargs=(X, X_shape)) as pool:\n    pool.map(assign_int, range(X_shape[0]))\n\nprint(f'Numpy array X_np:\\n{X_np}')\n```\n\nFirst, we defined the shape of the array **X_Shape**, and then created a Numpy array with zeros of shape **X_Shape**. Second, we have created a synchronized shared array and assigned it to **X**. Third, we wrapped the shared array as Numpy using **np.frombuffer**.\n\n**np.frombuffer** takes a 1-dimensional buffer array and interprets it into a Numpy array so we can manipulate the array easily. We used *X.get_obj()* instead **X** because **X** is a synchronized wrapper around the raw array and calling the **get_obj()** returns the raw buffer object.\n\n> For raw arrays (RawArray), objects should be passed normally without calling get_obj().\n\nWhy use [**np.frombuffer**](https://www.educba.com/numpy-frombuffer/)? Since Numpy arrays take a large amount of memory space, we don't want to create a copy that again takes large memory. So, using **np.frombuffer** by utilizing the buffer protocol, we can get a Numpy array which is just a wrapper around the buffer memory. \n\nIn **initiargs**, we should pass the shared array instead Numpy wrapper. We also pass the shape of the Numpy array as we need to reshape the 1D shared array into a multidimensional array in the worker function *assign_int()*.\n\nIn the worker function *assign_int()*, again we interpreted the buffer as a Numpy array and assigned the row values at row number **i**.\n\nAt last, in the parent process, we can check the multiprocessing assignment of the Numpy array.\n\n```markdown:Output\nNumpy array X_np:\n[[  0   0   0 ...   0   0   0]\n [  1   1   1 ...   1   1   1]\n [  2   2   2 ...   2   2   2]\n ...\n [997 997 997 ... 997 997 997]\n [998 998 998 ... 998 998 998]\n [999 999 999 ... 999 999 999]]\n```\n---\n\nEven though **multiprocessing** looks easy and flexible to use, there are some issues one can face with **multiprocessing** if not careful,\n\n- [Why your multiprocessing Pool is stuck](https://pythonspeed.com/articles/python-multiprocessing/)\n- [Multiprocessing Best Practices](https://superfastpython.com/multiprocessing-best-practices/)\n- [Handling Hang in Python Multiprocessing](https://sefiks.com/2021/07/05/handling-hang-in-python-multiprocessing/)\n- [The Parallelism Blues: when faster code is slower](https://pythonspeed.com/articles/parallelism-slower/)\n- [Things I Wish They Told Me About Multiprocessing in Python](https://www.cloudcity.io/blog/2019/02/27/things-i-wish-they-told-me-about-multiprocessing-in-python/)\n- [Exception Handling in Methods of the Multiprocessing Pool Class in Python](https://towardsdatascience.com/exception-handling-in-methods-of-the-multiprocessing-pool-class-in-python-7fbb73746c26)\n\nIn this blog, we discussed Python's **multiprocessing** module with the Pool function. Python released other modules for simple concurrent processing and better data sharing,\n\n- [Managers](https://docs.python.org/3/library/multiprocessing.html#managers)\n- [Shared Memroy](https://docs.python.org/3/library/multiprocessing.shared_memory.html)\n- [Concurrent Futures](https://docs.python.org/3/library/concurrent.futures.html)\n\nOn top of internal libraries, there are multiple good external libraries available for parallel and concurrent processing,\n\n- [Joblib](https://joblib.readthedocs.io/en/latest/parallel.html)\n- [IPyParallel](https://ipyparallel.readthedocs.io/en/latest/tutorial/intro.html)\n- [Ray](https://docs.ray.io/en/master/index.html)\n- [Dask](https://www.dask.org/)\n\nFor comparison among internal and external libraries,\n\n- [Parallelizing Python Code](https://www.anyscale.com/blog/parallelizing-python-code)\n- [Multiprocessing In Python: Core vs libraries](https://cosmiccoding.com.au/tutorials/multiprocessing)\n- [Sharing big NumPy arrays across python processes](https://luis-sena.medium.com/sharing-big-numpy-arrays-across-python-processes-abf0dc2a0ab2)"},{"metadata":{"title":"Super fast Python (Part-2): Good Practices","description":"Write Python programs by following good practices to run code incredibly faster.","imgName":"super-fast-python-good-practices/super-fast-python-good-practices.jpg","date":"Nov 9, 2022","tags":["python-performance"],"keywords":["python-performance","python-optimize","python","fast-python","speed","python"],"id":"super-fast-python-good-practices"},"content":"\n![Super fast Python: Good Practices](super-fast-python-good-practices/super-fast-python-good-practices.jpg)\n\n# Super fast Python (Part-2): Good practices\n\nIn the earlier post on [why Python is slow?](https://santhalakshminarayana.github.io/blog/super-fast-python-why-python-slow), we discussed slowness is in Python due to its internal design of some essential components like GIL, dynamic typing, and interpretation.\n\nIn this blog, we discuss some good practices to speed up Python incredibly faster.\n\nThis is the second post in the series on Python performance and Optimization. The series points out the utilization of inbuilt libraries, low-level code conversions, and other Python implementations to speed-up Python. The other posts included in this series are \n\n- (Part-1): [Why Python is slow?](https://santhalakshminarayana.github.io/blog/super-fast-python-why-python-slow)\n- (Part-2): Good practices to write fast Python code (this post)\n- (Part-3): [Multi-processing in Python](https://santhalakshminarayana.github.io/blog/super-fast-python-multi-processing)\n- (Part-4): [Use Cython to get speed as fast as C](https://santhalakshminarayana.github.io/blog/super-fast-python-cython)\n- (Part-5): [Use Numba to speed up Python Functions and Numeric calculations](https://santhalakshminarayana.github.io/blog/super-fast-python-numba)\n\nThe following section describes the various good practices one can use to make Python super speed (up to 30% or more) without any external support like PyPy, Cython, Numpy, etc.\n\n## Python good practices for super fast code\n\n### Use built-in data structures and libraries\n\nAs Python data types are implemented directly in **C**, using the built-in types like list, map, and trees, compared to custom types we define, really helps the program to run faster.\n\nAlso, use built-in libraries for common algorithms like counting the duplicates, summing all list elements, finding the maximum element, etc, because these are all already written in **C** and compiled which makes these functions run faster than custom functions we write.\n\n```python\nfrom random import randint\n\nrand_nums = [randint(1, 100) for _ in range(100000)]\n```\nCreate 100000 random numbers between 1 and 100.\n\n```python\n%%timeit\ncc = 0\nfor i in range(len(rand_nums)):\n    cc += rand_nums[i]\n```\n```python:output\n6.02 ms ± 94 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n```\n\nManually summing up the all numbers over running a loop takes approximately 6ms.\n\n```python\n%%timeit\ncc = sum(rand_nums)\n```\n```python:output\n332 µs ± 15 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)\n```\n\nUsing built-in *sum()* takes only 0.3ms approximately.\n\n### Local Variables vs Global Variables\n\nWhen we call a function (a routine), the system pauses the code execution at the call site in the current routine (say **main()**) where the call has been made and places the called function at the top of the call stack. Imagine if we have defined numerous global variables and made multiple function calls. The system has to make sure that all these global variables should be available for any routine placed in the call stack at all times. The system has to provide a lookup mechanism for both local and global variables for each routine. And with global variables, this lookup mechanism may take some time than local variables.\n\n### Import the sub-modules and functions directly\n\nWhen importing any module to use its sub-modules, classes, or functions, import them directly instead of importing just the module. When accessing objects using *.*, it triggers dictionary lookup using *\\_\\_getattribute\\_\\_*. If we call the object multiple times using *.*, that may increase the program time.\n\n```python\n# instead of this\nimport abc\ndef_obj = abc.Def()\n\n# do this\nfrom abc import Def\ndef_obj = Def()\n```\n\n### Limit the usage of '.'\n\nSpeaking of the lookup time with the module's object references, the same can be applied to the referencing of properties and functions of an object(both custom and in-built). \n\n```python\n%%timeit\nll = []\nfor i in range(len(rand_nums)):\n    ll.append(rand_nums[i])\n```\n```python:output\n6.67 ms ± 84.7 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n```\n\nAdding the list elements by appending with *list.append()* takes more time than following code because the function is assigned to a variable (functions are first-class citizens in Python) and used inside the loop. This simple practice avoids referencing the functions with **'.'** too often and finally limits the need for dictionary lookup.\n\n```python\n%%timeit\nll = []\nll_append = ll.append\nfor i in range(len(rand_nums)):\n    ll_append(rand_nums[i])\n```\n```python:output\n5.45 ms ± 116 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n```\n\n### Avoid writing functions unnecessary\n\nIt's good to have code separability by using functions for each independent task. But, as functions in Python are relatively more expensive than C/C++ due to boxing and unboxing dynamic variables and other factors, limit writing functions for unnecessary cases like one-liners. \n\n### Don't wrap lambdas around functions\n\nOveruse or misuse of lambdas is not a good practice. It's common to wrap functions inside lambdas which do the same thing without wrapping.\n\nConsider the following two functions for sorting a list based on absolute values.\n\n```python\ndef fun_sort_with_lambda(l):\n    return sorted(l, key=lambda x: abs(x))\n\ndef fun_sort_without_lambda(l):\n    return sorted(l, key=abs)\n```\n\nIf we look at the CPython bytecode for the above functions with lambda expression passed as a key and with *abs* function object as a key,\n\n```python\n>>> from dis import dis\n>>> dis(fun_sort_with_lambda)\n  2           0 LOAD_GLOBAL              0 (sorted)\n              2 LOAD_FAST                0 (l)\n              4 LOAD_CONST               1 (<code object <lambda> at 0x7fc51b3a19d0, file \"<ipython-input-62-c4147c242c71>\", line 2>)\n              6 LOAD_CONST               2 ('fun_sort_with_lambda.<locals>.<lambda>')\n              8 MAKE_FUNCTION            0\n             10 LOAD_CONST               3 (('key',))\n             12 CALL_FUNCTION_KW         2\n             14 RETURN_VALUE\n\nDisassembly of <code object <lambda> at 0x7fc51b3a19d0, file \"<ipython-input-62-c4147c242c71>\", line 2>:\n  2           0 LOAD_GLOBAL              0 (abs)\n              2 LOAD_FAST                0 (x)\n              4 CALL_FUNCTION            1\n              6 RETURN_VALUE\n\n>>> dis(fun_sort_without_lambda)\n  2           0 LOAD_GLOBAL              0 (sorted)\n              2 LOAD_FAST                0 (l)\n              4 LOAD_GLOBAL              1 (abs)\n              6 LOAD_CONST               1 (('key',))\n              8 CALL_FUNCTION_KW         2\n             10 RETURN_VALUE\n```\n\nfor the function *fun_sort_with_lambda*, there is an additional function has been generated for lambda. We can avoid this function generation without using lambda as we can see in function *fun_sort_without_lambda*. \n\n### List comprehension is fast\n\nWhen operating over lists like data structures, list comprehension is faster than traditional methods like looping, functional programming, etc.\n\n```python\n%%timeit\nrand_nums = []\nfor _ in range(1000):\n    rand_nums.append(randint(1, 100))\n```\n```output\n603 µs ± 15.3 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)\n```\n\nThe list comprehension version of the above code snippet runs faster.\n\n```python:output\n%%timeit\nrand_nums = [randint(1, 100) for _ in range(1000)]\n```\n```python:output\n565 µs ± 11 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)\n```\n\n---\n\nThe optimization practices are not limited to the above approaches. We can check how much time it is taking for each line by using libraries like [CProfile](https://docs.python.org/3/library/profile.html) and making changes to run faster. In the next blog, we discuss how to improve Python computing efficiency using multiprocessing.\n\n---\n\n### References\n- [Python Speed](https://wiki.python.org/moin/PythonSpeed)\n- [Python Optimization](https://aglowiditsolutions.com/blog/python-optimization/)\n- [Making Python Programs Blazingly Fast](https://martinheinz.dev/blog/13)"},{"metadata":{"title":"Super fast Python (Part-1): Why Python is Slow?","description":"Why Python is slow compared to C/C++ or Java? And where can we improve our code to run fast?","imgName":"super-fast-python-why-python-slow/super-fast-python-why-python-slow.jpg","date":"Nov 7, 2022","tags":["python-performance"],"keywords":["python-performance","python-optimize","python","fast-python","speed","python","slow-python"],"id":"super-fast-python-why-python-slow"},"content":"\n![Super fast Python: Why Python is Slow?](super-fast-python-why-python-slow/super-fast-python-why-python-slow.jpg)\n\n# Super fast Python (Part-1): Why Python is Slow?\n\nPython is an interpreted, high-level, and dynamically typed programming language. Developers prefer Python because of its easy-to-learn, flexibility, fast development, easy-to-code, readability, and many other development choices. From nowhere in the 2000s to the most used programming language right now, Python has come a long way with help of a strong community. But, there has been always a discussion on Python's choice for computation-intensive tasks like Machine Learning as Python is generally slow compared to widely used languages like C/C++ and Java. Even with the development of computation-efficient libraries and packages like Numpy, still Python is slow for general usage. \n\nPython's core development team has been working to make Python as fast as C/C++. They set a goal to make each Python release significantly faster than the earlier release. The current [Python 3.11 is up to 10-60 percent faster than Python 3.10](https://docs.python.org/3.11/whatsnew/3.11.html#faster-cpython). Let's hope we will reach a state where Python is at least at the same speed level as Java if not C++. \n\nOne common practice to tackle the speed issues in production is to upgrade the hardware resources or upscale the cloud infrastructure that increases the project budget. As Python's core development team is trying to improve Python, it's up to us to leverage the core libraries and code practices to make code faster at the developer's end and eventually use fewer resources and budget.\n\nThis is the first post in the series on Python performance and Optimization. The series points out the utilization of inbuilt libraries, low-level code conversions, and other Python implementations to speed-up Python. The other posts included in this series are \n\n- (Part-1): Why Python is slow? (this post)\n- (Part-2): [Good practices to write fast Python code](https://santhalakshminarayana.github.io/blog/super-fast-python-good-practices)\n- (Part-3): [Multi-processing in Python](https://santhalakshminarayana.github.io/blog/super-fast-python-multi-processing)\n- (Part-4): [Use Cython to get speed as fast as C](https://santhalakshminarayana.github.io/blog/super-fast-python-cython)\n- (Part-5): [Use Numba to speed up Python Functions and Numeric calculations](https://santhalakshminarayana.github.io/blog/super-fast-python-numba)\n\n---\n\n## Why Python is slow?\n\nBefore looking into how we can optimize the Python code, we should look at first why Python is slow. \n\nSome of the reasons for Python's slowness is due to its design of core details like how code executes, type-inference, and memory management. \n\n### Python implementation by interpretation\n\nPython is a programming language that talks about syntax and rules to write programs. Executing the code written is done by the [programming language implementation](https://en.wikipedia.org/wiki/Programming_language_implementation). This can be of two categories - Compilation and Interpretation. **CPython** is a Python implementation written in **C** that applies an interpretation approach to execute the python code written. CPython is the default runtime and reference implementation of Python and there are other runtimes like PyPy, Cython, Jython, etc., that take different execution approaches for different use cases. CPython is both an interpreter (widely represented) and a compiler as it complies the Python code to Python bytecode and then interprets it for the specific platform using Python Virtual Machine (PVM).\n\nCPython uses Global Interpreter Lock (GIL) on each CPython interpreter process. This means, within a single process, only a single thread processes the Python bytecode. We will see later why this behavior is both good and bad.\n\nAs interpretation is usually slow compared to compilation it is understood that Python is slow, but maybe up to 2x-3x times slower than C/C++. But it is not true, Java, which also interprets the code, is still many times faster than Python and this asks questions on what are other factors for slowness in Python. \n\nChanging the runtime of Python from interpretation to compilation like Cython and embedded C-code, or JIT with PyPy, we can improve the speed of Python many times. We will talk about Cython, and how to use it with Python, in a later article.\n\n### Comes the dynamically typing comes the problem \n\nOne of the beautiful features of Python is dynamic typing and many people like the way it is. But with dynamic typing, there is an additional burden on the interpreter to keep track of the type of variables that makes less scope for optimization. As Java is statically typed, the interpreter can optimize the bytecode generation and can interpret it faster than Python. \n\n```python\na = 1 # a as int\nb = a * 2 # b as int \n\na = 'python ' # a as string\n# c as a string with operations\n# of string and int\nc = a * b \n```\n\nIn the above snippet, the interpreter has to keep track of the *type* of **a** from top to bottom. If not dynamic typing is supported in Python, we have to declare types for every variable and the operation **c = a * b** is not possible then. So, with flexible support from Python, there is some overhead with the interpreter too.\n\n### That is an object, this too\n\nIn Python, everything is an object. Even functions too. If one can remember how objects are referenced in C++ (yes, the pointers), apply the same concept in Python for everything including built-in primitive (not exactly) types which are objects too and are specially taken care of. \n\nAssigning memory to the objects is done by creating actual memory to hold an object and a reference is given to the variables that point to the real object in the memory. Every time the variable changes its value, instead of changing the value in the memory, a new object is created and the variable is given the new location of the object that holds the new value. As CPython is implemented in C, objects created in Python are called PyObjects which are struct in C that refers to all Python objects.\n\n```python\n>>> a = 10\n>>> print(id(a))\n9801536\n\n>>> a = 12\n>>> print(id(a))\n9801600\n``` \n\nWe can see the address of **a** changes every time we change/assign the value because of how Python manages variables and their values. In C/C++, for variables, the addressing is done by creating an actual location for the variable instead of the value, and if the value changes, it just overwrites the previous value.\n\nPython has to create new objects, keep their references, delete unused objects, and repeat the cycle. This continuous cycle of object creation and deletion whenever variable values changes make runtime slow.\n\nThe major overhead that needs to address is Python's way of handling collections like Lists. In *C*, we create the arrays with fixed memory and the address of that array is fixed, and continuous memory allocation happens for all the elements starting from the fixed memory point. But in Python, for each value, an [object is created](http://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/) anywhere in the memory (not continuous), and the list holds only references to these objects. Working on these arbitrary memory locations make things complex and eventually takes more time.\n\n```python\n>>> l = [1, 2, 3, 4]\n>>> for i in l: \n        print(id(i))\n\nOUTPUT:\n-------\n\n9801248\n9801280\n9801312\n9801344\n```\n\nIn the above snippet, we can observe that the addresses for each element in the list are not the same or continuous.\n\nOne of the reasons why Numpy is faster is because it creates fixed memory of the array elements. The below snippet prints out the memory address of each element in the array and they are the same, meaning Numpy create an array with continuous memory address and they are easy to operate.\n\n```python\n>>> a = np.array([1, 2, 3, 4])\n>>> for i in a: \n        print(i.__array_interface__['data'][0]) \n\nOUTPUT:\n-------\n\n37936064\n37936064\n37936064\n37936064\n```\n\n\n### GIL, good and bad:=:gil-good-and-bad\n\nIn **C**, there is no inbuilt support for garbage collection. One has to manually de-allocate/free the memory. Unlike C, Python does garbage collection by using a mechanism called reference count. For every PyObject, Python keeps track of a count of how many references are pointing to the current object. If no reference is pointing to the current object, then, Python frees the memory by deleting the unused object. \n\nEarlier we talked about GIL that, in the current process, GIL locks the process to have only a single thread to run the Python interpreter. This does not mean we cannot use more threads, but it is hard and takes more time compared to multi-threading in other languages because CPython creates a separate environment for each thread. This limits multi-threading in Python to use only in situations where threads wait for external processes to complete like I/O operations, network requests, etc. \n\nWhen multiple threads access the same resource, it is hard to keep track of the reference count of objects. GIL is required in CPython to ensure thread-safe as it allows only a single thread to process. As Python is a general-purpose language, in most cases there is no need to implement multi-threading, and there is no problem with GIL.\n\nBut when there is a need to optimize CPU-intensive tasks, one must use multi-processing to utilize all cores and reduce the overall speed. We will talk about different use cases for multi-threading and multi-processing in the later part of this series.\n\n---\n\nNow, we have learned that there are a lot of things that contribute to the slowness of Python compared to other languages. We cannot change the design of Python but we can change how we write the code by using good libraries, code snippets, and changing implementations. \n\nIn the upcoming posts, we discuss how we can use both internal and external libraries like *multiprocessing*, *Cython*, and *Numba* to make Python blazingly faster."},{"metadata":{"title":"Image Enhancement using Retinex Algorithms","description":"Enhance low-light images using Retinex algorithms with Fast Fourier Transform in Python.","imgName":"retinex-image-enhancement/retinex-image-enhancement.jpg","date":"Mar 23, 2022","tags":["image-processing","color-science","opencv"],"keywords":["retinex","image-enhance","retinex-image-enhance","image-processing","python","color-correct","color-enhance","color-balance"],"id":"retinex-image-enhancement"},"content":"\n![Image Enhancement using Retinex Algorithms](retinex-image-enhancement/retinex-image-enhancement.jpg)\n\n# Image Enhancement using Retinex Algorithms\n\nIn the previous blog [Retinex theory of Color Vision](https://santhalakshminarayana.github.io/blog/retinex-theory-of-color-vision), we discussed the theory behind the Retinex model and other studies related to the human visual system of color constancy explained by the Retinex. Even though Retinex failed to accurately define the human color constancy, over the years the Retinex has been modified and used in many image processing applications mainly image color/contrast enhancement, dynamic image compression, shadow removal, and color balancing. In this blog, we apply the Retinex model and its modification algorithms to enhance the low-light color images.\n\n### Types of Retinex\n\nBased on the approach of computing the lightness of an image, Retinex algorithms are broadly categorized into four types as shown in the following image.\n\n![Retinex types:=:80](retinex-image-enhancement/retinex-types.jpg)\n\nAmong the above four types, **Center Surround Retinex** algorithms are widely used in image processing for image enhancement. In this blog, we discuss applying the following four algorithms from the center-surround category\n\n- Single-Scale Retinex\n- Multi-Scale Retinex\n- Multi-Scale Retinex with Color Restoration\n- Multi-Scale Retinex with Color Preservation\n\n## Retinex model and Lightness computation\n\nIn the previous blog about [Retinex theory](https://santhalakshminarayana.github.io/blog/retinex-theory-of-color-vision), we derived an equation that, the color of an image/scene that we perceive is equal to the illumination on the scene product the reflectance of the scene. When we formulate the previous statement in equation form, that gives\n\n$$\nRetinex(I)=Reflectance(r)*Illumination(S)\n$$\n\nwhere **I** is the retinex image, **r** is the reflectance of the surface, and **S** is the illumination on the surface. And the lightness of an image, which is computed in our visual system (Retina + Cortex) is computed by reflectance and illumination. If we assume illumination is uniform or smooth, then lightness depends only on reflectance value at a given position. \n\nWith this assumption, Land and McCann tried to compute the relative reflectance of an image to estimate the relative lightness of the scene. First, they proposed an algorithm that involves random paths and relative ratios to compute lightness. But that algorithm accuracy highly depends on the number of paths taken, and, it takes so much time to compute the number of paths increases. So, Land published another method to calculate the lightness of a pixel in which the lightness of a pixel is the ratio between the value of a pixel and the average of the surrounding pixels considering the density of these surrounding pixels to have density proportional to the inverse of the square distance.\n\n$$\nL_{(x,y)}=\\frac{I_{(x,y)}}{F_{(x,y)}*I_{(x,y)}} \\\\\nx\\in\\{0...M-1\\}, \\hspace2ex y\\in\\{0...N-1\\} \\\\\nM=no.of \\hspace1ex rows \\hspace2ex N=no.of \\hspace1ex columns\n$$\n\nwhere $L_{(x,y)}$ is lightness of image at pixel position $(x,y)$, and $F_{(x,y)}*I_{(x,y)}$ is the average of the surrounding pixels at $(x,y)$ given by the center surround function $F_{(x,y)}$.\n\nAs the retinex image is equal to the reflectance of the scene under no effect of illumination, the retinex image (**R**) is approximately equal to the relative lightness. That gives\n\n$$\nR_{(x,y)} \\approx \\log(I_{(x,y)}) - \\log(F_{(x,y)}*I_{(x,y)})\n$$\n\n---\n\n## Single Scale Retinex\n\n**Single-scale retinex (SSR)** is defined as the difference between the image at a given pixel (x,y) and the center-surround average of that pixel (x,y).\n\nThe calculation of the above surrounding pixels average is equal to the inverse square spatial function for a given pixel. And we can use any high pass filter to calculate the surrounding average (Ex. Gaussian distribution) that satisfies the above conditions. \n\nIf we consider Gaussian function ($G_{\\sigma}$) as center-surround function, then retinex image for each i-th channel in an image is,\n\n$$\nSSR_i{(x,y)} = \\log(I_i{(x,y)}) - \\log(G_{\\sigma}*I_i){(x,y)})\n$$\n\nThat is the Single-scale retinex of an image is estimated by taking the logarithm difference of image and point-surround filter of the image at position (x,y). The operation $(G_{\\sigma}*I_i)(x,y)$ is nothing but gaussian blur of an image with given scale ($\\sigma$). The implementation in python is pretty straight-forward as\n\n```python\nimport numpy as np\nimport cv2 \n\ndef get_ksize(sigma):\n    # opencv calculates ksize from sigma as\n    # sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8\n    # then ksize from sigma is\n    # ksize = ((sigma - 0.8)/0.15) + 2.0\n\n    return int(((sigma - 0.8)/0.15) + 2.0)\n\ndef get_gaussian_blur(img, ksize=0, sigma=5):\n    # if ksize == 0, then compute ksize from sigma\n    if ksize == 0:\n        ksize = get_ksize(sigma)\n    \n    # Gaussian 2D-kernel can be seperable into 2-orthogonal vectors\n    # then compute full kernel by taking outer product or simply mul(V, V.T)\n    sep_k = cv2.getGaussianKernel(ksize, sigma)\n\n    # if ksize >= 11, then convolution is computed by applying fourier transform\n    return cv2.filter2D(img, -1, np.outer(sep_k, sep_k))\n\ndef ssr(img, sigma):\n\t# Single-scale retinex of an image\n    # SSR(x, y) = log(I(x, y)) - log(I(x, y)*F(x, y))\n    # F = surrounding function, here Gaussian\n    \n    return np.log10(img) - np.log10(get_gaussian_blur(img, ksize=0, sigma=sigma) + 1.0)\n```\n\nThe function *ssr()* takes arguments of an image, for which retinex has to be estimated, and sigma value for Gaussian distribution. It returns the single-scale retinex image by subtracting the image and gaussian blur of an image. \n\n*get_gaussian_blur()* gives Gaussian blur of an image. In this function, we are not using normal *cv2.GaussianBlur()* method but calculating Gaussian blur using *cv2.filter2D()* using linear seperability of Gaussian distribution kernels. The reason is, *cv2.GaussianBlur()* is too slow for large kernels. But *cv2.filter2D()* applies filter to an image using [fast-Fourier transform](https://en.wikipedia.org/wiki/Fast_Fourier_transform) if *kernel size (ksize)* > 11. **fast Fourier transform** computes the convolution in a very few milliseconds than the traditional convolution that takes days or even years to complete.\n\n> As [OpenCV implementation of fast-Fourier transform](https://docs.opencv.org/4.5.5/de/dbc/tutorial_py_fourier_transform.html) is faster than NumPy implementation, we proceed with OpenCV default Fourier transform implementations instead of NumPy or SciPy.\n\n![Single scale retinex:=:100](retinex-image-enhancement/single-scale-retinex.jpg)\n\nIn the above image, for SSR with $\\sigma$=15, the output image has some corner areas enhanced but the color is not preserved and it all looks very dark and gray. In **SSR(80)** image, there has been some improvement in contrast enhancement than **SSR(15)**, but the corner regions became dark and the overall picture looks gloomy. And finally, in **SSR(250)** image, a significant contrast improvement is done compared to both **SSR(15)** and **SSR(80)**, but the corner regions became darker than the original image, and only the center region has been enhanced.\n\nIt is great that with simple subtraction of image and gaussian image we have enhanced parts of an image to look better but still not a good solution for overall performance. And results are different for different scale values and it is hard to select any single scale value that gives the best results as enhancement purely depends on the nature of the image.\n\n---\n\n## Multi Scale Retinex\n\nAs the choice of $\\sigma$ varies for different images for good results and different scale values enhance different parts of an image, we can combine **SSR** of different scales and give weightage for each scale and take a summation of all weighted-SSR images. This method is called **Multi-scale retinex (MSR)** of an image and it is defined as the weighted average of **n** single-scale retinex images for different $\\sigma$ values.\n\n$$\nMSR_i{(x,y)} = \\sum_{n=1}^Nw_{n}SSR_i{(x,y)}\n$$\n\nAs the output $MSR_i{(x,y)}$ image might contain negative real values and the range of values is not suitable for image representaion i.e not in range **[0-255]**, normalize the **MSR** output for range **[0-255]** given by the following equation\n\n$$\nMSR_i{(x,y)} = 255\\frac{MSR_i{(x,y)} - \\min(MSR_i)}{\\max(MSR_i) - \\min(MSR_i)}\n$$\n\nwhere for channel $i$, $MSR_i{(x,y)}$ is the pixel value at position $(x,y)$, $\\min(MSR_i)$ is minimum value of the channel, and $\\max(MSR_i)$ is maximum value of the channel  \n\nSo, Multi-scale retinex is calculated by taking single-scale retinex for different scales and it is computed by the following function \n\n```python\ndef msr(img, sigma_scales=[15, 80, 250]):\n    # Multi-scale retinex of an image\n    # MSR(x,y) = sum(weight[i]*SSR(x,y, scale[i])), i = {1..n} scales\n    \n    msr = np.zeros(img.shape)\n    # for each sigma scale compute SSR\n    for sigma in sigma_scales:\n        msr += ssr(img, sigma)\n    \n    # divide MSR by weights of each scale\n    # here we use equal weights\n    msr = msr / len(sigma_scales)\n    \n    # computed MSR could be in range [-k, +l], k and l could be any real value\n    # so normalize the MSR image values in range [0, 255]\n    msr = cv2.normalize(msr, None, 0, 255, cv2.NORM_MINMAX, dtype=cv2.CV_8UC3)\n    \n    return msr\n```\n\nWe give default sigma scale values as **[15, 80, 250]** with equal weights which preserve high, middle, and low frequencies of an image respectively. *msr()* computes the **MSR** of an image by calculating **SSR** for each $\\sigma$ scale. In the end, normalization of the **MSR** output is done because the computed values could be negative real values and not in a suitable range **[0-255]** for image representation.\n\n![Multi scale retinex:=:100](retinex-image-enhancement/multi-scale-retinex.jpg)\n\nThe **MSR** image for the above input image with scales **[15, 80, 250]** has many areas enhanced especially in the corner regions which are darker in the input image given by **SSR(15)**. And the retinex output has contrast separation comparatively better than the input image added by **SSR(80)** and **SSR(250)**, but the output image has an overall gray appeal. \n\nThe output **MSR** image is looking gray because retinex assumes the scene as in [Gray world](https://en.wikipedia.org/wiki/Color_normalization#Grey_world) where the average of all colors in the scene is close to gray color. If this assumption is failed in the input image, that is if there are colors that dominate the scene or some colors may not present, whatever the reason could be if the overall color average is not close to gray, then taking the average of multiple single-scale retinex images with equal weights gives output image with colors less saturated and close to gray color. So, we have to modify the Multi-scale retinex to preserve the color of the image.\n\n---\n\n## Multi Scale Retinex with Color Restoration\n\nAs the **MSR** of an image looks colorless, the Multi-scale retinex output is multiplied with **Color-restoration function (CRF)** of chromaticity to restore the original colors of the input image approximately. And this method of calculating the Color-restoration function and applying it to Multi-scale retinex output is called **Multi-scale retinex with Color Restoration (MSRCR)**.\n\n$$\nMSRCR_i{(x,y)} = MSR_i{(x,y)}*CRF_i{(x,y)}\n$$\n\nwhere $CRF_i{(x,y)}$ is color restoration vlaue for pixel (x,y) at i-th channel. The color restoration function is defined as\n\n$$\nCRF_i{(x,y)} = \\beta[\\log(\\alpha*I'_i{(x,y)}]\n$$\n\nwhere for i-th channel, at position $(x,y)$, **CRF** depends on the ratio composition of the pixel at (x,y) for that channel value to the sum of all channel values which is equal to calculating chromaticity coordinates. Chromaticity coordinates are calculated as\n\n$$\nI'_i{(x,y)} = \\frac{I_i{(x,y)}}{\\sum_{c=0}^{k-1} I_c{(x,y)}}\n$$\n\nwhere $k$ equals to no. of image channels, $\\alpha$ is to control non-linearity, and $\\beta$ is to control total gain. The above equation can be written as\n\n$$\nCRF_i{(x,y)} = \\beta[\\log(\\alpha*I_i{(x,y)}) - \\log(\\sum_{c=0}^{k-1} I_c{(x,y)})] \\\\\n$$\n\nTo achieve better contrast results, the **MSRCR** equation is modified to include **gain (G)** and **offset (b)** values.\n\n$$\nMSRCR_i{(x,y)} = G[MSR_i{(x,y)}*CRF_i{(x,y)} - b]\n$$\n\nThe gain and offset values are introduced to transform the contrast range of the **MSRCR** image to distribute uniformly and to attenuate tails forming in the histogram graph. But these values are not general and don't work for every image. And to stretch the contrast, the final **MSRCR** image is [contrast stretched](https://en.wikipedia.org/wiki/Histogram_equalization) using [Simplest Color Balance](http://www.ipol.im/pub/art/2011/llmps-scb/) algorithm with a clipping percentage of 1% at both ends.\n\nWe use default values suggested by different publishers for the above variables as $\\alpha=125, \\beta=46, G=192, b=-30$\n\n```python\ndef color_balance(img, low_per, high_per):\n    '''Contrast stretch img by histogram equilization with black and white cap'''\n    \n    tot_pix = img.shape[1] * img.shape[0]\n    # no.of pixels to black-out and white-out\n    low_count = tot_pix * low_per / 100\n    high_count = tot_pix * (100 - high_per) / 100\n\n    # channels of image\n    ch_list = []\n    if len(img.shape) == 2:\n        ch_list = [img]\n    else:\n        ch_list = cv2.split(img)\n    \n    cs_img = []\n    # for each channel, apply contrast-stretch\n    for i in range(len(ch_list)):\n        ch = ch_list[i]\n        # cummulative histogram sum of channel\n        cum_hist_sum = np.cumsum(cv2.calcHist([ch], [0], None, [256], (0, 256)))\n\n        # find indices for blacking and whiting out pixels\n        li, hi = np.searchsorted(cum_hist_sum, (low_count, high_count))\n        if (li == hi):\n            cs_img.append(ch)\n            continue\n        # lut with min-max normalization for [0-255] bins\n        lut = np.array([0 if i < li \n                        else (255 if i > hi else round((i - li) / (hi - li) * 255)) \n                        for i in np.arange(0, 256)], dtype = 'uint8')\n        # constrast-stretch channel\n        cs_ch = cv2.LUT(ch, lut)\n        cs_img.append(cs_ch)\n    \n    if len(cs_img) == 1:\n        return np.squeeze(cs_img)\n    elif len(cs_img) > 1:\n        return cv2.merge(cs_img)\n    return None\n\ndef msrcr(img, sigma_scales=[15, 80, 250], alpha=125, beta=46, G=192, b=-30, low_per=1, high_per=1):\n    # Multi-scale retinex with Color Restoration\n    # MSRCR(x,y) = G * [MSR(x,y)*CRF(x,y) - b], G=gain and b=offset\n    # CRF(x,y) = beta*[log(alpha*I(x,y) - log(I'(x,y))]\n    # I'(x,y) = sum(Ic(x,y)), c={0...k-1}, k=no.of channels\n    \n    img = img.astype(np.float64) + 1.0\n    # Multi-scale retinex and don't normalize the output\n    msr_img = msr(img, sigma_scales, apply_normalization=False)\n    # Color-restoration function\n    crf = beta * (np.log10(alpha * img) - np.log10(np.sum(img, axis=2, keepdims=True)))\n    # MSRCR\n    msrcr = G * (msr_img*crf - b)\n    # normalize MSRCR\n    msrcr = cv2.normalize(msrcr, None, 0, 255, cv2.NORM_MINMAX, dtype=cv2.CV_8UC3)\n    # color balance the final MSRCR to flat the histogram distribution with tails on both sides\n    msrcr = color_balance(msrcr, low_per, high_per)\n    \n    return msrcr\n```\n\n![Multi scale retinex with color restoration - MSRCR:=:100](retinex-image-enhancement/msrcr.jpg)\n\nIn the above **MSRCR** output image, the color contrast has been improved compared to Multi-scale retinex. Still, the color contrast is not as close to the original image. With using default values for gain, offset, and others, there might be a chance that some pixels will over-saturate and some will under-saturate. And working around different value settings for different images is not expected behavior from a good enhancement algorithm. The main drawback of this algorithm is to control at least 6 variables which is not a general working method.\n\n---\n\n## Multi Scale Retinex with Color Preservation\n\nIn the previous algorithm **MSRCR**, color restoration was the main issue, and to address that we have introduced many variables and operations. All these calculations are computed directly on each channel value that changes chromaticity coordinates/color composition and the final result is unwanted colors, reversed color order, and sometimes grayish region due to surrounding average. To maintain the chromaticity/color composition as it is and also enhance the color contrast globally on the image, we can apply Multi-scale retinex on **intensity** image-channel which is just an addition of all image channels divided by the total number of channels.\n\n$$\nInt_{(x,y)}=\\frac{\\sum_{c=0}^{k-1}I_c{(x,y)}}{k}\n$$\n\nwhere $k$ is no. of image channels.\n\nAfter applying Multi-scale retinex to the intensity image, apply contrast stretch like applied in **MSRCR** to set the image values in the range **[0-255]** with uniform distribution of histogram values.\n\n$$\nRInt_{(x,y)}=MSR(Int_{(x,y)})\n$$\n\nafter the **MSR**, apply the color balance step with a percentage clipping of 1% on both sides.\n\nFinally, preserving the initial chromaticity ratio between each image-channel and intensity image, multiply the ratio with enhance-intensity image channel for each image-channel to get the whole image.\n\nAs we are applying retinex enhancement only on intensity-image, each color changes proportional to the ratio between enhance-intensity and normal intensity values. This keeps the relative intensity between surrounding colors locally and globally and gives better results than **MSRCR**.\n\n$$\nR_i{(x,y)}=I_i{(x,y)}\\frac{RInt_i{(x,y)}}{Int_{(x,y)}}=I_i{(x,y)}*A_{(x,y)}\n$$\n$$\nA_{(x,y)}=\\min(\\frac{MAX\\_VALUE}{B}, \\frac{RInt_{(x,y)}}{Int_{(x,y)}})\n$$\n$$\nB_{(x,y)}=\\max(I_c{(x,y)}, c\\in\\{0...k-1\\})\n$$\n\n```python\ndef msrcp(img, sigma_scales=[15, 80, 250], low_per=1, high_per=1):\n    # Multi-scale retinex with Color Preservation\n    # Int(x,y) = sum(Ic(x,y))/3, c={0...k-1}, k=no.of channels\n    # MSR_Int(x,y) = MSR(Int(x,y)), and apply color balance\n    # B(x,y) = MAX_VALUE/max(Ic(x,y))\n    # A(x,y) = max(B(x,y), MSR_Int(x,y)/Int(x,y))\n    # MSRCP = A*I\n    \n    # Intensity image (Int)\n    int_img = (np.sum(img, axis=2) / img.shape[2]) + 1.0\n    # Multi-scale retinex of intensity image (MSR)\n    msr_int = msr(int_img, sigma_scales)\n    # color balance of MSR\n    msr_cb = color_balance(msr_int, low_per, high_per)\n    \n    # B = MAX/max(Ic)\n    B = 256.0 / (np.max(img, axis=2) + 1.0)\n    # BB = stack(B, MSR/Int)\n    BB = np.array([B, msr_cb/int_img])\n    # A = min(BB)\n    A = np.min(BB, axis=0)\n    # MSRCP = A*I\n    msrcp = np.clip(np.expand_dims(A, 2) * img, 0.0, 255.0)\n    \n    return msrcp.astype(np.uint8)\n```\n\n![Multi scale retinex with color preservation - MSRCP:=:100](retinex-image-enhancement/msrcp.jpg)\n\nThe final **MSRCP** image above is looking much better than the **MSRCR** image by preserving relative color intensities in surrounding areas like stand boards have colors enhanced with maintaining relative color ratios between surroundings. The dark regions around the corner are transformed to bright colors but unwanted gray blocks are also upscaled due to a lack of texture information. \n\n---\n\n### Result of other images\n\nThe output results for other images are\n\n![Retinex image enhancement result:=:100](retinex-image-enhancement/retinex-result-1.jpg)\n\n![Retinex color enhancement result:=:100](retinex-image-enhancement/retinex-result-2.jpg)\n\nThe **MSRCP** output images are better than **MSRCR** if the scene has different colors like in images 4th, 5th, and 7th image. Under mono-color illumination like in the 6th image, **MSRCP** gave a highly saturated blue image while the output from **MSRCR** looks decent. Choice of the algorithm depends on the scene conditions like illumination, object colors, etc.\n\n---\n\nThe Retinex algorithms presented in the above sections are very basic but gave good results. Most of the super-enhance, image super-resolution, and image-compression models have an underlying model structure based on Retinex. There are other modified Retinex algorithms developed by Gimp, NASA, etc, which give industry-level results. Without training deep-learning models, we can use these Retinex algorithms to implement simple image-enhance filters where we can save resources and time.\n\n---\n\n### References\n\n- [Retinex Theory of Color Vision](https://santhalakshminarayana.github.io/blog/retinex-theory-of-color-vision)\n- [Multiscale Retinex](http://www.ipol.im/pub/art/2014/107/)"},{"metadata":{"title":"Retinex Theory of Color Vision","description":"Retinex theory explains the color constancy of Human Visual System that used in many Image processing applications.","imgName":"retinex-theory/retinex-theory.jpg","date":"Feb 28, 2022","tags":["color-science"],"keywords":["retinex","color-constancy","retinex-theory","mondrian","human-visual-system","image-processing"],"id":"retinex-theory-of-color-vision"},"content":"\n![Retinex Theory](retinex-theory/retinex-theory.jpg)\n\n# Retinex Theory of Color Vision\n\nRetinex Color Theory first proposed by Edwin Land in 1964 aimed to explain the color constancy of the Human Visual System. Retinex theory tries to explain how our visual system works for color changes and perceives object/scene color despite changes in illumination.\n\nColor constancy is a phenomenon in which the human visual system adapts to illumination/lighting changes and identifies the relative color of the object correctly like we can observe the color of an apple as red in both bright light and dark light.\n\n> To understand how the human visual system sees color, read my later post about [Color Science](https://santhalakshminarayana.github.io/blog/color-science).\n\n> Read more about Color Constancy and adaptation in the previous article on [Chromatic Adaptation](https://santhalakshminarayana.github.io/blog/chromatic-adaptation).\n\nWith Retinex, Land challenged the conventional color theory that states color sensation occurs due to the mixing of colors and discount of illumination. Land, his colleagues, and other researchers worked for many decades and still working to improve the Retinex theory of understanding Color vision that speaks about color processing, color sensation, and color constancy in our visual system and also using the Retinex model in image processing applications.\n\n---\n\n## Red and White image experiment\n\nIn 1959, Land conducted a series of experiments based on the principles of color formation by mixing 3 primary colors (red, blue, green). A color can be seen with the sensitivity of Cones cells that responds to primary color intensities coming from the surface. The Cones cells have three types of photoreceptor cells which are Long(L), Medium(M), and Short(S) cones that respond to three overlapping bands of wavelengths of the visual spectrum and stimulate the colors red, blue, and green respectively.\n\nAn image is a composition of these 3 primary colors and our eye stimulates L, M, and S cone cells to perceive color by interleaving these three color sensations. And Rods are a type of photoreceptor cells that are activated only when there is a low level of illumination threshold(dark light) on the scene below where cones cannot stimulate the cells and rods sense object colors as shades of gray(black and white ranges). As an image is a combination of three colors and if we can separate these three colors and make image color (red, blue, green) channels, and if viewed each channel image, it looks like a black and white image. This black and white channel image tell how much composition does have of each color.\n\nNow, according to classical color theory principles, to form a color, one does have to mix all primary colors in any composition. But Land discovered that with only single primary color, a whole wide gamut of colors of a scene can be formed and showed results in his published paper [Experiments in Color Vision](http://www.millenuvole.org/f/Fotografia/Per-quali-ragioni-vediamo-i-colori/edwin_land_1959.pdf). \n\n![Experiments in Color Vision:=:75:=:Original scene red and green channels black-and-white transparencies recording.](retinex-theory/red-green-channel-image-recording.jpg)\n\nHe did this by projecting a red channel transparent black-and-white image through a red filter and a green channel transparent black-and-white image without a filter (that is white light) which were earlier taken from the original scene with various objects in color. By superimposition of light coming from the red filter and no filter (green channel image), it was observed that with increasing intensity of red light, colors appearing by superimposition covered a wide gamut of colors of the original scene but not accurate colors.\n\n![Experiments in Color Vision:=:75:=:Projecting red image recording through a red filter and green image transparent through no filter (white light). Observe that, even with the only red color channel, we can see some range of colors compared to the original image.](retinex-theory/red-and-white-image-experiment.jpg)\n\nThe colors formed are shades of red and a wide range of saturated colors. As this experiment showed different colors formation with only red and white light, Land called this experiment a **Red-and-White image**.\n\n> Before proceeding further reading it's better to have an understanding of terms related to light like **illumination**, **radiation energy**, **radiant flux**, **radiance**, **surface reflectance**, etc.\n\n### Lightness\n\nLightness is one of the most important concepts that Land proposed to understand the color vision of humans. Before understanding the colorful world, he started uncovering non-colorful details like black-and-white sensations we observe in dark vision which is when rods are activated and identifies scene color in the range from white to black. \n\nIn the dark vision, for color objects, our eyes perceive objects color of red, blue, and black as darker, green and white as lighter. The color of an object in night vision is not determined by the amount of light energy we are getting at the eye, but the nature of objects which have the amount of composition of the above colors. So whether increased or decreased illumination on the scene or radiant energy coming to the eye, the color perception is close to the object's true nature in the range of white-to-black colors. Lighter objects look light and darker objects look dark irrespective of radiation flux reaching the eye. Thus we can say colors of scene/image when only one photoreceptor (here rods) is functioning are the only range of white-to-black colors. And the lightness of a point in a scene is simply how much lighter it is compared to the lightest point in the scene. \n\nSo, the lightness value of an image/scene tells the black and white range value when only one photoreceptor is activated. You can imagine lightness as a single image channel that consists of only black and white colors as described in the above section. And this behavior can be extended to cones cells and each L, M, and S cone produce lightness values independently. The lightness of an area would be affected by the surrounding area's lightness like a small area when surrounded by a large area, the small area lightness depends on the large area if it is lighter or darker.\n\nIn our visual system, irrespective of illumination and flux reaching the eye, when light falls on the retina and it is observed by L, M, and S visual pigments independently and produce a response to the receptor system that converts these responses to produce lightness of that particular cell sensation which doesn't to relate the amount of flux energy reaching the eye.\n\nNow one can assume this lightness as red, blue, and green sensitivity values of a scene that processed independently by three visual receptor cells. If rods and L cones are activated with an illumination level that cuts off M and S cone's responsivity, then the resultant combination is a composition of black-and-white values from rods and red values from L cone cells. \n\nJohn McCann and Jeanne Benton reproduced the above Red-and-White image experiment by observing the color sensations of an eye when only rods and L cells are activated. This experiment is similar to projecting a red channel image through a red filter and a green channel image through no filter (white light). Rods cells activated when the scene was illuminated with a 550nm narrow waveband of light and long-wave receptor cells (L) activated with a 656nm narrow band of light. As L cones sense red color and rod cells sense black-and-white, the results observed of the scene were similar to the original experiment and various close colors of the original scene were observed.\n\n---\n\n## Retinex\n\nThe location of production of lightness in the visual system is uncertain that is it would be formed either in the retina or cortex or in both. As there is uncertainty about the location, Land coined the term **Retinex** which is a combination of retina and cortex. And Retinex is a biological mechanism of converting light to lightness that can happen in any part of the visual system.\n\nThe experiments above raise questions that what makes the color? From the above two-receptor experiment which produced color even though medium and short receptors haven't observed anything, Land concluded that independent lightness of each photoreceptor cell are compared to each other and the color is formed by comparing lightness values of different regions of the scene which contradicts the then existing belief of color formation by mixing of response by photoreceptors.\n\nFor color constancy, Land stated that as the lightness of three independent receptors is independent of flux reaching the eye (and also illumination), no matter what the illumination projected on the scene out visual system produces lightness for each of three wavebands and comparison of these lightness values makes color. So we achieve color constancy because of lightness produced independently of flux. The previous statement is quite convincing to answer the human color constancy behavior. But how one can measure lightness? how to prove color constancy with lightness independent of flux? We will cover these questions in the following experiment involving the color Mondrian.\n\n\n### Retinex system respone\n\nBefore proceeding to the color Mondrian experiment, let's first discuss Retinex responses that are equal to the human visual response that converts light energy to lightness for three independent receptor cells. To measure the visual sensitivity response of each cell, a device is developed using film-filter combinations to match the responsiveness of photoreceptor cells. \n\n![Spectral sensitivities of visual receptor cells:=:70:=:Spectral sensitivities of each photoreceptor cell for each waveband range in spectrum.](retinex-theory/spectral-sensitivities-retinex.jpg)\n\nIn the above diagram, the visual pigment sensitivity of the human eye is represented. The solid gray curve for rods and solid black curves for each cone cell. Broken line curves represent the matching sensitivities of the device for each of the photoreceptor cells. With this device that produces sensitivities like the human visual system, black-and-white images for each cell can be produced, and the resultant formation record/image represents respective lightness for that cell. And whenever there is lightness, Retinex comes in. So, the lightness records are called Retinex records which are black-and-white lightness of each cell responsiveness.\n\n---\n\n## Color Mondrian experiment\n\nTo prove that the human visual system adapts to illumination changes and performs color constancy, the Color Mondrian experiment was conducted by Land by preparing two identical boards filled with different color papers of various rectangular sizes. The resultant board formation is called **Mondrian** because the arrangement of color papers in different area sizes resembles the artwork of the Dutch painter Piete Mondrian. \n\n![Color Mondrian:=:30:=:Color Mondrian](retinex-theory/mondrian.jpg)\n\nThe two identical Mondrian boards are illuminated by three (red, green, blue) light projectors equipped with 670nm long-band, 540nm medium-band, and 450nm short-band wave filters. The illumination settings of these three different projectors are controlled to project any overall illumination conditions by changing light intensity. A photometer is used to read the amount of radiation reflected from any region of Mondrian. \n\n![Color Mondrian projection experiment:=:75:=:Two identical Mondrians are illuminated focusing green and red areas respectively.](retinex-theory/color-mondrian-projection.jpg)\n\nInitially left side illumination is on and the right side is projection is off. Then select an area on the left Mondrian say green, change the illumination settings of the three projectors so that the green area looks pure green on the left side. Read radiance values from the photometer of the light that reaches the eye. Radiance values are measured one by one by turning off the other two projectors. Assume **(X, Y, Z)** is the radiance values for long, medium, and short waveband projectors coming from the left side. \n\nNow on the right side, select an area other than green say red patch. For each of the projectors on the right side, turn on one projector and keep the other two projectors off. Change illumination so that the radiance value measure is the same as that coming on left side projectors. For example, on the long wave projector and turn-off medium and short waveband projectors. Increase/decrease the intensity of the long-wave projector so that the radiance value measured is equal to **X**. Repeat the same for other medium and short wavebands so that respective radiance values are equal to **Y** and **Z**. After reading values individually, turn on all three projectors and observe the color of the selected patch. It looks the same as red color even though the same quanta catch on the retina. \n\nThis observation that despite the same light energy reaching the eye, we can identify the patch color closely as green and red. This result challenges the principle that different colors are recognized by the eye depending on the amount of light intensity for each of the long, medium, and short wavebands contain. Here despite identical light energy (X, Y, and Z radiances) falling on the retina, we can identify different colors.\n\nThis makes Land conclude that color sensation in the human visual system processes each of long, medium, and short wavebands individually and forms another informative image called lightness image (as described above) for each of the three cones cells. The lightness images calculated are independent of the amount of light intensity reaching the eye.\n\nLightness is independent of flux because it can be observed that when only one receptor is active, let's take a long wave, despite the change in intensity of light, red color appears light. For medium and short waveband, red color is observed as darker and very dark respectively. So that for every color, the level of lightness for each of the three receptors is constant despite the change in light energy.\n\n\nNow we know lightness is independent of light illumination and we have to examine how the reflectance from the surface affects the color sensation under different illuminations.\n\n---\n\n## Color Mondrian and Munsell Chip matching experiment\n\nJohn J. McCann, Suzanne P. McKee, and Thomas H. Taylor experimented to study responses of observers if asked to match Mondrian areas to respective color in Munsell's book of color (which contains color swatch for hundreds of colors).\n\n![Color Mondrian and Munsell chip matching:=:75:=:Observers view Mondrian and Munsell chips through left and right eyes resepectively](retinex-theory/mondrian-munsell-view.jpg)\n\nThe color Mondrian is made with 17 different colors and projected under various illuminations and observers are asked to match the corresponding Munsell chip for every Mondrian color. Munsell's book is viewed under constant white illumination so that the white color looks pure white. The color chips are viewed by surrounding large gray paper which has a square cut to look exactly one chip at a time. Observers view Mondrian through the left eye and Munsell chips through the right eye.\n\nFirst observers are asked to match 17 Munsell chips for each of the Mondrian color patches under illumination settings that lit gray area in Mondrain as pure gray. Now record the triplet of radiance energies coming to the eye from the gray region on Mondrian say **(X, Y, Z)** for long, medium, and short wavebands, and also read radiance triplet for the gray chip in Munsell chip. After reading, select another patch, take the red region on Mondrian, and change illumination settings that the radiance triplet coming from the red region is the same as **(x, Y, Z)**, Note the matched Munsell chips for each of the Mondrian areas under this illumination that red region sent **(X, Y, Z)** radiance triplet. Repeat the experiment for adjusting illumination for yellow, blue, and green so that triplet energies coming from each of the respective areas is the same as **(X, Y, Z)** and note down the matched 17 chips and radiance triplet values. Throughout the experiment, only illumination settings for Mondrian change, and Munsell's book is viewed under constant illumination. Several observers are asked to match colors and matching colors are averaged over all experiments. And results showed that observers matched color chips approximately to several Mondrian color patches even under different illuminations. This shows color constancy under different illuminations by observers. \n\nRadiances are measured by a combination of photomultiplier and the retinex filters which measure different waveband responses that are close to the human visual system. This photomultiplier-retinex combination measures the integrated radiation flux for a given area for different wavebands. The resultant value is called integrated radiance as it gives radiation energy integrated for an area.\n\nIllumination values and light triplet integrated radiance values reaching the eye are known but don't know the reflectance from the surface. The reflectance of a surface is the amount of light reflected divided by the amount of light incident on the surface. Reflectance in general is not a comparison value and doesn't give a relative measurement. As white surface reflects almost all amount light, McCann and his colleagues used white as a comparison for forming scaled reflectance values. First, they illuminated the white surface with illumination that had been used for illuminating Munsell's book of color. They recorded integrated radiance values for each of the wavebands coming from a white surface. Now for any surface, reflectance can be obtained by dividing radiance values with radiance values for the white surface under the same illumination. The reflectance values are expressed as a percentage in the range 0-100 with 100 percent being maximum reflectance that is white surface reflectance.\n\n### Lightness Sensation\n\nObservers are asked to arrange different shades of black and white color patches in a range from darkest to lightest, and reflectance values are recorded for every color in the range. A function has been derived based on several arrangements by different observers, and the function gives the relation between black-and-white colors and reflectance value. Based on reflectance values for a single narrow-band wave, lightness sensations are scaled from 0-10 equally spaced intervals as shown in the following figure\n\n![Lightness Sensation:=:60:=:Lightness sensation vs Reflectance for shades of black-and-white colors](retinex-theory/lightness-sensation.jpg)\n\nReflectance values for various Munsell chips are determined under the same white illumination. It is observed that reflectance values for the Mondrian area and corresponding matched Munsell chips are close.\n\n\nNow back to the experiment, a very close relation between reflectance and illumination is observed that the light energy reaching the eye is equal to reflectance product illumination. \n\n![Reflectance product Illumination:=:90:=:](retinex-theory/reflectance-illumination-relation.jpg)\n\nIn the above image, the left side charts denote Mondrian color paper values and the right side denotes matched Munsell chip values. The bar chart denoting reflectance has values in scaled reflectance in the range of 0.0-1.0 for each of the three narrow-bands 630nm, 530nm, and 450nm. For both Mondrian and Munsell, light energy at the eye (recorded by photometer) is equal to the product of reflectance and illuminant. \n\nFrom this data, the relation between surface reflectance, illumination of surface, and color sensation in the eye can be described as \n\n$$\nI=R*S\n$$\n\nwhere I is the surface image, R is the reflectance of the surface, and S is the illumination on the surface.\n\n---\n\nRetinex theory talks about how lightness is crucial for color constancy. But how does our visual system calculate the lightness of a scene for each of the receptor cells? How visual system scales these lightness values like lightness sensation and reflectance relation? Land stated that our visual system compares the lightness images and senses a color. The color of an object also depends on the surrounding colors and edges. This comparison of lightness across each receptor cell and for every region gives the sensation of color. And human visual system obtains these lightness values from only flux reaching the eye from a scene by comparing narrow-waveband response ratios at adjacent edges and surrounding areas that are independent of illumination and reflectance. \n\nFrom a lightness image, the eye compares different regions of the image and calculates the sequential product of ratios of reflectances to estimate maximum and minimum lightness values for that lightness image. These sequential products also give relative lightness between two regions of the image. Our visual system has evolved over the years to adapt to these changes and maintain color constancy.\n\nEven though Edwin Land's Retinex theory conceptualizes how the human visual system adapts to color constancy, the accuracy of the theory has not been proved yet, and many scientists disproved the relation between lightness and color adaptation. After many decades, there is still research going on Retinex theory and its applications mainly in image processing.\n\n---\n\n### References\n- [Colour vision: Is colour constancy real?](https://www.cell.com/action/showPdf?pii=S0960-9822%2899%2980354-6)\n- [Experiments in Color Vision - Edwin Land](http://www.millenuvole.org/f/Fotografia/Per-quali-ragioni-vediamo-i-colori/edwin_land_1959.pdf)\n- [The Retinex Theory of Color Vision - Edwin Land](http://perceptionstuff.weebly.com/uploads/2/8/4/7/2847832/land-retinex_theory.pdf)\n- [Lightness and Retinex Theory - Edwin Land and John J. McCann](https://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Land71.pdf)\n- [Retinex at 50](https://www.spiedigitallibrary.org/journals/journal-of-electronic-imaging/volume-26/issue-03/031204/Retinex-at-50--color-theory-and-spatial-algorithms-a/10.1117/1.JEI.26.3.031204.full?SSO=1)\n- [Retinex: Physics and the Theory of Color Vision](https://aip.scitation.org/doi/pdf/10.1063/1.4822794)\n- [Quantitative studies in Retinex Theory](https://www.semanticscholar.org/paper/Quantitative-studies-in-retinex-theory-a-comparison-McCann-McKee/a69002b2e276e111db8f4f18b690e03cbbeb9c4b)\n- [Color Vision Is a Spatial Process: The Retinex Theory](http://link.springer.com/content/pdf/10.1007%2F978-3-319-56010-6_3.pdf)\n- [Analysis of the retinex theory of color vision](https://color2.psych.upenn.edu/brainard/papers/retinex.pdf)"},{"metadata":{"title":"Chromatic adaptation (Color constancy)","description":"Color constancy of an image using Chromatic adaptation technique in Python.","imgName":"chromatic-adaptation/chromatic-adaptation.jpg","date":"Nov 26, 2021","tags":["image-processing","color-science","opencv"],"keywords":["color-science","color-constancy","chromatic-adaptation","gray-world","opencv","python"],"id":"chromatic-adaptation"},"content":"\n![Color constancy of an image using Chromatic adaptation](chromatic-adaptation/chromatic-adaptation.jpg)\n\n# Color constancy of an image using Chromatic adaptation\n\n## Color constancy\n\nColor constancy is the tendency of the human color system that ensures the color perception of objects is relatively constant under varying illumination conditions. It means we observe the same object colors for different light conditions. \n\nLike for example, under a greenish light source, the color of the apple looks relatively red even though the intensity of the green wavelength is greater than other colors. It's unknown how we (and some other animals) have this color perception system.\n\nSeveral mechanisms like metamerism, chromatic adaptation, memory map, etc. are involved in achieving color constancy. Metamerism happens when two object looks the same color even though the reflectance wavelengths are not the same but overall color is the same. Our memory map of object colors helps our eyes to adjust the color perception after some time under different illuminations. \n\nColor constancy is not true in every object case, for some objects under certain illumination conditions, it could be inverse. Color constancy happens in most of the cases for objects if we have seen them before and for other objects/surfaces, we observe the color of major intensity wavelength. Color constancy depends heavily on the illumination source and neighborhood surface.\n\n![Checker Shadow Illusion:=:50:=:Even though both A and B are the same gray color, A appears darker than B because of shadow from the cylinder which changes illumination on B](chromatic-adaptation/checker-shadow-illusion.jpg)\n\nSeveral theories like photoreceptor sensitivity, retinex, color map, etc, try to measure the color constancy using different mechanisms. \n\n## Chromatic adaptation \n\nChromatic adaptation is one of the mechanisms involved in color constancy and is defined as the ability of human color perception to adjust the retina/cortex sensitivity for changes in the illuminant color system. Chromatic adaptation is closely related to the adjustment of cone sensitivity that happens in our eyes when the illumination changes. Like our eyes adjust to see the objects as constant colors under different day-light conditions like sunrise, mid-day, and sunset. In all these conditions, we perceive object colors as the same. This could be opposite in some conditions where we see opposite colors instead of relative colors.  \n\nIn computer vision, computation color constancy is achieving human color constancy using different methods based on color constancy mechanisms. And chromatic adaptation technique is one of the methods to achieve computational color constancy based on illumination.\n\n### Von Kries transform\n\nThe Von Kries chromatic adaptation technique is based on the LMS cone sensitivity response function. LMS cones responses in the retina are independent of each other and they adjust independently for varying illuminations. Each cone increases or decreases responsiveness based on illuminant spectral energy. Each cone cell gains (increase or decrease) some spectral sensitivity response to adapt for new illumination from the previous illumination to perceive object constant colors. \n\nBased on LMS cones gain, Von Kries adaptation transforms one illuminant to other to keep the **white color** constant in both systems. Von Kries transform based on LMS cone sensitivity is the base for chromatic adaptation transforms proposed later.\n\n---\n\n## Chromatic adaptation transform\n\nVon Kries chromatic adaptation transformation is a linear transformation of the source color to destination color based on LMS cones gain for adaptation to destination illuminant. That is, we can transform the color in one illuminant to other illuminants if we scale the color with a gain of LMS for adaptation to color constancy. \n\n> If you're not familiar with concepts like **CIE RGB**, **CIE XYZ** tristimulus values, **chromaticity diagram**, and other color science topics, please refer to those topics at my previous blog about [color-science](https://santhalakshminarayana.github.io/blog/color-science).\n\nThe destination LMS cone responses can be calculated by multiplying the gain LMS with source LMS cone responses. In matrix form, the representation is \n\n$$\n\\begin{bmatrix}\nL_{D} \\\\\nM_{D} \\\\\nS_{D} \\\\\n\\end{bmatrix} = \n\\begin{bmatrix}\nL_{D}/L_{S} & 0 & 0 \\\\\n0 & M_{D}/M_{S} & 0 \\\\\n0 & 0 & S_{D}/S_{S} \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nL_{S} \\\\\nM_{S} \\\\\nS_{S} \\\\\n\\end{bmatrix}\n$$\n\nwhere **L, M, and S** of source and destination are represented in **CIE LMS color space**, and $$L_{D}/L_{S}$$, $$M_{D}/M_{S}$$, and $$S_{D}/S_{S}$$ are gain factors for source to destination illumination adaptation.\n\nAs color representation in **LMS color space** is difficult and not practiced, transform the **LMS color space** to **CIE XYZ**. When a transformation is performed in **CIE XYZ** or any other space but not **LMS cone space** is called **Wrong Von Kries**.\n\n$$\n\\begin{bmatrix}\nL \\\\\nM \\\\\nS \\\\\n\\end{bmatrix} = M_{A}\n\\begin{bmatrix}\nX \\\\\nY \\\\\nZ \\\\\n\\end{bmatrix}\n$$\n\n$$\n\\begin{bmatrix}\nL \\\\\nM \\\\\nS \\\\\n\\end{bmatrix} = \n\\begin{bmatrix}\na & b & c \\\\\nd & e & f \\\\\ng & h & i \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nX \\\\\nY \\\\\nZ \\\\\n\\end{bmatrix}\n$$\n\nwhere the transformation matrix $$M_{A}$$ with dimensions $$3x3$$ and independent gain control factors $$(a, e, i)$$ is called chromatic adaptation transform (CAT) matrix. Each CAT model give different CAT matrices for transformation from **LMS cone space** to **CIE XYZ**.\n\nWrong Von Kries transform by **XYZ** gain scaling to **CIE XYZ** tristimulus values of the source is,\n\n$$\n\\begin{bmatrix}\nX_{D} \\\\\nY_{D} \\\\\nZ_{D} \\\\\n\\end{bmatrix} = \n\\begin{bmatrix}\nX_{D}/X_{S} & 0 & 0 \\\\\n0 & Y_{D}/Y_{S} & 0 \\\\\n0 & 0 & Z_{D}/Z_{S} \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nX_{S} \\\\\nY_{S} \\\\\nZ_{S} \\\\\n\\end{bmatrix}\n$$\n\nWe can convert **CIE XYZ** to **LMS cone space** and then back to **CIE XYZ** with $$M_{A}$$, then we can change Wrong Von Kries to general Von Kries as,\n\n$$\n\\begin{bmatrix}\nX_{D} \\\\\nY_{D} \\\\\nZ_{D} \\\\\n\\end{bmatrix} = M\n\\begin{bmatrix}\nX_{S} \\\\\nY_{S} \\\\\nZ_{S} \\\\\n\\end{bmatrix}\n$$\n\n$$\nM = M_{A}^{-1}\n\\begin{bmatrix}\nL_{D}/D_{S} & 0 & 0 \\\\\n0 & M_{D}/M_{S} & 0 \\\\\n0 & 0 & S_{D}/S_{S} \\\\\n\\end{bmatrix} M\n$$\n\n$$\n\\begin{bmatrix}\nL_{S} \\\\\nM_{S} \\\\\nS_{S} \\\\\n\\end{bmatrix} = M_{A}\n\\begin{bmatrix}\nX_{S} \\\\\nY_{S} \\\\\nZ_{S} \\\\\n\\end{bmatrix}\n$$\n\n$$\n\\begin{bmatrix}\nL_{D} \\\\\nM_{D} \\\\\nS_{D} \\\\\n\\end{bmatrix} = M_{A}\n\\begin{bmatrix}\nX_{D} \\\\\nY_{D} \\\\\nZ_{D} \\\\\n\\end{bmatrix}\n$$\n\nThe generalized version of Von Kries for **CIE XYZ white point** reference is,\n\n$$\n\\begin{bmatrix}\nX_{D} \\\\\nY_{D} \\\\\nZ_{D} \\\\\n\\end{bmatrix} = M_{A}^{-1}\n\\begin{bmatrix}\nL_{D}/L_{S} & 0 & 0 \\\\\n0 & M_{D}/M_{S} & 0 \\\\\n0 & 0 & S_{D}/S_{S} \\\\\n\\end{bmatrix} M_{A}\n\\begin{bmatrix}\nX_{S} \\\\\nY_{S} \\\\\nZ_{S} \\\\\n\\end{bmatrix}\n$$\n\n$$(X, Y, Z)$$ values for source and destination are illuminant white point values in **CEI XYZ**.\n\n> [White point](https://en.wikipedia.org/wiki/White_point) is the color that is formed when all cone sensitivity responses are maximum.\n\n---\n\n## Implementation of Chromatic adaptation transform\n\nWe will implement chromatic adaptation for converting source image to destination illuminant by applying CAT. Chromatic adaptation for an image is implemented in two steps \n1. Estimate scene illuminant of image\n2. Convert source image to destination illuminant with source illuminant obtained in step 1\n\n### Illumination estimation of image\n\nIllumination estimation is predicting tristimulus values (CIE XYZ) for the white point of the illuminant light source under which the reference image has been taken. These predicted white point tristimulus values were then later used for CAT. Illumination estimation is a very crucial step in chromatic adaptation. Several illumination estimation methods exist like\n- Gray world assumption\n- White patch retinex\n- Reflection model\n\nThe above methods are suitable for uniform illumination, for nonuniform illumination Retinex models are widely used.\n\nFor now, we use the Gray world assumption for illumination estimation\n\n### Gray world assumption illuminant estimation\n\n[Gray world assumption](https://en.wikipedia.org/wiki/Color_normalization) is a simple method that assumes image contains objects with different reflectance colors uniformly from minimum to maximum intensities and averaging all pixel colors gives gray color. Illumination estimation is calculated by averaging all pixel values for each channel. For an image with equal representation of colors, illumination estimation gives average color gray.\n\n$$\nIlluminant = (R_{avg}/255, G_{avg}/255, B_{avg}/255)\n$$\n\nwhere $R_{avg}$, $G_{avg}$, and $B_{avg}$ are means of each image channel (R, B, G). Scale the mean values to the maximum intensity value of an image which is generally 255 (8-bit).\n\n> Images are generally stored in JPEG or PNG in [sRGB](https://en.wikipedia.org/wiki/SRGB) format. To mimic the human perception of non-linear luminance factor, while taking pictures, exposure values are [Gamma corrected](https://www.cambridgeincolour.com/tutorials/gamma-correction.htm) with a value close to 2.2. And any image processing operation should be applied on linear RGB values by converting sRGB gamma to linear RGB without gamma. \n\nRead source image to which we apply chromatic adaptation and transform to destination illuminant,\n\n```python\nimport numpy as np\nimport cv2\n\n# read image which generally in sRGB format\nimg = cv2.imread('input.jpg')\n# reverse channel order from BGR to RGB\nimg = img[:, :, ::-1]\n# scale image in range [0.0, 1.0]\nimg = img / 255.0\n```\n\nConvert sRGB image to linear RGB\n\n```python\ndef srgb_to_linear(srgb):\n    # 'sRGB' in [0.0, 1.0]\n\n    ln_rgb = srgb.copy()\n    mask = ln_rgb > 0.04045\n    ln_rgb[mask] = np.power((ln_rgb[mask] + 0.055) / 1.055, 2.4)\n    ln_rgb[~mask] /= 12.92\n    return ln_rgb\n\ndef linear_to_srgb(linear):\n    # 'linear RGB' in [0.0, 1.0]\n    \n    srgb = linear.copy()\n    mask = srgb > 0.0031308\n    srgb[mask] = 1.055 * np.power(srgb[mask], 1 / 2.4) - 0.055\n    srgb[~mask] *= 12.92\n    return np.clip(srgb, 0.0, 1.0)\n```\n\n![sRGB to linear RGB](chromatic-adaptation/srgb-to-linear-rgb.jpg)\n\nApply gray world on linear RGB image and get illuminant\n\n```python\ndef get_gray_world_illuminant(img):\n    # image in sRGB with range [0.0, 1.0]\n    # convert sRGB to linear RGB\n    ln_img = srgb_to_linear(img)\n    # mean of each channel\n    avg_ch = ln_img.mean(axis=(0, 1))\n    # convert back RGB mean values to sRGB\n    return linear_to_srgb(avg_ch)\n```\n\nIlluminant for the image is \n\n```python\nilluminant = get_gray_world_illuminant(img)\n```\n\n```python\nprint(illuminant) => array([0.29078475, 0.39055316, 0.50858647])\n```\n\nIlluminant for the above image is **[0.29078475, 0.39055316, 0.50858647]**. For the output illuminant, we can say that the blue color influence is higher than other color wavelengths in the image.\n\nNow we have the illuminant of the source image, next apply chromatic adaptation for this image.\n\n### Chromtic adaptation\n\nWe have source illuminant, to transform to destination illuminant, we consider [D65 standard illuminant](https://www.waveformlighting.com/color-matching/what-is-d65-and-what-is-it-used-for) for the destination which is standard for digital images and displays. We assume that the source image was taken under a different illuminant and we now transform that image to D65 illuminant.\n\nIlluminant for D65 white is **[0.95047, 1., 1.08883]**, these are the **CIE XYZ** values for white point of sRGB D65. sRGB values for D65 white point (all values are 255) is **(1.0, 1.0, 1.0)** which is destination illuminant white point. \n\nWe implement chromatic adaptation transform step-by-step.\n\n> Every operation should be applied on **linear RGB**\n\nFirst, convert illuminant sRGB values to **CIE XYZ**.\n\n```python\nRGB_TO_XYZ = np.array([[0.412453, 0.357580, 0.180423], \n                       [0.212671, 0.715160, 0.072169], \n                       [0.019334, 0.119193, 0.950227]])\n\nXYZ_TO_RGB = np.array([[3.240481, -1.537151, -0.498536],\n                       [-0.969256, 1.875990, 0.0415560],\n                       [0.055647, -0.204041, 1.057311]])\n\ndef srgb_to_xyz(srgb):\n    # convert 'sRGB' to 'linear RGB'\n    rgb = srgb_to_linear(srgb)\n    # convert 'linear RGB' to 'XYZ'\n    return rgb @ RGB_TO_XYZ.T\n\ndef xyz_to_srgb(xyz):\n    # convert 'XYZ' to 'linear RGB'\n    rgb = xyz @ XYZ_TO_RGB.T\n    # convert back 'linear RGB' to 'sRGB'\n    return linear_to_srgb(rgb)\n\ndef normalize_xyz(xyz):\n    # normalize xyz with 'y' so that 'y' represents luminance\n    return xyz / xyz[1]\n```\n\nConvert sRGB to XYZ passing source and destination white points\n\n```python\n# source illuminant white point obtained from previous step \nsrc_white_point = illuminant\n# destination illuminant white point scale to 1.0\ndst_white_point = (1.0, 1.0, 1.0)\n\n# convert white point in 'sRGB' to 'XYZ' \n# and normalize 'XYZ' that 'Y' as luminance\nxyz_src = srgb_to_xyz(src_white_point)\nn_xyz_src = normalize_xyz(xyz_src)\nxyz_dst = srgb_to_xyz(dst_white_point)\nn_xyz_dst = normalize_xyz(xyz_dst)\n```\n\nNext, convert XYZ values to LMS cone space by transforming XYZ values with CAT transform matrix. Multiple CAT matrices exist and the Bradford model is popular among all these types.\n\n```python\nBRADFORD = np.array([[0.8951, 0.2664, -0.1614], \n                     [-0.7502, 1.7135, 0.0367], \n                     [0.0389, -0.0685, 1.0296]])\n\nVON_KRIES = np.array([[0.40024, 0.70760, -0.08081],\n                      [-0.22630, 1.16532, 0.04570],\n                      [0.00000, 0.00000, 0.91822]])\n\nSHARP = np.array([[1.2694, -0.0988, -0.1706],\n                  [-0.8364, 1.8006, 0.0357],\n                  [0.0297, -0.0315, 1.0018]])\n\nCAT2000 = np.array([[0.7982, 0.3389, -0.1371],\n                    [-0.5918, 1.5512, 0.0406], \n                    [0.0008, 0.2390, 0.9753]])\n\nCAT02 = np.array([[0.7328, 0.4296, -0.1624],\n                  [-0.7036, 1.6975, 0.0061],\n                  [0.0030, 0.0136, 0.9834]])\n```\n\nConvert XYZ values to LMS and get gain scale factors by dividing destination LMS with source LMS.\n\n```python\ndef get_cat_matrix(cat_type = 'BRADFORD'):\n    if cat_type == 'BRADFORD':\n        return BRADFORD\n    elif cat_type == 'VON_KRIES':\n        return VON_KRIES\n    elif cat_type == 'SHARP':\n        return SHARP\n    elif cat_type == 'CAT2000':\n        return CAT2000\n    else:\n        return CAT02\n    \ndef xyz_to_lms(xyz, M):\n    return xyz @ M.T\n\ndef get_gain(lms_src, lms_dst):\n    return lms_dst / lms_src\n\ndef transform_lms(M, gain):\n    return np.linalg.inv(M) @ np.diag(gain) @ M\n```\n\n```python\n# get CAT type matrix\ncat_m = get_cat_matrix('BRADFORD')\n\n# convert 'XYZ' to 'LMS'\nlms_src = xyz_to_lms(n_xyz_src, cat_m)\nlms_dst = xyz_to_lms(n_xyz_dst, cat_m)\n# LMS gain by scaling destination with source LMS\ngain = get_gain(lms_src, lms_dst)\n\n# multiply CAT matrix with LMS gain factors\nca_transform = transform_lms(cat_m, gain)\n```\n\n*ca_transform()* applies chromatic adaptation transformation on LMS gain factors and then converts back the LMS values to XYZ by multiplying with the inverse transform of CAT matrix.\n\nTransform the source image to destination illuminant by multiplying XYZ values with chromatic adaptation transformation XYZ values.\n\n```python\n# convert 'sRGB' source image to 'XYZ' \nsrc_img_xyz = srgb_to_xyz(img)\n\n# apply CAT transform to image\ntransformed_xyz = src_img_xyz @ ca_transform.T\n\n# convert back 'XYZ' to 'sRGB' image\ntransformed_img = xyz_to_srgb(transformed_xyz)\n```\n\n**transformed_img** is the final image after transformation.\n\nThe final chromatic adaptation function that transforms source image to destination illuminant is\n\n```python\ndef chromatic_adaptation_image(src_white_point, dst_white_point, src_img, cat_type = 'BRADFORD'):\n    # convert white point in 'sRGB' to 'XYZ' \n    # and normalize 'XYZ' that 'Y' as luminance\n    xyz_src = srgb_to_xyz(src_white_point)\n    n_xyz_src = normalize_xyz(xyz_src)\n    xyz_dst = srgb_to_xyz(dst_white_point)\n    n_xyz_dst = normalize_xyz(xyz_dst)\n\n    # get CAT type matrix\n    cat_m = get_cat_matrix(cat_type)\n\n    # convert 'XYZ' to 'LMS'\n    lms_src = xyz_to_lms(n_xyz_src, cat_m)\n    lms_dst = xyz_to_lms(n_xyz_dst, cat_m)\n    # LMS gain by scaling destination with source LMS\n    gain = get_gain(lms_src, lms_dst)\n\n    # multiply CAT matrix with LMS gain factors\n    ca_transform = transform_lms(cat_m, gain)\n    \n    # convert 'sRGB' source image to 'XYZ' \n    src_img_xyz = srgb_to_xyz(src_img)\n    \n    # apply CAT transform to image\n    transformed_xyz = src_img_xyz @ ca_transform.T\n    \n    # convert back 'XYZ' to 'sRGB' image\n    transformed_img = xyz_to_srgb(transformed_xyz)\n    \n    return transformed_img\n```\n\n```python\n# read image which generally in sRGB format\nimg = cv2.imread('input.jpg')\n# reverse channel order from BGR to RGB and scale to 1.0\nr_img = img[:, :, ::-1] / 255\n# get source illuminant by illumination estimation\nsrc_white_point = get_gray_world_illuminant(r_img)\ndst_white_point = np.array([1.0, 1.0, 1.0])\n# apply chromatic apatation for source image\nca_img = chromatic_adaptation_image(src_white_point, dst_white_point, r_img, cat_type='BRADFORD')\n# reverse channel order from RGB to BGR, and rescale to 255\nca_img = (ca_img[:, :, ::-1] * 255).astype(np.uint8)\n```\n\n![Chromatic adaptation transform Batman](chromatic-adaptation/chromatic-adaptation-transform-batman.jpg)\n![Chromatic adaptation transform Pool](chromatic-adaptation/chromatic-adaptation-transform-pool.jpg)\n\nAs chromatic adaptation is done with reference white point, the transformed images contain improved white color ranges and other colors are transformed based on illumination transform obtained by white point transform. \n\nAs illumination estimation is a crucial step, we can improve results further by applying other illumination estimation methods and images with uniform color objects.\n\n---\n\n### ColorChecker\n\n[ColorChecker](https://en.wikipedia.org/wiki/ColorChecker) is a color checker chart containing multiple color squares or rectangles in a grid. ColorChecker chart contains a range of spectral reflectance color patches that represents natural object colors like human skin, leaves, flowers, sky, etc. These color patches on a whole represent all possible intensity ranges that are suitable for many uniform illumination conditions. \n\nColorChecker charts are used in photography while shooting images/videos under varying illumination conditions. Multiple scenes are shot under varying lighting conditions placing ColorChecker chart in the scene, and later based on the color patches illumination, images are adjusted to destination illuminant. This process is called color grading and it involves several steps including chromatic adaptation. \n\n![ColorChecker chart:=:40:=:Macbeth ColorChecker chart](chromatic-adaptation/color-checker.jpg)\n\nAs the color checker chart contains uniform color ranges, we can use this chart to estimate the illuminant of an image. We can detect ColorChecker chart in an image using OpenCV using OpenCV-Contrib module **mcc** (Macbeth ColorChecker).\n\n```python\ndef get_colorchecker_coord(img):\n    # initialize CCDetector object\n    checker_detector = cv2.mcc.CCheckerDetector_create()\n    # detect classic Macbeth 24 color grid chart\n    has_chart = checker_detector.process(img, cv2.mcc.MCC24, 1)\n    # if any chart present\n    if has_chart:\n        # ColorChecker chart coordinates\n        # order - (tl, tr, br, bl)\n        box = checker_detector.getListColorChecker()[0].getBox()\n        min_x = int(min(box[0][0], box[3][0]))\n        max_x = int(max(box[1][0], box[2][0]))\n        min_y = int(min(box[0][1], box[1][1]))\n        max_y = int(max(box[2][1], box[3][1]))\n        coord = [(min_x, min_y), (max_x, max_y)]\n        return [True, coord]\n    else:\n        return [False, []]\n```\n\nThe above function returns rectangle coordinates (top-left, bottom-right) for ColorChecker chart if present in an image.\n\nWe extract ColorChecker from an image and estimate illuminant for only that extracted color chart as it contains uniform color ranges that give a good estimation of illuminant than the whole image.\n\n```python\nsrc_white_point = np.array([1.0, 1.0, 1.0])\nhas_chart, coord = get_colorchecker_coord(img)\nif has_chart:\n    src_white_point = get_gray_world_illuminant(r_img[coord[0][1]: coord[1][1], coord[0][0]: coord[1][0]])\nelse:\n    src_white_point = get_gray_world_illuminant(r_img)\n```\n\n![Detect ColorChecker chart](chromatic-adaptation/detec-colorchecker-chart.jpg)\n\nChromatic adaptation of the above image with illuminant obtained from cropped ColorChecker chart is\n\n![Chromatic adptation ColorChecker Batman](chromatic-adaptation/chromatic-adaptation-batman-comparison.jpg)\n\nSome regions and color ranges of transformed images of **Img 1** and **Img 2** are close to each other because we have applied the same destination illuminant for both images and this gives the conclusion that chromatic adaptation works to transform images from one illuminant to another.\n\n---\n\nWe can improve transformation further with better illumination estimation models (both uniform and non-uniform) and compare various chromatic adaptation transform models.\n\n### References\n\n- https://www.cell.com/current-biology/pdf/S0960-9822(07)01839-8.pdf\n- http://www.marcelpatek.com/color.html\n- http://www.brucelindbloom.com/index.html?Eqn_ChromAdapt.html\n- https://web.stanford.edu/~sujason/ColorBalancing/adaptation.html\n- https://in.mathworks.com/help/images/color.html\n- https://in.mathworks.com/matlabcentral/fileexchange/66682-chromadapt-adjust-color-balance-of-rgb-image-with-chromatic"},{"metadata":{"title":"Whiteboard Image Enhancement using OpenCV","description":"Enhance whiteboard images taken from mobile using OpenCV.","imgName":"whiteboard-enhance/whiteboard-image-enhancement.jpg","date":"Oct 19, 2021","tags":["image-processing","opencv"],"keywords":["whiteboard","whiteboard-enhance","image-enhance","image-processing","opencv","python","difference-of-guassian","dog","contrast-stretch","color-balance"],"id":"whiteboard-image-enhancement-opencv-python"},"content":"\n![Whiteboard image enhancement in Python](whiteboard-enhance/whiteboard-image-enhancement.jpg)\n\n# Whiteboard image enhancement using OpenCV\n\nWhiteboard images generally contain less contrast and low brightness as they would be captured in mobile under normal room light conditions. Enhancing whiteboard images makes text readable and gives an image with high contrast and brightness. \n\nWe will apply different image-processing techniques to enhance whiteboard images using OpenCV in Python. From this [whiteboard-cleaner](https://gist.github.com/lelandbatey/8677901) gist that enhances whiteboard images using [ImageMagick](https://imagemagick.org/), we will implement those ImageMagick methods in Python.\n\nIn that script, the following ImageMagick functions were used to enhance whiteboard images\n\n```shell\n-morphology Convolve DoG:15,100,0 -negate -normalize -blur 0x1 -channel RBG -level 60%,91%,0.1\n``` \nAbove command applies image enhancing functions in order \n- **-morphology Convolve DoG:15, 100, 0**: Difference of Gaussian (DoG) with kernel_radius=15, sigma1=100, and sigma2=0\n- **-negate**: Negative of image\n- **-normalize**: Contrast stretch image with black=0.15% and white=0.05%\n- **-blur 0x1**: Gaussian blur with sigma=1\n- **-level 60%,91%,0.1: Stretch image with black=60% and white=91%, and Gamma correction by gamma=0.1\n\nAs I found some difficulty for exactly converting the ImageMagick C code to Python, I have changed the order and parameters that would give close results.\n\n---\n\nWe will apply series of image-processing methods and effects to enhance whiteboard images in the following order\n- Difference of Gaussian (DoG)\n- Negative effect\n- Contrast Stretching\n- Gaussian blur\n- Gamma correction\n- Color balance\n\nYou can find the full code in my Github repository [whiteboard-image-enhance](https://github.com/santhalakshminarayana/whiteboard-image-enhance)\n\n### Import packages and read image\n\n```python\nimport cv2\nimport numpy as np\n\nimg = cv2.imread('input.jpg')\n```\n\n![Whiteboard image input:=:70:=:Input Whiteboard image](whiteboard-enhance/whiteboard-image.jpg)\n\n### Difference of Gaussian (DoG)\n\n[Difference of Gaussians (DoG)](https://en.wikipedia.org/wiki/Difference_of_Gaussians) is the difference of two Gaussian kernel convoluted images. DoG image is obtained by subtracting two Gaussian blurred images with different kernel radius and variance.\n\nNormally $I_{dog}$ (DoG of image) is calculated by subtracting $I_{g1}$ and $I_{g2}$ which are convoluted images with two different Gaussian kernels. But ImageMagick applies convolution after subtracting and scaling two gaussian kernels.\n\nSo, we will first subtract two different Gaussian kernels, scale and normalize the dog-kernel to the zero-summing kernel (sum of all elements ~ 0.0)  and then apply convolution.\n\n```python\ndef normalize_kernel(kernel, k_width, k_height, scaling_factor = 1.0):\n    '''Zero-summing normalize kernel'''\n    \n    K_EPS = 1.0e-12\n    # positive and negative sum of kernel values\n    pos_range, neg_range = 0, 0\n    for i in range(k_width * k_height):\n        if abs(kernel[i]) < K_EPS:\n            kernel[i] = 0.0\n        if kernel[i] < 0:\n            neg_range += kernel[i]\n        else:\n            pos_range += kernel[i]\n    \n    # scaling factor for positive and negative range\n    pos_scale, neg_scale = pos_range, -neg_range\n    if abs(pos_range) >= K_EPS:\n        pos_scale = pos_range\n    else:\n        pos_sacle = 1.0\n    if abs(neg_range) >= K_EPS:\n        neg_scale = 1.0\n    else:\n        neg_scale = -neg_range\n        \n    pos_scale = scaling_factor / pos_scale\n    neg_scale = scaling_factor / neg_scale\n    \n    # scale kernel values for zero-summing kernel\n    for i in range(k_width * k_height):\n        if (not np.nan == kernel[i]):\n            kernel[i] *= pos_scale if kernel[i] >= 0 else neg_scale\n            \n    return kernel\n\ndef dog(img, k_size, sigma_1, sigma_2):\n    '''Difference of Gaussian by subtracting kernel 1 and kernel 2'''\n    \n    k_width = k_height = k_size\n    x = y = (k_width - 1) // 2\n    kernel = np.zeros(k_width * k_height)\n    \n    # first gaussian kernal\n    if sigma_1 > 0:\n        co_1 = 1 / (2 * sigma_1 * sigma_1)\n        co_2 = 1 / (2 * np.pi * sigma_1 * sigma_1)\n        i = 0\n        for v in range(-y, y + 1):\n            for u in range(-x, x + 1):\n                kernel[i] = np.exp(-(u*u + v*v) * co_1) * co_2\n                i += 1\n    # unity kernel\n    else:\n        kernel[x + y * k_width] = 1.0\n    \n    # subtract second gaussian from kernel\n    if sigma_2 > 0:\n        co_1 = 1 / (2 * sigma_2 * sigma_2)\n        co_2 = 1 / (2 * np.pi * sigma_2 * sigma_2)\n        i = 0\n        for v in range(-y, y + 1):\n            for u in range(-x, x + 1):\n                kernel[i] -= np.exp(-(u*u + v*v) * co_1) * co_2\n                i += 1\n    # unity kernel\n    else:\n        kernel[x + y * k_width] -= 1.0\n    \n    # zero-normalize scling kernel with scaling factor 1.0\n    norm_kernel = normalize_kernel(kernel, k_width, k_height, scaling_factor = 1.0)\n    \n    # apply filter with norm_kernel\n    return cv2.filter2D(img, -1, norm_kernel.reshape(k_width, k_height))\n``` \n\nGet Difference of Gaussian (DoG) for image by calling *dog()* function with **radius = 15, sigma_1 = 100, sigma_2 = 0**. Here **radius = 15** for both kernels, for first kernel, **sigma = 100**, and for second kernel, **sigma = 0**. Kernel with **sigma = 0** creates unity kernel means convolution with this kernel gives same image. \n\n```python\ndog_img = dog(img, 15, 100, 0)\n```\n\nAfter applying DoG, the resultant image looks like\n\n![Difference of Gaussian (DoG) Image:=:70:=:Difference of Gaussian (DoG) image](whiteboard-enhance/difference-of-gaussian.jpg)\n\n---\n\n### Negative Image\n\nFor $I_{dog}$, get a negative image which is just an inversion of colors (255 - image).\n\n```python\ndef negate(img):\n    '''Negative of image'''\n    \n    return cv2.bitwise_not(img)\n```\n\n```python\nnegative_img = negate(dog_img)\n```\n\nThe result of the inversion image is\n![Negative image:=:70:=:Negative image](whiteboard-enhance/negative.jpg)\n\nImage content is not much visible as we inverted an image whose most of the pixels are black. So, to improve the contrast, we apply contrast-stretch enhancement for the negative image.\n\n---\n\n### Contrast Stretching\n\nContrast stretching of an image is the same as histogram equalization but we cap some percentage of pixel values to black (0) and white (255).\n\n```python\ndef get_black_white_indices(hist, tot_count, black_count, white_count):\n    '''Blacking and Whiting out indices same as color balance'''\n\n    black_ind = 0\n    white_ind = 255\n    co = 0\n    for i in range(len(hist)):\n        co += hist[i]\n        if co > black_count:\n            black_ind = i\n            break\n            \n    co = 0\n    for i in range(len(hist) - 1, -1, -1):\n        co += hist[i]\n        if co > (tot_count - white_count):\n            white_ind = i\n            break\n    \n    return [black_ind, white_ind]\n\ndef contrast_stretch(img, black_point, white_point):\n    '''Contrast stretch image with black and white cap'''\n    \n    tot_count = img.shape[0] * img.shape[1]\n    black_count = tot_count * black_point / 100\n    white_count= tot_count * white_point / 100\n    ch_hists = []\n    # calculate histogram for each channel\n    for ch in cv2.split(img):\n        ch_hists.append(cv2.calcHist([ch], [0], None, [256], (0, 256)).flatten().tolist())\n    \n    # get black and white percentage indices\n    black_white_indices = []\n    for hist in ch_hists:\n        black_white_indices.append(get_black_white_indices(hist, tot_count, black_count, white_count))\n        \n    stretch_map = np.zeros((3, 256), dtype = 'uint8')\n    \n    # stretch histogram \n    for curr_ch in range(len(black_white_indices)):\n        black_ind, white_ind = black_white_indices[curr_ch]\n        for i in range(stretch_map.shape[1]):\n            if i < black_ind:\n                stretch_map[curr_ch][i] = 0\n            else:\n                if i > white_ind:\n                    stretch_map[curr_ch][i] = 255\n                else:\n                    if (white_ind - black_ind) > 0:\n                        stretch_map[curr_ch][i] = round((i - black_ind) / (white_ind - black_ind)) * 255\n                    else:\n                        stretch_map[curr_ch][i] = 0\n    \n    # stretch image\n    ch_stretch = []\n    for i, ch in enumerate(cv2.split(img)):\n        ch_stretch.append(cv2.LUT(ch, stretch_map[i]))\n        \n    return cv2.merge(ch_stretch)\n```\n\nFor each image channel, calculate cummulative histogram sum, and then cap pixels based on **black_point = 2** and **white_point = 99.5** percentage.\n\n```python\ncontrast_stretch_img = contrast_stretch(negative_img, 2, 99.5)\n``` \n\nNegative image after contrast stretching is\n\n![Contrast stretch image:=:70:=:Contrast strech image](whiteboard-enhance/contrast-stretch.jpg)\n\n---\n\n### Gaussin Blur & Gamma Correction\n\nContrast stretching image contains noise, so blur the image with Gaussian kernel. As Gaussian distribution kernel can be linearly separable, we apply convolution with the same 1D-kernel along the x-axis and y-axis for performance (negligible for small kernels and low-res images).\n\n```python\ndef fast_gaussian_blur(img, ksize, sigma):\n    '''Gussian blur using linear separable property of Gaussian distribution'''\n    \n    kernel_1d = cv2.getGaussianKernel(ksize, sigma)\n    return cv2.sepFilter2D(img, -1, kernel_1d, kernel_1d)\n\ndef gamma(img, gamma_value):\n    '''Gamma correction of image'''\n    \n    i_gamma = 1 / gamma_value\n    lut = np.array([((i / 255) ** i_gamma) * 255 for i in np.arange(0, 256)], dtype = 'uint8')\n    return cv2.LUT(img, lut)\n```\n\nApply Gaussian blur with **kernel_size = 3** and **sigma = 1**.\n\n```python\nblur_img = fast_gaussian_blur(contrast_stretch_img, 3, 1)\n```\n\nBlurred image after noise suppression is\n\n![Gaussian blur image:=:70:=:Blurred image](whiteboard-enhance/gaussian-blur.jpg)\n\nNow apply Gamma correction to enhance the blurred image with **gamma_value = 1.1**.\n\n```python\ngamma_img = gamma(blur_img, 1.1)\n```\n\nBlurred image Gamma corrected looks like\n\n![Gamma correction:=:70:=:Gamma corrected image](whiteboard-enhance/gamma-correction.jpg)\n\n---\n\n### Color Balance\n\nColor balance of an image is same as contrast-stretching method above but they are different in implementation. Above contrast-stretching is an implementation based on [ImageMagick-ContrastStretchImage()](https://imagemagick.org/api/MagickCore/enhance_8c.html), and [color balance](https://gist.github.com/DavidYKay/9dad6c4ab0d8d7dbf3dc) is based on [Simplest Color Balance](https://www.ipol.im/pub/art/2011/llmps-scb/article.pdf).\n\n```python\ndef color_balance(img, low_per, high_per):\n    '''Contrast stretch image by histogram equilization with black and white cap'''\n    \n    tot_pix = img.shape[1] * img.shape[0]\n    # no.of pixels to black-out and white-out\n    low_count = tot_pix * low_per / 100\n    high_count = tot_pix * (100 - high_per) / 100\n    \n    cs_img = []\n    # for each channel, apply contrast-stretch\n    for ch in cv2.split(img):\n        # cummulative histogram sum of channel\n        cum_hist_sum = np.cumsum(cv2.calcHist([ch], [0], None, [256], (0, 256)))\n\n        # find indices for blacking and whiting out pixels\n        li, hi = np.searchsorted(cum_hist_sum, (low_count, high_count))\n        if (li == hi):\n            cs_img.append(ch)\n            continue\n        # lut with min-max normalization for [0-255] bins\n        lut = np.array([0 if i < li \n                        else (255 if i > hi else round((i - li) / (hi - li) * 255)) \n                        for i in np.arange(0, 256)], dtype = 'uint8')\n        # constrast-stretch channel\n        cs_ch = cv2.LUT(ch, lut)\n        cs_img.append(cs_ch)\n        \n    return cv2.merge(cs_img)\n```\n\nEnhance image by passing Gamma corrected image to **color_balance()** with parameters **low_per = 2** and **high_per = 1**.\n\n```python\ncolor_balanced_img = color_balance(gamma_img, 2, 1)\n```\n\nThe final enhanced whiteboard image is\n![Whiteboard image enhance:=:70:=:Whiteboard image enhanced](whiteboard-enhance/whiteboard-image-enhanced.jpg)\n\nYou can find out full code at my Github repository file [whiteboard_image_enhance.py](https://github.com/santhalakshminarayana/whiteboard-image-enhance/blob/main/whiteboard_image_enhance.py)\n\n---\n\n## Results\n\n![img_2:=:100](whiteboard-enhance/img_2.jpg)\n\n![img_3:=:100](whiteboard-enhance/img_3.jpg)\n\n![img_4:=:100](whiteboard-enhance/img_4.jpg)"},{"metadata":{"title":"Color Theory","description":"Different color properties, color models, and color space that are useful in image processing, graphic design, and game design.","imgName":"color-theory/color-theory.jpg","date":"Sep 14, 2021","tags":["color-science"],"keywords":["color","color-theory","color-models","color-spaces","graphic-design","image-processing","photography"],"id":"color-theory"},"content":"\n![Color Properties, Models and Spaces](color-theory/color-theory.jpg)\n\n# Color Theory\n\n> Before reading color theory, it is recommended to know about color science that explains how color is defined, represented, and quantified in my previous article about [color science](https://santhalakshminarayana.github.io/blog/color-science)\n\nThe Color theory deals with multiple color terminology, models, and schemes that we use in our daily day-to-day life. The color theory describes relationships between different colors and color schemes. It acts like guidelines for better marketing and design of a product. Color theory is a set of rules that combines art and science. The color theory defines the logical structure of color to create color palettes, color schemes, aesthetically pleasing color designs, and color psychology.\n\nFrom an e-commerce website to an offline store, still photography to a motion picture, interior design to an art gallery, we can see the usage of color theory to attract, please, or astonish the customers.\n\nIn fields like image processing, digital photography, graphic design, and game design, color plays a vital role and one must understand basic color theory concepts like color properties, color models, and color spaces before learning other concepts. \n\n\n## Color Wheel\n\nA color wheel is a set of colors distributed over a circular disc with some rules that signify the meaning of colors. A color wheel can have numerous colors, and generally, a color wheel is a combination of 12 basic colors from primary, secondary, and teritary colors.\n\nHue, saturation and lightness are three elements used to define a color.\n\n## Hue\n\nHue is the dominant color among similar colors in a range of the visible spectrum. Hues are the basic colors to which adding white and black produce multiple colors. Hues are generally classified into major colors we see in nature. They are Red, Yellow, Green, Blue, Violet, and Orange. \n\n**Primary colors** - Primary hues are colors that cannot be produced by mixing other hues. In painting world **red**, **yellow**, and **blue** are primary hues. In digital world **red**, **green**, and **blue** are primary colors.\n\n**Secondary colors** - Mixing two primary hues creates secondary hues:\n- **Green** - (Blue + Yellow)\n- **Orange** - (Yellow + Red)\n- **Purple** - (Red + Blue)\n\n**Tertiary colors** - In the color wheel, tertiary hues are mixtures of adjacent primary and secondary hues. Thus, six territory hues are produced.\n- **Chartreuse** - (Yellow + Green)\n- **Teal** - (Green + Blue)\n- **Violet** - (Blue + Purple)\n- **Magenta** - (Purple + Red)\n- **Vermillion** - (Red + Orange)\n- **Amber** - (Orange + Yellow)\n\n![Color Wheel - Primary, Secondary, and Tertiary Hues:=:50:=:Color wheel](color-theory/color-wheel.jpg)\n\n## Saturation/Chroma\n\nSaturation/Chroma is the purity of a hue. It defines the color intensity. A pure color is 100% saturated or fully saturated. Mixing gray (white + black) color to a pure hue decreases the intensity and finally reaches a 0% saturation level. A color can be desaturated by mixing with its complementary color. A hue at 0% saturation is a gray color. Saturation defines a range of color intensities from pure color (100%) to gray (0%). \n\n![Saturation:=:70](color-theory/saturation.jpg)\n\n### Tint\n\nWhen white color is mixed with a color, the resultant is the Tint of that color. Adding white color makes color lighter than the original. The amount of white added defines the tint of color.\n\n![Tints:=:70](color-theory/tints.jpg)\n\n### Shade\n\nA shade of a color is the blackness of the color after being mixed with black color. The shade of a color is darker than the original color.\n\n![Shades:=:70](color-theory/shades.jpg)\n\n### Tone \n\nA Tone is mixing both white and black colors to a color. The resultant color is grayer than the original.\n\n![Tones:=:70](color-theory/tones.jpg)\n\nAlthough Chroma and Saturation speak the same, Chroma is an absolute term that defines color value a range from gray (0%) to pure hue (100%), and saturation defines the brilliance of a color relative to gray.\n\n## Lightness/Luminance\n\nLightness/Luminance define how light (100%) or dark (0%) a color is. All pure hues have a lightness value of 50%. Lightness is measured relative to the brightness of white color. In color perception, lightness tells how much light is reflected from a surface. \n\n![Lightness:=:70](color-theory/lightness.jpg)\n\n---\n\n## Color properties and color terms\n\n### Chromatic & Achromatic colors\n\nAchromatic colors are colors that have lightness but no hue or saturation. They are black, white and gray. Mixing complementary colors produces achromatic colors.\n\nChromatic colors are the ones that have any amount of hue and saturation. The presence of saturation defines chromatic colors. All other colors except achromatic colors are chromatic colors.\n\n### Chromatic value/Chromatic intensity/Chromaticity\n\nChromatic value/intensity is the measure of how light or dark a color is. Depending on how light or dark a hue is, Tints and Shades of color are created. Chromaticity is similar to saturation as they both speak about how much color is chromatic (a hue with some saturation). Chromaticity is also defined as color independent of lightness (only hue and saturation).\n\n\n### Luminance\n\nLuminance is the intensity of light emitted, reflected, or passes through per unit area in a given direction.\n\n### Brightness\n\nBrightness is a relative term that describes how much light is shining from something. It is the average lightness of an object. It is not a color term but a perception of our eyes created by color's lightness. It is not a quantitative term but can be scaled (%). It is quite similar to luminance in human color vision. [Luminance](http://www.workwithcolor.com/color-luminance-2233.htm) is the brightness of a color perceived by our eyes. A high-intensity color looks more bright. The green color looks more bright than the blue color. A hue with more saturation is brighter than a desaturated hue. A color with the same luminance appears in different brightness depending on the surrounding colors.\n\n### Contrast\n\nContrast is the difference between the luminance of two or more colors placed adjacent or overlapped. High contrast colors appear more bright than low contrast. Generally, contrast is used in the context of foreground and background colors. When equal luminance colors are placed on foreground and background, they look similar and there is no difference observed. Depending on the position of colors in the color wheel, contrast levels vary. Colors next to each other have low contrast and opposite colors have high contrast.\n\n### Color contrast ratio\n\nColor contrast ratio is the quantitative term to define the contrast between two colors. They are measured based on the relative luminance of different colors. The [Web Content Accessibility Guidelines (WCGA)](https://www.w3.org/WAI/WCAG22/Understanding/contrast-minimum.html) published guidelines for calculating contrast ratio of color and these are considered as standard rules in web design.\n\n### Luma\n\nLuma describes the presence of achromatic signal (white, gray, and black) intensity in a color. Luma describes how bright a color is. The difference between luminance and luma is, luminance is derived from linear RGB values, whereas luma is derived from non-linear (gamma-corrected) RGB values. Luminance is based on standard [relative luminance ratios of RGB](https://santhalakshminarayana.github.io/blog/color-science#relative-luminance), and luma is based on relative gamma-corrected RGB ratios.\n\n### Metamerism (Color metameres)\n\nMetamerism occurs when two colors look the same under one lighting condition but, different when light source/conditions change. This usually happens when we buy clothes in a store like a shirt appears light blue in the store but when we brought it in sunlight the shirt looks pale blue. \n\n### Color Temperature\n\nThe color temperature of the light source is the temperature of black-body radiation when black-body is heated at a constant temperature. As the black body observes all spectrum wavelengths, when heated up at a constant temperature, it emits certain wavelengths which are perceived as color. Color temperature is measured in Kelvin (&degK). At different color temperatures, the body is seen as different colors. \n\n![Color Temperature:=:60:=:Colors at different temperatures emitted by a black-body](color-theory/color-temperature.jpg)\n\nThe lower the temperature, the lower the color appears warm, and the higher the temperature, the cooler the color appears.\n\n### Color Rendering Index (CRI)\n\nColor Rendering Index (CRI) is a measurement of how light affects the appearance of a color. It defines how accurately colors can be distinguished under a light source. Light sources with different color temperatures illuminate objects as different colors and sometimes we cannot distinguish object colors in extremely warm or cool light sources. CRI indicates how well a light source can reproduce colors with the same temperature for natural light such as the sun. It is a quantitative term measured on a scale of 0-100. A score of 90 or more is considered excellent and less than 80 is considered poor.\n\nColor temperature and Color Rendering Index (CRI) are two vital terms that affect the selection of light sources and conditions. Art galleries, museums, photographers, and product displays stores choose light sources based on these terms. \n\n---\n\n## Color Harmony or Color schemes\n\nColor harmony is the theory of selecting/combining colors to create a visually pleasing color scheme. Color harmony creates aesthetically rich color combinations that maintain harmony and engages users with the product. The color wheel is the basic logical structure for creating color schemes.\n\n### Monochromatic\n\nThe monochromatic color scheme contains single color with variations of tints, tones, and shades.\n\n![Monochromatic Harmony:=:25:=:Monochromatic Harmony](color-theory/monochromatic.jpg)\n\n### Analogous\n\nAnalogous color schemes are created by grouping the main color with adjacent colors to it in the color wheel.\n\n![Analogous Harmony:=:25:=:Analogous Harmony](color-theory/analogous.jpg)\n\n### Complementary\n\nComplementary colors are two colors selected in a way that colors are opposite to each other in the color wheel.\n\n![Complementary Harmony:=:25:=:Complementary Harmony](color-theory/complementary.jpg)\n\n### Split Complementary\n\nIn the split complementary scheme, the main color is selected and the other two colors are adjacent colors to the complementary color of the main color.\n\n![Split Complementary Harmony:=:25:=:Split Complementary Harmony](color-theory/split-complementary.jpg)\n\n### Triad\n\nTriad is a group of three colors that are equally distant from each other in the color wheel and form a triangle.\n\n![Triad Harmony:=:25:=:Triad Harmony](color-theory/triad.jpg)\n\n### Square\n\nThe square color scheme has four colors that are the same distance to each other forming a square or rhombus in the color. \n\n![Square Harmony:=:25:=:Square Harmony](color-theory/square.jpg)\n\nOther harmonies include diad, diad complementary, rectangle, and polygon schemes.\n\n\n## Color models\n\nColor models are the organization of colors and their mixing (additive or subtractive) based on human color perception. A color model defines color and its properties in a mathematical way.\n\n### RGB\n\nIn the RGB color model, Red, Green, and Blue are three primary colors that are mixed to produce all other colors by [additive color mixing](https://santhalakshminarayana.github.io/blog/color-science#additve-subtractive-color-mixing). Display systems and digital photography stores color values based on RGB model.\n\nBased on the depth (no. of bits allocated to store) of a color, RGB values are scaled in a certain range. For an 8-bit system, the range is 0-255, and when all colors are mixed at minimum level then it designates black color and at maximum level designates white color. If RGB colors are mapped to 3-dimensional space with unit vectors X, Y, and Z-axis as R, G, and B colors, then the vector space forms a cube with all possible colors in it formed by the combination of RGB at different values.\n\n![RGB color model:=:35](color-theory/rgb-cube.jpeg)\n\nWith the RGB model, one cannot easily identify important color terms like lightness, contrast, brightness, tones, tint, and shades.\n\n### HSV (HSB)\n\nHue, Saturation, and Value (or Brightness) (HSV or HSB) is a cylindrical color model that is based on hue, saturation, and brightness described above. \n\nHue is arranged with all hues taking up a certain range in a 0-360 degrees circle. Starting red at 0&deg, green at 120&deg, blue at 240&deg, and again wrapping back to red at 360&deg.\n\nSaturation has a range from 0%-100%, starting from 0% (gray) at the center of the base to 100% (pure color/hue) at the circumference. Saturation controls tints and shades\n\nValue/Brightness also has a range of 0%-100%, with 0 (black) at the bottom of the base to 100% (no black) at the top.\n\n![HSV:=:35](color-theory/hsv.jpeg)\n\nIf brightness is at 0% then the color is black irrespective of hue and saturation. But for white color, the brightness value is 100% and saturation is kept at 0% while hue can be anything.\n\n### HSL\n\nHue, Saturation, and Lightness (HSL) is a bi-cone (double) model while H and S are the same as HSB. \n\n![HSL Cone:=:35](color-theory/hsl-cone.jpeg)\n\nLightness has a range from 0%-100%, starting from 0% (black) at bottom of the cone to 100%(white) at top of the cone. All pure hues have a lightness value of 50%.\n\n![HSL:=:35](color-theory/hsl.jpeg)\n\nColor is white if lightness is 100% irrespective of hue and saturation. Same for black color with lightness at 0% irrespective of hue and saturation values. \n\n## Color spaces\n\nA color space is based on the color model that maps colors to a set of colors like sRGB and Adobe RGB and is reproduced by display systems.\n\n### L\\*a\\*b* (CIELAB) color space \n\nL\\*a\\*b* color space is a device-independent color space in which color is expressed in three components:\n- **L***- Lightness\n- **a***- Green-Red\n- **b***- Blue-Yellow\n\nIt was defined by CIE and also called CIELAB (Lab without * is color space defined by Hunter Lab).\n\nIn L\\*a\\*b\\* color space, L indicates lightness, and a\\* and b\\* indicates chromaticity coordinates. Unlike RGB and HSV, L\\*a\\*b* represents colors in the sphere where L\\*, a\\*, and b\\* are orthogonal axis to each other. CIELAB is a perceptually uniform color space i.e. a standard color system that reflects the color representation close to human vision color perception. \n\n![Lab color space:=:35:=:Lab sphere$$$https://sensing.konicaminolta.asia/what-is-cie-1976-lab-color-space/](color-theory/3d-lab.jpg)\n\nL\\*a\\*b* is based on [opponent process theory](https://santhalakshminarayana.github.io/blog/color-science#opponent-process-theory) where red-green and blue-yellow form opponent pairs. \n\nL\\*-axis is a positive axis with coordinates black at 0 to white at 100. \na\\*-axis is present along horizontal from left to right in the range of -128 to 127, +a\\* is the red axis, and -a\\* is the green axis.\nb\\*-axis runs along top to down in the range of -128 to 127, +b\\* axis is the yellow axis, and -b\\* axis is the blue axis.\n\n![Lab color space:=:40:=:Lab color space$$$https://www.xrite.com/blog/lab-color-space](color-theory/lab-color-space.jpg)\n\nAt the center, colors are achromatic colors, and saturation increases moving towards the circumference.\n\n### YUV and YCbCr\n\n[YUV](https://en.wikipedia.org/wiki/YUV) and [YCbCr](https://en.wikipedia.org/wiki/YCbCr) are a family of color spaces used to encode color data. In both models, the Y component refers to luminance but practically Y'UV and Y'CbCr are used. Y' component is luma which is scaled in the range of 0-100. The other two components are chrominance components derived by the difference of Y' on blue and red values.\n\nYUV, historically used for transmitting video data for analog devices. In the olden days, as there was a need to support both black and white display and color displays, a conversion has be to applied for RGB data to transmit signals without disturbing black-and-white channels. As the black-and-white image is the same as the luminance channel, YUV was developed to pass chrominance channels along with luminance. Later, YCbCr was developed to store, compress and encode digital photographs. YUV is for analog TVs and YCbCr is for digital TVs. \n\nUsing [chroma subsampling](https://www.matrox.com/en/video/media/guides-articles/introduction-color-spaces-video), image data can be transmitted and stored at a low-bit rate for chrominance channels UV and CbCr, because human eyes are tolerant for perceptually equal colors. This made transmitting or storing image data in [Y'UV or Y'CbCr](https://docs.microsoft.com/en-us/windows/win32/medfound/about-yuv-video) requires less space: a high bit-rate luma channel and low bit-rate chrominance channels.\n\nConversion from **RGB** to **Y'UV** is computed as follows:\n$$\nY' = W_{R}R + W_{G}G + W_{B}B\n$$\n$$\nY' = 0.299R + 0.587G + 0.114B\n$$\n$$\nU = U_{max}\\frac{B - Y'}{1 - W_B}\n$$\n$$\nV = V_{max}\\frac{R - Y'}{1 - W_R}\n$$\n\nWhere $W_R$, $W_G$, and $W_B$ are relative ratios of non-linear gamma-corrected RGB values. $U_{max}$ and $V_{max}$ are maximum values of the numerical range selected. For PAL and NTSC, these values were $U_{max} = 0.436$ and $V_{max} = 0.615$.\n\nSimilarly, **RGB** to **Y'CbCr** is computed as\n$$\nY' = K_{R}R + K_{G}G + K_{B}B\n$$\n$$\nY' = 0.299R + 0.587G + 0.114B\n$$\n$$\nC_b = \\frac{1}{2}\\frac{B - Y'}{1 - K_B}\n$$\n$$\nC_r = \\frac{1}{2}\\frac{R - Y'}{1 - K_R}\n$$\n\nWhere $K_R$, $K_G$, and $K_B$ are relative ratios of non-linear gamma-corrected RGB values and satisfies $K_R + K_G + K_R = 1$.\n\n---\n\n## Device-dependent and device-independent color spaces\n\n**Device-dependent** color models mean they depend on the display system subset of colors or reference color space. This model explains the physical device output rather than human color vision. Coordinates used to display colors in device-dependent models change when the display system changes its light source. RGB, CMY, HSV, and HSL are device-dependent color models.\n\n**Device-independent** color spaces are universal references and coordinates used to specify colors will produce the same color in all conditions because they define color output based on human color vision. These are used to convert device-dependent color spaces across display devices. CIELAB, CIELUV, YCbCr, and YUV are device-independent color spaces."},{"metadata":{"title":"Color Science","description":"Understanding the concept of Color from human eye's perception to digital world representation.","imgName":"color-science/color-science.jpg","date":"Aug 28, 2021","tags":["color-science"],"keywords":["color-matching","color","chromaticity-diagram","cie","graphic-design"],"id":"color-science"},"content":"\n![Color Science](color-science/color-science.jpg)\n\n# Color Science\n\nColor is an important element that exists in nature. Everything we see or feel through the eyes is all about colors. It is necessary to understand the concept of color in domains like image processing, film making, and digital photography, where color is the primary element.\n\nFrom Space exploration to Film making, Air force to Archeology, color science is applied everywhere that uses colors to gather data. For example Hubble telescope uses image processing techniques like **broad-band** and **narrow-band** filtering to color map planets, nebula, and galaxies based on the gases and their interactions like in \"The Pillars of Creation\".\n\n![Pillars of Creation:=:40:=:The Pillars of Creation (NASA)$$$https://www.nasa.gov/image-feature/the-pillars-of-creation](color-science/pillars-of-creation.jpg)\n\nIn this article, we discuss color, the evolution of color understanding, and numerical representation of color in the digital world.\n\n---\n\n## Color and Human Vision\n\nWhen we talk about colors, colors are represented in a way human eyes perceive. Because different species see things in different colors, and they can also see what humans cannot see like Snakes and Bats can detect infrared radiation which humans couldn't. So we generally restrict colors to human vision.\n\nColor is an illusion that our brain creates when a light beam reflects off an object/emits from an object and reaches our eyes. When light strikes the surface of an object, some light will be absorbed and some will be reflected. That reflected light with different wavelengths reaches our eyes and we perceive them as different colors.\n\nIssac Newton described the color as a quality of light. And the light which is an electromagnetic wave is classified into different segments with certain frequencies and wavelength ranges. The visible light spectrum is the segment of the electromagnetic spectrum that human eyes can only perceive. The visible light wavelength range is ~380 to ~780 nanometers. By deflection of light through a prism, Newton assigned different colors to different wavelengths in the visible spectrum which we generally see when a rainbow appears (VIBGYOR).\n\n![Visible Spectrum:=:55:=:Visible Light Spectrum$$$https://en.wikipedia.org/wiki/Electromagnetic_radiation](color-science/visible-spectrum.jpg)\n\nThe retina in our eye is responsible for vision. The retina contains photoreceptor cells that convert light signals to neural signals and send those signals back to the brain through nerves. And then, the brain intercepts these signals to colors. Rods and Cones in the retina are two types of photoreceptors that are responsible for our vision in dark and bright conditions. Rods work at a low level of light and our vision is in grayscale. Rods don't provide any color vision. At night as there is a low level of light we can see the objects in combinations of white and black (grayscale). Cones work in bright light and provides color vision. \n\n![Retina:=:70:=:Light capture by Rods and Cones in Retina$$$https://www.xrite.com/blog/color-perception-part-3](color-science/retina-rods-cones.jpg)\n\n### Triochromatic theory\n\nIn the 1800s, Thomas Young stated that the human eye consists of three different types of color receptors more likely red, green, and blue, and mixing these colors create other colors.\n\nThere are three types of cones called short (S), medium (M), and long (L) which are sensitive to different wavelength ranges of spectral distribution and detect Blue, Green, and Red respectively.\n\n![Normalized Cone Responsivity:=:45:=:Normalized Responsivity$$$https://en.wikipedia.org/wiki/Cone_cell^^^ of S, M and L cones](color-science/normalized-cone-responsivity.jpg)\n\nThese S, M, and L cones detect Blue, Green, and Red colors respectively and other colors are perceived by overlapping of different stimulations of these cones. The brain then integrates these cone signals and detects millions of colors. For example, Yellow color is a proportion of Green and Red cones and no or less effect of Blue cone. These three colors RGB (Red, Green, Blue) are primary colors and any color can be produced with the combination of these primitive colors.\n\n![Retinal Response:=:40:=:Retinal Response$$$https://askabiologist.asu.edu/rods-and-cones^^^ of rods and cones](color-science/retinal-response.jpg)\n\nIf we mix all RGB colors at a high-intensity level we get White color, and if RGB colors with 0 intensity level produce Black Color.\n\n### Opponent process theory:=:opponent-process-theory\n\nAfter cones converting physical (light) signals to neural signals, these neural signals reach the brain through nerves. Here, cells changes behavior and responds in the opponent manner for colors. The photoreceptor cells are in inter-connection with each other cell and give positive or negative responses for incoming color signals. Some cells fire positive signals when seeing red color, and activate negative signals for green color. These opposite responses don't happen at the same time in a cell. The opponent-process theory states that color perception is controlled by three opponent color systems: red-green, blue-yellow, and white-black (according to recent studies, these pairs are blue-yellow, red-cyan, and green-magenta). These opponent colors don't perceive as together because cells can only fire one of the colors in a pair i.e. there is no \"bluish-yellow\" or \"greenish-red\".\n\n![Opponent Process:=:60:=:Opponent Process$$$https://en.wikipedia.org/wiki/Opponent_process](color-science/opponent-process-theory.jpg)\n\nThese trichromatic and opponent-process theories give an idea about how our brain receives and processes light signals into colors.\n\n## The Color of an object\n\nWhen a light beam hits the surface of an object, it absorbs some wavelengths and reflects a particular wavelength of light. An object looking Pink absorbs all wavelengths of light except some portion of Red and Blue. And our eyes receive those Red and Blue colors by cones and intercept as pink by stimulating the Red and Blue cones. Paints on walls are made to absorb all of the wavelengths except the color of their appearance. \n\n### Secondary colors\n\nIf we mix two primary colors at equal intensities and another one is being kept at a 0 level, we get secondary colors.\n- Cyan (Blue + Green)\n- Magenta (Red + Blue)\n- Yellow (Green + Red). \n\nThese Cyan (C), Magenta (M), and Yellow (Y) colors are called secondary colors (CMY) as they are derived from primary ones (RGB).\n\nC, M, and Y are also complementary colors to R, G, and B as synthesize of C, M and Y don't contain R, G, and B colors respectively. This means when an object is illuminated with RGB colors, the object absorbs at least one primary color and reflects the other two primary colors. An object looking Cyan would absorb Red but reflects Green and Blue (G + B = C). Mixing secondary colors produces RGB colors.\n- M + Y = R\n- Y + C = G\n- C + M = B\n\n### Additive and Subtractive color mixing:=:additve-subtractive-color-mixing\n\nThe object appears in different colors if the various amount of RGB light emitted from it. It appears black when no percentage of RGB is emitted and if all are emitted at the highest intensity, it appears as white. Thus adding different RGB percentages produce different colors. This process of synthesizing colors by emitting RGB colors from black (when no light is produced) is called **Additive** color model. We start from black and reach white. Display monitors and screens we see around are based on an Additive color model. They produce colors by varying RGB color intensities.\n\nWhat if an object instead of emitting it reflects certain wavelengths of light by absorbing other wavelengths. This is how we naturally see an object and its appearance. An object absorbs some light and reflects other visible spectrum wavelengths that are perceived as color by our eyes. If an object absorbs cyan color, then it reflects red. Because \n$$\n\\small{White - Cyan = (R + G + B) - (G + B) = R}\n$$\nif we subtract cyan from white it produces a red color. \n\n![Additive and Subtractive Colors:=:40](color-science/additive-subtractive-colors.jpeg)\n\nHere subtracting means mixing colors as an object absorbs colors and then reflects. Thus mixing CMY colors with a white color produces different colors. This process of synthesizing colors from adding CMY mixtures to white is called **Subtractive** color model. We start from white to black color. Printing and painting involve this color synthesis to generate different colors on white paper or canvas. As mixing of CMY at the highest intensity produces brown color, printers also use black (K) color to generate shades of the black, and the resultant color group is called as CMYK color model.\n\n---\n\n## Color matching\n\nColor matching is representing and reproducing any color wavelength using primary monochromatic wavelengths. Using different intensities of primary colors, the target color wavelength is produced.\n\n### Grassmann's laws of additive color mixture\n\nIn 1953, Grassmann recognized that any color can be matched with a linear combination of three primary colors. Grassmann's laws describe the relations between primary colors to match any color by additive color mixture. The following Grassmann's laws are fundamental for color mixing,\n\n- If two colors (X and Y) are the same, then mixing X and Y with the third color Z would still look like same. \n$$\n\\footnotesize{If \\space X = Y, \\space then \\space X + Z = Y + Z}\n$$\n\n- Any color C can be produced by a linear combination of three primary colors but no primary color is matched by a combination of the other two. \n$$\n\\footnotesize{C = xX + yY + zZ}\n$$\nwhere (x, y, z) are portions of primary colors (X, Y, Z) required to match color C.\n\n- Two colors C1 and C2, if mixed to form another color C3, then C3 can be matched by a linear combination of mixtures of primary colors that are used to produce C1 and color C3. \n$$\n\\footnotesize{C3 = C1 + C2 = (xX1 + yY1 + zZ1) + (xX2 + yY2 + zZ2)}\n$$\n\n- Colors that are produced by mixing primary colors have constant luminance. This is not true at various lighting conditions like in photopic (daylight) vision, objects appear in different colors, but in scotopic (night) vision, objects appear in grayscale.\n\n\n### Human tristimulus response\n\nIn the 1860s, James Maxwell stated that using RGB primary colors, all other colors can be generated but it is not possible to generate all colors only by addition and requires subtraction also to match certain colors. This is called the human tristimulus response. \n\n### 2&deg Standard Observer color-matching experiment\n\nIn the late 1920s, based on the works of Newton, Grassmann, and Maxwell, David Wright and John Guild independently conducted experiments to quantify the color reception ability of a normal human observer. They believed that human color receptors are located within the 2&deg arc of the fovea back from the retina, and asked standard observers or human volunteers to look through a hole that provides a 2&deg field of view. They asked volunteers to match the target color by adjusting combinations of red, blue, and green colors.\n\nAs not all colors could be matching using an additive color model of red, blue, and green, the target color is mixed with some portion of the primary color, and the other two primary colors are altered in portions to match the target colors.\n\nThe Commission International de l’Eclairage (CIE), based on Wright-Guild's 2&deg standard observer data, published RGB color matching functions to represent colors as a combination of three primary colors. This is also called **CIE standard 2&deg observer**.\n\n![2&deg and 10&deg Standard Observer:=:40:=:2&deg and 10&deg standard observer view$$$https://support.hunterlab.com/hc/en-us/articles/203420099-CIE-Standard-Observers-and-calculation-of-CIE-X-Y-Z-color-values-AN-1002b](color-science/standard-observer.jpg)\n\n### 10&deg Supplementary Standard Observer color-matching experiment\n\nIn the 1960s, researchers observed that cones present in the retina cover a larger field than the standard 2&deg view. Three researchers, Stiles, Burch, and Speranskaya again repeated color matching experiments with a 10&deg field view. They believed 10&deg color matching experiments would cover more spectral response than 2&deg. And it was right. In 1964, the CIE published 10&deg Standard Observer based on a 10&deg color-matching experiment. The 10&deg standard observer is recommended than 2&deg as it covers larger color representatives.\n\n## CIE 1924 $\\small{V(\\lambda)}$ Spectral Luminous Efficiency function\n\nHuman eyes perceive different wavelengths of the visible spectrum at different brightness levels for the same radiance energy. Sensitivity is zero at either end of the spectrum thus we receive 0 brightness and no color.\n\nThe luminous efficiency function describes the human eye's sensitivity for different wavelengths. The more sensitivity observed the more brightness the color is. Eyes are most sensitive at **555nm** at daylight (photopic) and **507nm** at night (scotopic). CIE $\\small{V(\\lambda)}$ luminosity curve tells the relative sensitivity of the human eye for different color wavelengths. The luminous efficiency function distinguishes the brightness level of two colors at equal luminous. We can derive relative brightness for different colors with $\\small{V(\\lambda)}$ function.\n\n![Luminous efficiency function:=:50:=:Photopic (black) and Scotopic (green) luminosity function$$$https://en.wikipedia.org/wiki/Luminous_efficiencG_function](color-science/luminosity-curve.jpg)\n\nFrom $\\small{V(\\lambda)}$ luminous efficiency function, we can observe that, for equal radiance energy, brightness order of RGB is **green>red>blue**. For two colors at **500nm** and **570nm** to look as equal brightness, the color at **500nm** should be more luminous than **570nm**. \n$\\small{V(\\lambda)}$ function is an approximation function and accurate in some cases (like color blind people).\n\n### Relative luminance of RGB primaries:=:relative-luminance\n\nThe above CIE RGB color matching functions are scaled in assumtion that all colors have same brightness. The $\\bar{r}$, $\\bar{g}$ and $\\bar{b}$ are normalized to have equal area under curve to yield $\\bar{r}(\\lambda) = \\bar{g}(\\lambda) = \\bar{b}(\\lambda) = 1$. The integrated area is assumed to be same that\n$$\n\\int \\bar{r}(\\lambda)d\\lambda = \\int \\bar{g}(\\lambda)d\\lambda = \\int \\bar{b}(\\lambda)d\\lambda = \\int V(\\lambda)d\\lambda\n$$\n\nSolving the above expression gives the relative luminanace ratios for **r : g : b = 1 : 4.5907 : 0.0601**. If we compare $V(\\lambda)$ luminous curve for **R = 700nm**, **G = 546.1nm** and **G = 435.8nm**, (r, g, b) luminance ratios are approximately matches.\n\nIf ratios are normalized such that sum of ratios equals to 1, then **r : g : b = 0.2126 : 0.7152 : 0.0722**.\n\nTo match any target color, RGB colors are mixed in portions obtained from the CIE RGB color-matching function, and then those resultant RGB values should multiply by relative luminance ratios to get the target color with exact brightness.\n\n## CIE 1931 RGB color matching functions\n\nThe **Color matching functions** are mathematical estimation of color response of each primary color relative to human observer in 2&deg view field. Color matching functions gives amount of primary color energy required to generate target color wavelength. CIE defined three color mathcing functions $\\small{\\bar{r}(\\lambda), \\space \\bar{g}(\\lambda) \\space and \\space \\bar{b}(\\lambda)}$ which are normalized weight factors.\n\n![CIE 1931 RGB color matching functions:=:50](color-science/cie-rgb-cmf.jpg)\n\nIn the above RGB cmf diagram, each color wave represents RGB spectral intensities at various wavelengths. The three primary colors have peak sensitivity at wavelengths **R = 700nm**, **G = 546.1nm** and **G = 435.8nm**. The distribution of spectral energy is normalized and adding all color matching functions equals 1. Negative values in the graph indicate primary colors have to be mixed with the target color before color matching. And $\\small{\\bar{r}(\\lambda)}$ slightly matches the $\\small{V(\\lambda)}$ luminous efficiency function.\n\n### RGB Tristimulus values\n\nThe **tristimulus values** are, in a color space, the amount of color proportions of primary colors are required in a trichromatic additive color model to produce a color.\n\nFor CIE 1931 RGB color space, the RGB tristimulus values for spectral distribution of color $\\small{S(\\lambda)}$ can be calculated as\n$$\n\\small{R = \\int S(\\lambda)\\bar{r}(\\lambda)d\\lambda \\hspace2ex\nG = \\int S(\\lambda)\\bar{g}(\\lambda)d\\lambda \\hspace2ex\nB = \\int S(\\lambda)\\bar{b}(\\lambda)d\\lambda}\n$$\n\nwhere $\\small{S(\\lambda)}$ is spectral intensity of a color.\n\nIt can also be expressed as, for a color $\\small{C}$,\n$$\n\\small{C = R\\bar{r}(\\lambda) + G\\bar{g}(\\lambda) + B\\bar{b}(\\lambda)}\n$$\n$$\n\\small{C = R\\bold{R} + G\\bold{G} + B\\bold{B}}\n$$\n\nwhere $\\small{R}$, $\\small{G}$ and $\\small{B}$ are tristimulus values, and scaled to unit length.\n\n## CIE XYZ color matching functions\n\nRGB color matching functions contain negative intensities in mathematical form but they are not practically suitable for the physical world. CIE then converted RGB color space to XYZ color space where XYZ are linear combinations of monochromatic colors RGB. The new XYZ color matching functions have only positive intensities. The derived XYZ parameters are imaginary and they roughly represent S, M, and L cones.\n\n![CIE XYZ color matching functions:=:60](color-science/cie-xyz-cmf.jpg)\n\n$\\small{\\bar{x}(\\lambda), \\bar{y}(\\lambda) \\space and \\space \\bar{z}(\\lambda)}$ are color matching functions. From above diagram, we can say Violet (around 450nm) color is a mixture of Red and Blue which is indeed true and this cannot be seen in RGB color matching function curves.\n\n### CIE XYZ tristimulus values calculation \n\nFor light source with spectral radiance $\\small{L(\\lambda)}$,\n$$\n\\small{X = \\int L(\\lambda)\\bar{x}(\\lambda)d\\lambda \\hspace2ex\nY = \\int L(\\lambda)\\bar{y}(\\lambda)d\\lambda \\hspace2ex\nZ = \\int L(\\lambda)\\bar{z}(\\lambda)d\\lambda}\n$$\nwhere $$\\lambda$$ is the equivalent monochromatic light (nm) for a range of wavelengths [380, 780]nm.\n\nFor reflective or transmissive object case when illuminated by light source, replace spectral radiance by spectral reflectance (or transmittance) $\\small{S(\\lambda)}$, multiplied by the spectral power distribution of the illuminant $\\small{I(\\lambda)}$\n$$\n\\small{X = \\frac{K}{N}\\int S(\\lambda)I(\\lambda)\\bar{x}(\\lambda)d\\lambda}\n$$\n$$\n\\small{Y = \\frac{K}{N}\\int S(\\lambda)I(\\lambda)\\bar{y}(\\lambda)d\\lambda}\n$$\n$$\n\\small{Z = \\frac{K}{N}\\int S(\\lambda)I(\\lambda)\\bar{z}(\\lambda)d\\lambda}\n$$\n\nwhere $$K$$ is scaling factor (1-100), and\n$$\n\\small {N = \\int I(\\lambda)\\bar{y}(\\lambda)d\\lambda}\n$$\n\nDue to absence of analytical expressions of color matching functions, the above integration is transformed to summation of equal intervals of **10nm** over spectrum wavelength range [380, 780]nm.\n\n### XYZ from RGB\n\nDistribution of $\\small{\\bar{y}(\\lambda)}$ is close to $\\small{V(\\lambda)}$ luminous efficiency function. So Y component roughly describes the luminance of the color. X is a combination of RGB colors and Z represents blue color. With Y, XZ represents all possible chromaticities (color without luminance).\n\nXYZ is a linear combination of RGB colors. If RGB colors are vectors with unit length and act as vector basis, they form a three-dimensional vector space. And XYZ vectors form a new basis vector by a linear transformation **M** of RGB vector basis.\n\n$$\n\\small{\\begin{bmatrix}\nX \\\\\nY \\\\\nZ \\\\\n\\end{bmatrix} = M\n\\begin{bmatrix}\nR \\\\\nG \\\\\nB \\\\\n\\end{bmatrix}}\n$$\n$$\n\\small{\\begin{bmatrix}\nX \\\\\nY \\\\\nZ \\\\\n\\end{bmatrix} = \n\\begin{bmatrix}\nR_x & R_y & R_z \\\\\nG_x & G_y & G_z \\\\\nB_x & B_y & B_z\n\\end{bmatrix}\n\\begin{bmatrix}\nR \\\\\nG \\\\\nB \\\\\n\\end{bmatrix}}\n$$\n$$\n\\small{\\begin{bmatrix}\nX \\\\\nY \\\\\nZ \\\\\n\\end{bmatrix} = \\frac{1}{0.17}\n\\begin{bmatrix}\n0.49 & 0.31 & 0.20 \\\\\n0.17 & 0.81 & 0.01 \\\\\n0.00 & 0.01 & 0.99\n\\end{bmatrix}\n\\begin{bmatrix}\nR \\\\\nG \\\\\nB \\\\\n\\end{bmatrix}}\n$$\n\nFrom the above transformation matrix **M**, we can say Red and Green colors have zero or no impact on Z which can be confirmed from RGB color matching functions. Also, Y is a combination of weighted RGB values of relative luminance. \n\n---\n\n## CIE xy chromaticity diagram & CIE xyY color space\n\nImagine if XYZ tristimulus values are represented as vectors, they form a 3D vector space and contains all possible colors with RGB combinations in a cube. Now trace out the coordinates of XYZ for different wavelengths in the visible spectrum, the closed curve that is formed by joining all coordinates is called spectral locus.\n\n![CIE XYZ color space:=:60:=:CIE XYZ spectral locus$$$https://commons.wikimedia.org/wiki/File:3D_Graph_of_CIE_XYZ_Colorspace.png](color-science/cie-xyz-colorspace.jpg)\n\nThe above 3D XYZ color space contains colors with Hue, Saturation, and Intensity/Brightness. It requires three parameters (H, S, and V) to describe a color (each for hue, saturation, and intensity).\n\nIf (X, Y, Z) are projected to $\\small{X + Y + Z = 1}$ plane in XYZ vector space, then normalized representation of (X, Y, Z) is\n$$\n\\small{x = \\frac{X}{X + Y + Z} \\hspace2ex \ny = \\frac{Y}{X + Y + Z} \\hspace2ex\nz = \\frac{Z}{X + Y + Z}}\n$$\n\nSumming up the normalized x, y and z components equals to 1 i.e, $\\small{x + y + z = 1}$ and $\\small{x,y,z\\ge0}$\n\nThe planar projection of the above spectral locus to the plane $\\small{X + Y + Z = 1}$ forms a planar triangle.\n\n![CIE XYZ planar projection:=:35](color-science/spectral-locus-planar-projection.jpg)\n\n**Chromaticity** is a color property without intensity i.e color independent component of a color. Chromaticity is the quality of a color determined by its dominant wavelength and its purity (chroma/saturation). In chromaticity, only hue and saturation are used to describe the colors. That means light blue and dark blue have the same hue and saturation values, and same color matching functions.\n\nA chromaticity diagram is a representation of 3D XYZ color space in 2D space with only chromaticity values (hue and saturation). As $x + y + z =1$, any component can be derived from two other components. So z can be derived from x and y as\n$$\n\\small{x + y + z = 1}\n$$\n$$\n\\small{z = 1 - x - y}\n$$\n\nAny tristimulus value can be derived from other tristimulus values. With Y, X and Z are derived as \n$$\n\\small{X = \\frac{Y}{y}x}\n$$\n$$\n\\small{Z = \\frac{Y}{y}(1 - x - y)}\n$$\n\nIf the above spectral locus triangular plane in xyz-plane is projected onto xy-plane, a chromaticity diagram is obtained. And to construct the actual XYZ values, Y is stored along with xy. Together xyY forms the **CIE xyY** color space with xy as chromaticity coordinates and Y as a luminance value because we discussed earlier that the Y component roughly matches $\\small{V(\\lambda)}$.\n\nThe [RGB chromaticity diagram](https://en.wikipedia.org/wiki/Rg_chromaticity) could be constructed by following the same procedure as XYZ. Here **CIE rgG** color space is constructed by keeping rg chromaticity coordinates and G value for luminance.\n\n![CIE chromaticity diagram:=:50:=:CIE xyY chromaticity diagram](color-science/cie-chromaticity-diagram.jpg)\n\nThe horseshoe shape in the above diagram contains all colors of the projected planar triangle. The chromaticity diagram is a mathematical representation of the human eye's color perception. \n- The outer line of the spectral locus has colors with wavelengths distributed across in visible spectrum. Starting from violet to red and magenta line as a bridge between. These colors are hues or dominant wavelength colors which are seen in the rainbow.\n- The region inside the spectral locus contains all colors possible in XYZ space that are visible to our human eyes. These colors are saturated colors of hues or a mixture of monochromatic wavelengths.\n- A point (x, y) on the above graph matches a color in the xyY color space.\n- It can be observed that CMY (cyan, magenta, yellow) colors lie between (green and blue), (blue and red), and (red and green). CMY colors are present in complement/opposite to RGB.\n\n### Color gamut\n\n**Color gamut** describes a range of colors in the visible spectrum that are visible for human eyes. The color gamut of a device is that subset of color space that can be represented. color gamuts are generally a subset of the CIE chromaticity diagram with the center as a white point.\n\n![Color gamut:=:50:=:Different color gamuts in CIE xy chromaticity diagram$$$https://en.wikipedia.org/wiki/Gamut](color-science/color-gamut.jpg)\n\nColor gamuts are color spaces enclosed by a triangle with color coordinates of the monitor as red, green, and blue colors. A gamut is a three-dimensional color space with lightness being the third dimension perpendicular to the chromaticity diagram.\n\nCertain color gamuts are standardized by different institutions to reproduce the colors across different environments. The **sRGB** color gamut is the standard color subset used to display colors around the web.\n\nThe colors outside of the chromaticity diagram but inside a color gamut (like ProPhoto RGB) are called imaginary colors as they are not visible for human eyes and they look like normal visible colors. These colors can be detected using color measuring techniques but our eyes cannot differentiate those colors with normal visible colors.\n\n---\n\nOver time, different color spaces and techniques were developed to describe human color perception. **Colorimetry** and **Spectrophotometry** are two different methods to quantify the colors. CIE XYZ color spaces are also defined for the 10&deg standard observer, and it is the standard color space being used in the modern digital world. In the fields like image processing and digital photography, it is necessary to have a good grasp of concepts like chromaticity diagram and color gamuts that are useful for methods like color constancy, color correction, and color grading. \n\nFor further study about colors, check out the topics like color tolerance, color difference, conversion of different color gamuts between display systems, and additional color spaces like CIE LAB.\n\n---\n\n### References\n- [How the CIE 1931 color matching functions were derived](https://silo.tips/download/how-the-cie-1931-color-matching-functions-were-derived-from-wright-guild-data)\n- https://scholar.harvard.edu/files/schwartz/files/lecture17-color.pdf\n- [CIE 1931 color space - Wikipedia](https://en.wikipedia.org/wiki/CIE_1931_color_space)\n- [CIE color space - Gernot Hoffmann](http://docs-hoffmann.de/ciexyz29082000.pdf)\n- https://engineering.purdue.edu/~bouman/ece637/notes/pdf/Tristimulus.pdf\n- http://graphics.stanford.edu/courses/cs148-10-summer/docs/02_light_color.pdf\n- http://cs.haifa.ac.il/hagit/courses/ist/Lectures/IST03_ColorXYZx4.pdf\n- http://www.cs.cmu.edu/afs/cs/academic/class/15462-s16/www/lec_slides/23_color.pdf\n- https://web.eecs.umich.edu/~sugih/courses/eecs487/lectures/22-Light+Color.pdf\n- [Light, Color and Color Space - Scratch Pixel](https://www.scratchapixel.com/lessons/digital-imaging/colors/color-space)\n- [Color Matching - Craig Blackwell](https://www.youtube.com/watch?v=82ItpxqPP4I)\n- [Visualizing the XYZ Color space](https://www.youtube.com/watch?v=x0-qoXOCOow)\n- [A Beginner's Guide to Colorimetry](https://medium.com/hipster-color-science/a-beginners-guide-to-colorimetry-401f1830b65a)\n- [Precise Color Communincation - Konica Minolta](https://www.konicaminolta.com/instruments/knowledge/color/index.html)\n- [Color Gamut - Epxx](https://epxx.co/artigos/gamut_en.html)\n- http://www.marcelpatek.com/color.html\n- https://www.oceanopticsbook.info/view/photometry-and-visibility/chromaticity\n- https://www.thebroadcastbridge.com/content/entry/14426/color-and-colorimetry-part-7-cie-xyz"},{"metadata":{"title":"Create a Notes App with Flutter","description":"Create a color-rich Note-taking app with Flutter.","imgName":"note-app-flutter/note-app-in-flutter.jpg","date":"Jun 15, 2021","tags":["flutter"],"keywords":["flutter","dart","android","note-app","note-taking","sqflite","sqlite"],"id":"create-a-notes-app-with-flutter"},"content":"\n![Create a Notes App with flutter](note-app-flutter/note-app-in-flutter.jpg)\n\n# Create a Note-taking App in Flutter\n\nFlutter is a declarative framework that requires programming in Dart. Flutter is suitable for creating simple apps like Note-taking, Event-registration, etc.\n\n> Pre-requisites: Knowledge of basic Dart and Flutter. Read about [Flutter](https://flutter.dev/docs) and [Dart](https://dart.dev/guides).\n\nWith basic concepts like Widgets and Material design we can create simple apps very fast and easily in Flutter as in Flutter we can use tons of pre-designed widgets to create almost every popular design using in the modern design world.\n\nIn this tutorial, we discuss creating a simple note-taking app. The note-taking app we are going to create provides options like create, save, update and delete notes. \n\nOur note-taking app contains two screens \n- Home screen to display all saved notes\n- Notes edit screen to create new notes or edit saved notes\n\n## Create Flutter App\n\nBefore creating a Flutter app please make sure you have installed flutter-sdk and dart-sdk. If not follow the instructions to [install flutter](https://flutter.dev/docs/get-started/install).\n\nCreate a raw flutter app from the terminal. Run the following command and pass any name (to join more than single sting use only underscore)\n\n```bash\nflutter create notes_app\n```\n\nGo to root directory of **notes_app** and locate **main.dart** in **lib** folder. This is where our app starts execution by calling the main() function. You can find some code here which displays the welcome screen.\n\nNow to see the app in an emulator or on a physical device run the below command.\n\n```bash\ncd notes_app/\nflutter run\n```\n\nFor the initial run, it takes some time to install the app on the device, and later builds will be fast. If you encounter any error run _flutter doctor -v_ for additional information and make sure all necessary items are checked.\n\n---\n\n## What a Note should like and contain?\n\nA simple note must have a title and the content which can be edited as many times as possible. We can also add color to note for look and feel. \n\nTo store notes we use [Sqflite](https://pub.dev/packages/sqflite) (a plugin to mimic SQL database in Flutter). Each note can be stored as a single row in the database with fields id, title, content, color. \n\nCreate a file **note.dart** inside **lib/models**. Add a class **Note** to store note as an object which can be converted later as a Map object to store in the database.\n\n```dart:models/note.dart\nclass Note {\n\tint id;\n\tString title;\n\tString content;\n\tString noteColor;\n\n\tNote({\n\t\tthis.id = null, \n\t\tthis.title = \"Note\", \n\t\tthis.content = \"Text\", \n\t\tthis.noteColor = 'red'\n\t});\n\n\tMap<String, dynamic> toMap() {\n\t\tMap<String, dynamic> data = Map<String, dynamic>();\n\t\tif (id != null) {\n\t\t\tdata['id'] = id;\n\t\t}\n\t\tdata['title'] = title;\n\t\tdata['content'] = content;\n\t\tdata['noteColor'] = noteColor;\n\t\treturn data;\n\t}\n\n\t@override toString() {\n\t\treturn {\n\t\t\t'id': id,\n\t\t\t'title': title,\n\t\t\t'content': content,\n\t\t\t'noteColor': noteColor,\n\t\t}.toString();\n\t}\n}\n```\n\nThis Note class has attributes\n- id (primary key) - an identifier to store unique note objects in the database\n- title - the title of the note\n- content - content of the note\n- noteColor - the color of the note\n\n**toMap()** returns note as an object to store in the database.\n\nFor note colors, add another file called **theme/note_colors.dart** inside **lib/theme**.\n```dart:theme/note_colors.dart\nconst NoteColors = {\n\t'red': {'l': 0xFFFFCDD2,'b': 0xFFE57373},\n\t'pink': {'l': 0xFFF8BBD0, 'b': 0xFFF06292},\n\t'purple': {'l': 0xFFE1BEE7, 'b': 0xFFBA68C8},\n\t'deepPurple': {'l': 0xFFD1C4E9, 'b': 0xFF9575CD},\n\t'indigo': {'l': 0xFFC5CAE9, 'b': 0xFF7986CB},\n\t'blue': {'l': 0xFFBBDEFB, 'b': 0xFF64B5F6},\n\t'lightBlue': {'l': 0xFFB3E5FC, 'b': 0xFF4FC3F7},\n\t'cyan': {'l': 0xFFB2EBF2, 'b': 0xFF4DD0E1},\n\t'teal': {'l': 0xFFB2DFDB, 'b': 0xFF4DB6AC},\n\t'green': {'l': 0xFFC8E6C9, 'b': 0xFF81C784},\n\t'lightGreen': {'l': 0xFFDCEDC8, 'b': 0xFFAED581},\n\t'lime': {'l': 0xFFF0F4C3, 'b': 0xFFDCE775},\n\t'yellow': {'l': 0xFFFFF9C4, 'b': 0xFFFFF176},\n\t'amber': {'l': 0xFFFFECB3, 'b': 0xFFFFD54F},\n\t'orange': {'l': 0xFFFFE0B2, 'b': 0xFFFFB74D},\n\t'deepOrange': {'l': 0xFFFFCCBC, 'b': 0xFFFF8A65},\n\t'brown': {'l': 0xFFD7CCCB, 'b': 0xFFA1887F},\n\t'blueGray': {'l': 0xFFCFD8DC, 'b': 0xFF90A4AE},\n};\n```\n\nEach color name ('k') is a key and each key ('k') has two colors 'l' and 'b', where 'l' is a light color and 'b' is the bright color of this 'k' color. The light and bright colors are used to display a note in the UI which we discuss later. 'k' is the color name we store in the database.\n\n---\n\n## Store notes in the database\n\nNow to store notes on the database we use **sqflite** plugin. Install **sqflite** by adding dependency in *pubspec.yaml*.\n\n```bash\ndependencies:\n  flutter:\n    sdk: flutter\n  sqflite: ^1.3.0\n```\n\nNow in terminal run *flutter pub get* to install or update dependencies in *pubspec.yaml*.\n\nTo handle database operations we write different functions for different operations like read, write, update and delete. Create **notes_database.dart** inside **models** and add a class to handle different operations\n\n```dart:models/notes_database.dart\nimport 'package:sqflite/sqflite.dart';\n\nimport 'note.dart';\n\nclass NotesDatabase {\n\tstatic final _name = \"NotesDatabase.db\";\n\tstatic final _version = 1;\n\n\tDatabase database;\n\tstatic final tableName = 'notes';\n\n\tinitDatabase() async {\n\t\tdatabase = await openDatabase(\n\t\t\t_name,\n\t\t\tversion: _version,\n\t\t\tonCreate: (Database db, int version) async {\n\t\t\t\tawait db.execute(\n\t\t\t\t\t'''CREATE TABLE $tableName (\n\t\t\t\t\tid INTEGER PRIMARY KEY AUTOINCREMENT,\n\t\t\t\t\ttitle TEXT,\n\t\t\t\t\tcontent TEXT,\n\t\t\t\t\tnoteColor TEXT\n\t\t\t\t\t)'''\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\tFuture<int> insertNote(Note note) async {\n\t\treturn await database.insert(tableName, \n\t\t\tnote.toMap(), \n\t\t\tconflictAlgorithm: ConflictAlgorithm.replace\n\t\t);\n\t}\n\n\tFuture<int> updateNote(Note note) async {\n\t\treturn await database.update(tableName, note.toMap(),\n\t\t\twhere: 'id = ?', \n\t\t\twhereArgs: [note.id],\n\t\t\tconflictAlgorithm: ConflictAlgorithm.replace\n\t\t);\n\t}\n\n\tFuture<List<Map<String, dynamic>>> getAllNotes() async {\n\t\treturn await database.query(tableName);\n\t}\n\n\tFuture<Map<String, dynamic>> getNotes(int id) async {\n\t\tvar result = await database.query(tableName,\n\t\t\twhere: 'id = ?',\n\t\t\twhereArgs: [id]\n\t\t);\n\n\t\tif (result.length > 0) {\n\t\t\treturn result.first;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tFuture<int> deleteNote(int id) async {\n\t\treturn await database.delete(tableName,\n\t\t\twhere: 'id = ?',\n\t\t\twhereArgs: [id]\n\t\t);\n\t}\n\n\tcloseDatabase() async {\n\t\tawait database.close();\n\t}\n}\n```\n\nFirst, we need to create a table in the database with some schema. Inside **initDatabase()**, we are calling **openDatabase()** to create database and table or open existing database and table by passing parameters **_name** (name of the database) and **_version** where **_name = NotesDatabse.db** is the name of the database and we can maintain different versions of the database through **_version**. \n\nIf there is no database with a specified **name**, **onCreate** callback is called to create a database with table and schema. Above we create a table with **tableName = notes** and initial schema with required fields like id, title, content, and noteColor to store a note object. \n\n**openDatabase()** is an async operation and returns **Database** object reference which points to the created/existed database. We store this reference as **database** of type class **Database**.\n\nOther functions **insertNote**, **updateNote**, **getNotes** and **deleteNotes** handles different database operations. Read more about [how to perform different operations in sqflite](https://github.com/tekartik/sqflite/blob/master/sqflite/doc/how_to.md).\n\nAs we cannot store Note as a class object we convert Note object members to a Map object by calling Note.toMap() which returns a Map object which sqflite map fields and values to store in the database. And Sqflite returns data as Map objects the way we pass it to insert rows in the database.\n\nWe have added logic to maintain notes in the database. But we have not done anything in UI to interact for maintaining notes. \n\n## Add Home Screen\n\nNow create a file called **home.dart** in **lib/screens**. This **home.dart** serves as the Home screen of our app. Add following code to **home.dart**\n\n```dart:screens/home.dart\nimport 'package:flutter/material.dart';\n\nconst c1 = 0xFFFDFFFC, c2 = 0xFFFF595E, c3 = 0xFF374B4A, c4 = 0xFF00B1CC, c5 = 0xFFFFD65C, c6 = 0xFFB9CACA,\n\tc7 = 0x80374B4A, c8 = 0x3300B1CC, c9 = 0xCCFF595E;\n\n// Home Screen\nclass Home extends StatefulWidget{\n\t@override\n\t_Home createState() => _Home();\n}\n\nclass _Home extends State<Home> {\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn MaterialApp(\n\t\t\ttitle: 'Super Note',\n\t\t\thome: Scaffold(\n\t\t\t\tbackgroundColor: Color(c6),\n\t\t\t\tappBar: AppBar(\n\t\t\t\t\tautomaticallyImplyLeading: false,\n\t\t\t\t\tbackgroundColor: const Color(c2),\n\t\t\t\t\tbrightness: Brightness.dark,\n\n\t\t\t\t\ttitle: Text(\n\t\t\t\t\t\t'Super Note',\n\t\t\t\t\t\tstyle: TextStyle(\n\t\t\t\t\t\t\tcolor: const Color(c5),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\n\t\t\t\t//Floating Button\n\t\t\t\tfloatingActionButton: FloatingActionButton(\n\t\t\t\t\tchild: const Icon(\n\t\t\t\t\t\tIcons.add,\n\t\t\t\t\t\tcolor: const Color(c5),\n\t\t\t\t\t),\n\t\t\t\t\ttooltip: 'New Notes',\n\t\t\t\t\tbackgroundColor: const Color(c4),\n\t\t\t\t\tonPressed: () => {},\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n}\n```\n\nThere are some color constants defined at the top which will be used across the app. The color format in Flutter is different from normal Hex. In normal Hex format, we provide opacity at last but in Flutter we have to provide opacity at first.\n\nHere we are creating a Home widget as **StatefulWidget** keeping in mind that we need to maintain the state. Every custom widget must override **build** method and return a widget. **MaterialApp** widget gives child widgets material look and we must declare required attributes. **Scaffold** widget is a common material design concept that provides appbar, floating button, drawer, body, etc.  \n\nThe Home screen displays all notes stored in the database. We discuss later displaying notes in the Home screen after creating notes in the Edit screen.\n\nTo display our Home screen as default screen in our app call **Home()** widget inside **MyApp** in **main.dart**\n\n```dart:main.dart\nimport 'package:flutter/material.dart';\n\nimport './screens/home.dart';\n\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Home(),\n    );\n  }\n}\n```\n\nTo see the changes in the app, in the flutter running environment press **r** to hot reload or **R** restart of the app.\n\n![Home Screen:=:30](note-app-flutter/notes-app-initial-home-screen.jpg)\n\nThe Floating action button at the bottom-right will take us to the Edit screen to create a new note. To add navigation from Home to Edit, first create a Edit Screen Widget in **notes_edit.dart** inside **lib/screens**. For now, add a simple UI for the Edit screen like below because we just need a widget to route from Home to Edit screen.\n\n```dart:screens/notes_edit.dart\nimport 'package:flutter/material.dart';\n\nconst c1 = 0xFFFDFFFC, c2 = 0xFFFF595E, c3 = 0xFF374B4A, c4 = 0xFF00B1CC, c5 = 0xFFFFD65C, c6 = 0xFFB9CACA,\n\t\t\tc7 = 0x80374B4A;\n\nclass NotesEdit extends StatefulWidget {\n\t_NotesEdit createState() => _NotesEdit();\n}\n\nclass _NotesEdit extends State<NotesEdit> {\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn MaterialApp(\n\t\t\ttitle: 'Edit Screen',\n\t\t\thome: Text(\n\t\t\t\t'Edit'\n\t\t\t),\n\t\t);\n\t}\n}\n```\n\n**NotesEdit** widget is the main widget for the Edit screen. We call this widget in navigation.\n\n### Navigation from Home to Edit\n\nAdd navigation from Home to Edit when pressed floating-action-buttton. Call **Navigation.push()** for the **EditNotes** widget. In **home.dart** add navigation in **onPressed()** event of floating-action-button.\n\n```dart\nimport './notes_edit.dart';\n```\n\n```dart\n//Floating Button\nfloatingActionButton: FloatingActionButton(\n\tchild: const Icon(\n\t\tIcons.add,\n\t\tcolor: const Color(c5),\n\t),\n\ttooltip: 'New Notes',\n\tbackgroundColor: const Color(c4),\n\t// Go to Edit screen\n\tonPressed: () {\n\t  Navigator.push(\n\t  \tcontext,     \n\t    MaterialPageRoute(builder: (context) => NotesEdit()),\n\t  );\n\t}\n),\n```\n\n---\n\n## Change Edit Screen\n\nChange Edit screen UI for creating a new note.\n\n```dart:screens/notes_edit.dart\nimport 'package:flutter/material.dart';\n\nimport '../models/note.dart';\nimport '../models/notes_database.dart';\nimport '../theme/note_colors.dart';\n\nconst c1 = 0xFFFDFFFC, c2 = 0xFFFF595E, c3 = 0xFF374B4A, c4 = 0xFF00B1CC, c5 = 0xFFFFD65C, c6 = 0xFFB9CACA,\n\tc7 = 0x80374B4A;\n\nclass NotesEdit extends StatefulWidget {\n\t_NotesEdit createState() => _NotesEdit();\n}\n\nclass _NotesEdit extends State<NotesEdit> {\n\tString noteTitle = '';\n\tString noteContent = '';\n\tString noteColor = 'red';\n\n\tTextEditingController _titleTextController = TextEditingController();\n\tTextEditingController _contentTextController = TextEditingController();\n\n\tvoid handleTitleTextChange() {\n\t\tsetState(() {\n\t\t\tnoteTitle = _titleTextController.text.trim();\n\t\t});\n\t}\n\n\tvoid handleNoteTextChange() {\n\t\tsetState(() {\n\t\t\tnoteContent = _contentTextController.text.trim();\n\t\t});\n\t}\n\n\t@override\n\tvoid initState() {\n\t\tsuper.initState();\n\t\t_titleTextController.addListener(handleTitleTextChange);\n\t\t_contentTextController.addListener(handleNoteTextChange);\n\t}\n\n\t@override\n\tvoid dispose() {\n\t\t_titleTextController.dispose();\n\t\t_contentTextController.dispose();\n\t\tsuper.dispose();\n\t}\n\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn Scaffold(\n\t\t\tbackgroundColor: Color(NoteColors[this.noteColor]['l']),\n\t\t\tappBar: AppBar(\n\t\t\t\tbackgroundColor: Color(NoteColors[this.noteColor]['b']),\n\n\t\t\t\tleading: IconButton(\n\t\t\t\t\ticon: const Icon(\n\t\t\t\t\t\tIcons.arrow_back,\n\t\t\t\t\t\tcolor: const Color(c1),\n\t\t\t\t\t),\n\t\t\t\t\ttooltip: 'Back',\n\t\t\t\t\tonPressed: () => {},\n\t\t\t\t),\n\n\t\t\t\ttitle: NoteTitleEntry(_titleTextController),\n\t\t\t),\n\n\t\t\tbody: NoteEntry(_contentTextController),\n\t\t);\n\t}\n}\n```\n\nIn the above **NotesEdit** widget, the state variables **noteTitle**, **noteContent** and **noteColor** are initialized to default values for now. **noteTitel** is to store title of the note, **noteContent** is to store note content and**noteColor** is color of the color, light and bright colors of the **noteColor** are used as **backgroundColor** for **appBar** and **Scaffold** respectively. \n\nAlso there are two **TextEditingController** defined which are used to controll **TextField** values for **noteTitle** and **noteContent**. These two text controller are attached with listeners in **iniitState()**. These listeneres listen to changes and updates text values in state. **_titleTextController** handles and updates text value for **noteTitle** and **_contentTextController** handles **noteContent**.\n\nThe **title** of the **appBar** is set to a widget **NoteTitleEntry** which handles displaying and editing of the title.\n\n```dart\nclass NoteTitleEntry extends StatelessWidget {\n\tfinal _textFieldController;\n\n\tNoteTitleEntry(this._textFieldController);\n\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn TextField(\n\t\t\tcontroller: _textFieldController,\n\t\t\tdecoration: InputDecoration(\n\t\t\t\tborder: InputBorder.none,\n\t\t\t\tfocusedBorder: InputBorder.none,\n\t\t\t\tenabledBorder: InputBorder.none,\n\t\t\t\terrorBorder: InputBorder.none,\n\t\t\t\tdisabledBorder: InputBorder.none,\n\t\t\t\tcontentPadding: EdgeInsets.all(0),\n\t\t\t\tcounter: null,\n\t\t\t\tcounterText: \"\",\n\t\t\t\thintText: 'Title',\n\t\t\t\thintStyle: TextStyle(\n\t\t\t\t\tfontSize: 21,\n\t\t\t\t\tfontWeight: FontWeight.bold,\n\t\t\t\t\theight: 1.5,\n\t\t\t\t),\n\t\t\t),\n\t\t\tmaxLength: 31,\n\t\t\tmaxLines: 1,\n\t\t\tstyle: TextStyle(\n\t\t\t\tfontSize: 21,\n\t\t\t\tfontWeight: FontWeight.bold,\n\t\t\t\theight: 1.5,\n\t\t\t\tcolor: Color(c1),\n\t\t\t),\n\t\t\ttextCapitalization: TextCapitalization.words,\n\t\t);\n\t}\t\n}\n```\n\nIn the **TextField**, the controller is set to **_textFieldController** which is passed from parent widget ** as **_titleTextController**. \n\nSimilarly, content of the notes is handled by another widget **NoteEntry**.\n\n```dart\nclass NoteEntry extends StatelessWidget {\n\tfinal _textFieldController;\n\n\tNoteEntry(this._textFieldController);\n\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn Container(\n\t\t\theight: MediaQuery.of(context).size.height,\n\t\t\tpadding: EdgeInsets.symmetric(horizontal: 12, vertical: 8),\n\t\t\tchild: TextField(\n\t\t\t\tcontroller: _textFieldController,\n\t\t\t\tmaxLines: null,\n\t\t\t\ttextCapitalization: TextCapitalization.sentences,\n\t\t\t\tdecoration: null,\n\t\t\t\tstyle: TextStyle(\n\t\t\t\t\tfontSize: 19,\n\t\t\t\t\theight: 1.5,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n}\n```\n\nHere also controller of **TextField** is set to **_textFieldController** which is passed from parent wdiget as **_contentTextController**.\n\nAfter adding all these widgets, the Edit screen would look like\n\n![Edit screen:=:30](note-app-flutter/notes-app-initial-edit-screen.jpg)\n\n### Add a Color palette to select Note color\n\nWe will add a color palette to select note color and store the value in **noteColor**. For color palette, add an icon in **appBar** **actions** which on press shows a **Dialog** box with different colors.\n\nIn **NotesEdit** add color palette button\n\n```dart\nactions: [\n\tIconButton(\n\t\ticon: const Icon(\n\t\t\tIcons.color_lens,\n\t\t\tcolor: const Color(c1),\n\t\t),\n\t\ttooltip: 'Color Palette',\n\t\tonPressed: () => handleColor(context),\n\t),\n],\n```\n\nFor this button, **onPressed** event calls **handleColor()** function which shows a color palette and store selected value in **noteColor** variable. Define **handleColor()** inside **_NotesEdit**\n\n```dart\nvoid handleColor(currentContext) {\n\tshowDialog(\n\t\tcontext: currentContext,\n\t\tbuilder: (context) => ColorPalette(\n\t\t\tparentContext: currentContext,\n\t\t),\n\t).then((colorName) {\n\t\tif (colorName != null) {\n\t\t\tsetState(() {\n\t\t\t\tnoteColor = colorName;\n\t\t\t});\n\t\t}\n\t});\n}\n```\n\nThis **handleColor()** calls widget **ColorPalette** which is a **Dialog** box and returns selected color value. Add **ColorPalette** widget to show different colors and return selected color\n\n```dart\nclass ColorPalette extends StatelessWidget {\n\tfinal parentContext;\n\n\tconst ColorPalette({ \n\t\t@required this.parentContext,\n\t});\n\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn Dialog(\n\t\t\tbackgroundColor: Color(c1),\n\t\t\tclipBehavior: Clip.hardEdge,\n\t\t\tinsetPadding: EdgeInsets.all(MediaQuery.of(context).size.width * 0.03),\n\t\t\tshape: RoundedRectangleBorder(\n\t\t\t\tborderRadius: BorderRadius.circular(2),\n\t\t\t),\n\t\t\tchild: Container(\n\t\t\t\tpadding: EdgeInsets.all(8),\n\t\t\t\tchild: Wrap(\n\t\t\t\t\talignment: WrapAlignment.start,\n\t\t\t\t\tspacing: MediaQuery.of(context).size.width * 0.02,\n\t\t\t\t\trunSpacing: MediaQuery.of(context).size.width * 0.02,\n\t\t\t\t\tchildren: NoteColors.entries.map((entry) {\n\t\t\t\t\t\treturn GestureDetector(\n\t\t\t\t\t\t\tonTap: () => Navigator.of(context).pop(entry.key),\n\t\t\t\t\t\t\tchild: Container(\n\t\t\t\t\t\t\t\twidth: MediaQuery.of(context).size.width * 0.12,\n\t\t\t\t\t\t\t\theight: MediaQuery.of(context).size.width * 0.12,\n\t\t\t\t\t\t\t\tdecoration: BoxDecoration(\n\t\t\t\t\t\t\t\t\tborderRadius: BorderRadius.circular(MediaQuery.of(context).size.width * 0.06),\n\t\t\t\t\t\t\t\t\tcolor: Color(entry.value['b']),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}).toList(),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n}\n``` \n\nAs we already stored different colors in **NoteColors** Map object, we iterate this object and fill the color palette with bright colors.\n\n![Color Palette:=:60](note-app-flutter/notes-app-color-palette.jpg)\n\n### Save notes\n\nWe have everything to save notes in the database. We save a note in the database if **backButton** is pressed at the top. Now add a function to handle **backButton** **onPressed**.\n\n```dart\nvoid handleBackButton() async {\n\tif (noteTitle.length == 0) {\n\t\t// Go Back without saving\n\t\tif (noteContent.length == 0) {\n\t\t\tNavigator.pop(context);\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tString title = noteContent.split('\\n')[0];\n\t\t\tif (title.length > 31) {\n\t\t\t\ttitle = title.substring(0, 31);\n\t\t\t}\n\t\t\tsetState(() {\n\t\t\t\tnoteTitle = title;\n\t\t\t});\n\t\t}\n\t}\n\n\t// Save New note\n\tNote noteObj = Note(\n\t\ttitle: noteTitle, \n\t\tcontent: noteContent, \n\t\tnoteColor: noteColor\n\t);\n\ttry {\n\t\tawait _insertNote(noteObj);\n\t} catch (e) {\n\t\tprint('Error inserting row');\n\t} finally {\n\t\tNavigator.pop(context);\n\t\treturn;\n\t}\n}\n```\n\nThis function calls **_insertNote()** which saves the note object in the database.\n\n```dart\nFuture<void> _insertNote(Note note) async {\n  NotesDatabase notesDb = NotesDatabase();\n  await notesDb.initDatabase();\n  int result = await notesDb.insertNote(note);\n  await notesDb.closeDatabase();\n}\n``` \n\nWe have saved notes in the database, now in the Home screen, display the saved notes in list view.\n\n---\n\n## Show saved notes on the Home screen\n\nWe can retrieve saved notes from the database and we use that retrieved data to show a note as a list on the Home screen. As retrieving data from the database is an async task and we need to have data before building the Home widget, we use [FutureBuilder](https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html).\n\n```dart\nFuture<List<Map<String, dynamic>>> readDatabase() async {\n\ttry {\n\t  NotesDatabase notesDb = NotesDatabase();\n\t  await notesDb.initDatabase();\n\t  List<Map> notesList = await notesDb.getAllNotes();\n\t  await notesDb.closeDatabase();\n\t  List<Map<String, dynamic>> notesData = List<Map<String, dynamic>>.from(notesList);\n\t \tnotesData.sort((a, b) => (a['title']).compareTo(b['title']));\n\t  return notesData;\n\t} catch(e) {\n\t\tprint('Error retrieving notes');\n\t\treturn [{}];\n\t}\n}\n```\n\nThis function reads all saved notes in the database and returns them as **Future** objects. We call this function in FutureBuilder and it builds the note list which displays each notes as a list.\n\nBefore that add necessary imports in **home.dart** to handle the database, to store note object and colors.\n\n```dart\nimport '../models/note.dart';\nimport '../models/notes_database.dart';\nimport '../theme/note_colors.dart';\n```\nStore read notes from database in state and define other state variables\n\n```dart\nList<Map<String, dynamic>> notesData;\nList<int> selectedNoteIds = [];\n```\n\n**notesData** stores all notes data read from database and **selectedNoteIds** will have a list of selected notes when a note is selected in Home.\n\n```dart\nbody: FutureBuilder(\n\tfuture: readDatabase(),\n\tbuilder: (context, snapshot) {\n\t\tif (snapshot.hasData) {\n\t\t\tnotesData = snapshot.data;\n\t\t\treturn Stack(\n\t\t\t\tchildren: <Widget>[\n\t\t\t\t\t// Display Notes\n\t\t\t\t\tAllNoteLists(\n\t\t\t\t\t\tsnapshot.data,\n\t\t\t\t\t\tthis.selectedNoteIds,\n\t\t\t\t\t\tafterNavigatorPop,\n\t\t\t\t\t\thandleNoteListLongPress,\n\t\t\t\t\t\thandleNoteListTapAfterSelect,\n\t\t\t\t\t),\n\t\t\t\t],\n\t\t\t);\n\t\t} else if (snapshot.hasError) {\n\t\t\tprint('Error reading database');\n\t\t} else {\n\t\t\treturn Center(\n\t\t\t\tchild: CircularProgressIndicator(\n\t\t\t\t\tbackgroundColor: Color(c3),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t}\n),\n```\n\nHere before building the widget we read the data from the database and builds a list of note widgets to display on the Home screen by calling **AllNoteLists** widget. We also pass different callback functions to **AllNoteLists** to handles cases like the long selection of note, deselect a note, etc.\n\nDefine all these functions inside **_Home**\n\n```dart\n// Render the screen and update changes\nvoid afterNavigatorPop() {\n\tsetState(() {});\n}\n\n// Long Press handler to display bottom bar\nvoid handleNoteListLongPress(int id) {\n\tsetState(() {\n\t\tif (selectedNoteIds.contains(id) == false) {\n\t\t\tselectedNoteIds.add(id);\n\t\t}\n\t});\n}\n\n// Remove selection after long press\nvoid handleNoteListTapAfterSelect(int id) {\n\tsetState(() {\n\t\tif (selectedNoteIds.contains(id) == true) {\n\t\t\tselectedNoteIds.remove(id);\n\t\t}\n\t});\n}\n\n// Delete Note/Notes\nvoid handleDelete() async {\n\ttry {\n\t\tNotesDatabase notesDb = NotesDatabase();\n\t\tawait notesDb.initDatabase();\n\t\tfor (int id in selectedNoteIds) {\n\t\t\tint result = await notesDb.deleteNote(id);\n\t\t}\n\t\tawait notesDb.closeDatabase();\n\t} catch (e) {\n\n\t} finally {\n\t\tsetState(() {\n\t\t\tselectedNoteIds = [];\n\t\t});\n\t}\n}\n```\n\nDefine **AllNoteLists** widget which gets arguments from parent widget including note data and callback functions to handle\n\n```dart\n// Display all notes\nclass AllNoteLists extends StatelessWidget {\n\tfinal data;\n\tfinal selectedNoteIds;\n\tfinal afterNavigatorPop;\n\tfinal handleNoteListLongPress;\n\tfinal handleNoteListTapAfterSelect;\n\n\tAllNoteLists(\n\t\tthis.data, \n\t\tthis.selectedNoteIds,\n\t\tthis.afterNavigatorPop,\n\t\tthis.handleNoteListLongPress,\n\t\tthis.handleNoteListTapAfterSelect,\n\t);\n\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn ListView.builder(\n\t\t\titemCount: data.length,\n\t\t\titemBuilder: (context, index) {\n\t\t\t\tdynamic item = data[index];\n\t\t\t\treturn DisplayNotes(\n\t\t\t\t\titem,\n\t\t\t\t\tselectedNoteIds,\n\t\t\t\t\t(selectedNoteIds.contains(item['id']) == false? false: true),\n\t\t\t\t\tafterNavigatorPop, \n\t\t\t\t\thandleNoteListLongPress,\n\t\t\t\t\thandleNoteListTapAfterSelect,\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\n\n\n// A Note view showing title, first line of note and color\nclass DisplayNotes extends StatelessWidget {\n\tfinal notesData;\n\tfinal selectedNoteIds;\n\tfinal selectedNote;\n\tfinal callAfterNavigatorPop;\n\tfinal handleNoteListLongPress;\n\tfinal handleNoteListTapAfterSelect;\n\n\tDisplayNotes(\n\t\tthis.notesData,\n\t\tthis.selectedNoteIds,\n\t\tthis.selectedNote,\n\t\tthis.callAfterNavigatorPop,\n\t\tthis.handleNoteListLongPress,\n\t\tthis.handleNoteListTapAfterSelect,\n\t);\n\n\t@override\n\tWidget build(BuildContext context) {\n\t\treturn Padding(\n\t\t\tpadding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 2.0),\n\t\t\tchild: Material(\n\t\t\t\televation: 1,\n\t\t\t\tcolor: (selectedNote == false? Color(c1): Color(c8)),\n\t\t\t\tclipBehavior: Clip.hardEdge,\n\t\t\t\tborderRadius: BorderRadius.circular(5.0),\n\t\t\t\tchild: InkWell(\n\t\t\t\t\tonTap: () {\n\t\t\t\t\t\tif (selectedNote == false) {\n\t\t\t\t\t\t\tif (selectedNoteIds.length == 0) {\n\t\t\t\t\t\t\t\t// Go to edit screen to update notes\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\thandleNoteListLongPress(notesData['id']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} \n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\thandleNoteListTapAfterSelect(notesData['id']);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tonLongPress: () {\n\t\t\t\t\t\thandleNoteListLongPress(notesData['id']);\n\t\t\t\t\t},\n\t\t\t\t\tchild: Container(\n\t\t\t\t\t\twidth: MediaQuery.of(context).size.width,\n\t\t\t\t\t\tpadding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),\n\t\t\t\t\t\tchild: Row(\n\t\t\t\t\t\t\tchildren: <Widget>[\n\t\t\t\t\t\t\t\tExpanded(\n\t\t\t\t\t\t\t\t\tflex: 1,\n\t\t\t\t\t\t\t\t\tchild: Column(\n\t\t\t\t\t\t\t\t\t\tmainAxisAlignment: MainAxisAlignment.center,\n\t\t\t\t\t\t\t\t\t\tcrossAxisAlignment: CrossAxisAlignment.center,\n\t\t\t\t\t\t\t\t\t\tmainAxisSize: MainAxisSize.min,\n\t\t\t\t\t\t\t\t\t\tchildren: <Widget>[\n\t\t\t\t\t\t\t\t\t\t\tContainer(\n\t\t\t\t\t\t\t\t\t\t\t\talignment: Alignment.center,\n\t\t\t\t\t\t\t\t\t\t\t\tdecoration: BoxDecoration(\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: (selectedNote == false? \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tColor(NoteColors[notesData['noteColor']]['b']):\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tColor(c9)\n\t\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\t\tshape: BoxShape.circle,\n\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\tchild: Padding(\n\t\t\t\t\t\t\t\t\t\t\t\t\tpadding: EdgeInsets.all(10),\n\t\t\t\t\t\t\t\t\t\t\t\t\tchild: (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tselectedNote == false?\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tText(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnotesData['title'][0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstyle: TextStyle(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: Color(c1),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfontSize: 21,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t):\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tIcon(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tIcons.check,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: Color(c1),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsize: 21,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t),\n\n\t\t\t\t\t\t\t\tExpanded(\n\t\t\t\t\t\t\t\t\tflex: 5,\n\t\t\t\t\t\t\t\t\tchild: Column(\n\t\t\t\t\t\t\t\t\t\tmainAxisAlignment: MainAxisAlignment.spaceAround,\n\t\t\t\t\t\t\t\t\t\tcrossAxisAlignment: CrossAxisAlignment.start,\n\t\t\t\t\t\t\t\t\t\tmainAxisSize: MainAxisSize.min,\n\t\t\t\t\t\t\t\t\t\tchildren:<Widget>[\n\t\t\t\t\t\t\t\t\t\t\tText(\n\t\t\t\t\t\t\t\t\t\t\t\tnotesData['title'] != null? notesData['title']: \"\",\n\t\t\t\t\t\t\t\t\t\t\t\tstyle: TextStyle(\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: Color(c3),\n\t\t\t\t\t\t\t\t\t\t\t\t\tfontSize: 18,\n\t\t\t\t\t\t\t\t\t\t\t\t\tfontWeight: FontWeight.bold,\n\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t),\n\n\t\t\t\t\t\t\t\t\t\t\tContainer(\n\t\t\t\t\t\t\t\t\t\t\t\theight: 3,\n\t\t\t\t\t\t\t\t\t\t\t),\n\n\t\t\t\t\t\t\t\t\t\t\tText(\n\t\t\t\t\t\t\t\t\t\t\t\tnotesData['content'] != null? notesData['content'].split('\\n')[0]: \"\",\n\t\t\t\t\t\t\t\t\t\t\t\tstyle: TextStyle(\n\t\t\t\t\t\t\t\t\t\t\t\t\tcolor: Color(c7),\n\t\t\t\t\t\t\t\t\t\t\t\t\tfontSize: 16,\n\t\t\t\t\t\t\t\t\t\t\t\t\tfontWeight: FontWeight.w300,\n\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n}\n```\n\n**AllNoteLists** builds a list of notes from the Map of a list of notes. In **ListView** builder it passes each note extracted data to another widget **DisplayNotes** which represents each note. \n\nNow Home screen displays all notes stored as\n\n![Home screen:=:30](note-app-flutter/notes-app-home-notes-list.jpg)\n\nLong press on the note to select the note. And if a note is selected we can add a delete action to delete the selected notes. Add **Delete** button at **appBar** **actions** which shows delete icon only if any note is selected.\n\n```dart\nactions: [\n\t(selectedNoteIds.length > 0?\n\t\tIconButton(\n\t\t\ticon: const Icon(\n\t\t\t\tIcons.delete,\n\t\t\t\tcolor: const Color(c1),\n\t\t\t),\n\t\t\ttooltip: 'Delete',\n\t\t\tonPressed: () => handleDelete(),\n\t\t):\n\t\tContainer()\n\t),\n],\n```\n\nDefine **hanldeDelete()** which deletes all selected notes from database.\n\n```dart\n// Delete Notes\nvoid handleDelete() async {\n\ttry {\n\t\tNotesDatabase notesDb = NotesDatabase();\n\t\tawait notesDb.initDatabase();\n\t\tfor (int id in selectedNoteIds) {\n\t\t\tint result = await notesDb.deleteNote(id);\n\t\t}\n\t\tawait notesDb.closeDatabase();\n\t} catch (e) {\n\t\tprint('Cannot delete notes');\n\t} finally {\n\t\tsetState(() {\n\t\t\tselectedNoteIds = [];\n\t\t});\n\t}\n}\n```\n\nFor notes, we have added create, read and delete functions. Now we will add an update function to edit already stored notes.\n\n### Update notes\n\nFor this, we can use the Edit screen to update the notes as it has all features to create notes which are similar for update notes also. We have to tell the Edit screen which type of notes operations we doing either create or update notes. To inform the Edit screen we can pass arguments to **NotesEdit** widget while routing about the type of action and notes data if the action is to update. Change **NotesEdit** widget to accept arguments telling the type of action and necessary data.\n\n```dart\nclass NotesEdit extends StatefulWidget {\n\tfinal args;\n\n\tconst NotesEdit(this.args);\n\t_NotesEdit createState() => _NotesEdit();\n}\n```\n\n**args** stores parameters passed from parent widget.\n\nChange navigation arguments for **NotesEdit** in the floating-action-button in **_Home**.\n\n```dart\n//Floating Button\nfloatingActionButton: FloatingActionButton(\n\tchild: const Icon(\n\t\tIcons.add,\n\t\tcolor: const Color(c5),\n\t),\n\ttooltip: 'New Notes',\n\tbackgroundColor: const Color(c4),\n\tonPressed: () {\n\t  Navigator.push(\n\t  \tcontext,     \n\t    MaterialPageRoute(builder: (context) => NotesEdit(['new', {}])),\n\t  );\n\t}\n),\n```\n\nAs floating-button triggers the creation of a new note, we pass argument **new** to inform **NotesEdit** that operation in creation of note.\n\nWhen tapped on a note on the Home screen we navigate to the Edit screen to update the note. For this add navigation from Home to Edit when tapped on the note in **DisplayNotes**.\n\n```dart\nchild: InkWell(\nonTap: () {\n\tif (selectedNote == false) {\n\t\tif (selectedNoteIds.length == 0) {\n\t\t\tNavigator.push(\n\t\t\t\tcontext, \n        MaterialPageRoute(\n          builder: (context) => NotesEdit(['update', notesData]),\n        ),\n\t\t\t).then((dynamic value) {\n\t\t\t\t\tcallAfterNavigatorPop();\n\t\t\t\t}\n\t\t\t);\n\t\t\treturn;\t\t\n\t\t}\n\t\telse {\n\t\t\thandleNoteListLongPress(notesData['id']);\n\t\t}\n\t} \n\telse {\n\t\thandleNoteListTapAfterSelect(notesData['id']);\n\t}\n},\n```\n\nWe pass **update** and **notesData** to the Edit screen stating the operation is updating notes and note data to fill in the Edit screen.\n\nChange **NotesEdit** widget in **notes_edit.dart** for handling update note operation.\n\n```dart\n@override\nvoid initState() {\n\tsuper.initState();\n\tnoteTitle = (widget.args[0] == 'new'? '': widget.args[1]['title']);\n\tnoteContent = (widget.args[0] == 'new'? '': widget.args[1]['content']);\n\tnoteColor = (widget.args[0] == 'new'? 'red': widget.args[1]['noteColor']);\n\n\t_titleTextController.text = (widget.args[0] == 'new'? '': widget.args[1]['title']);\n\t_contentTextController.text = (widget.args[0] == 'new'? '': widget.args[1]['content']);\n\t_titleTextController.addListener(handleTitleTextChange);\n\t_contentTextController.addListener(handleNoteTextChange);\n}\n\nvoid handleBackButton() async {\n\tif (noteTitle.length == 0) {\n\t\t// Go Back without saving\n\t\tif (noteContent.length == 0) {\n\t\t\tNavigator.pop(context);\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tString title = noteContent.split('\\n')[0];\n\t\t\tif (title.length > 31) {\n\t\t\t\ttitle = title.substring(0, 31);\n\t\t\t}\n\t\t\tsetState(() {\n\t\t\t\tnoteTitle = title;\n\t\t\t});\n\t\t}\n\t}\n\n\t// Save New note\n\tif (widget.args[0] == 'new') {\n\t\tNote noteObj = Note(\n\t\t\ttitle: noteTitle, \n\t\t\tcontent: noteContent, \n\t\t\tnoteColor: noteColor\n\t\t);\n\t\ttry {\n\t\t\tawait _insertNote(noteObj);\n\t\t} catch (e) {\n\n\t\t} finally {\n\t\t\tNavigator.pop(context);\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\t// Update Note\n\telse if (widget.args[0] == 'update') {\n\t\tNote noteObj = Note(\n\t\t\tid: widget.args[1]['id'],\n\t\t\ttitle: noteTitle, \n\t\t\tcontent: noteContent, \n\t\t\tnoteColor: noteColor\n\t\t);\n\t\ttry {\n\t\t\tawait _updateNote(noteObj);\n\t\t} catch (e) {\n\n\t\t} finally {\n\t\t\tNavigator.pop(context);\n\t\t\treturn;\n\t\t}\n\t}\n}\n```\n\nTapping on the note in the Home screen will take us to the Edit screen to update notes.\n\n---\n\nThis tutorial addressed how to create a simple note-taking app in Flutter with common operations like create, read, update and delete. We can extend the app to have multiple day-to-day useful features. I hope you will do that to create your own notes app according to your interests and needs.\n\nI have created a full Android working application with additional features like Notes sharing, multi-select notes, deleting notes in the edit screen, sort text in notes, etc. Check out the full code at [github.com/santhalakshminarayana/zehero-note](https://github.com/santhalakshminarayana/zehero-note)."},{"metadata":{"title":"Build Blog with Next.js and MDX & Deploy to Github Pages","description":"Create a blog with Next.js as Static Site Generator, MDX for writing content, Github Pages for deploying the static website. Also add SEO and Image optimization.","imgName":"blog-nextjs-mdx/nextjs.jpeg","date":"Dec 31, 2020","tags":["react","next-js"],"keywords":["react'","next.js","blog","mdx","markdown","gh-pages","github-pages"],"id":"build-blog-with-nextjs-mdx-and-deploy-to-github-pages"},"content":"\n![Build Blog with Next.js & MDX and Deploy to Github Pages](blog-nextjs-mdx/nextjs.jpeg)\n\n# Build Blog with Next.js & MDX and Deploy to Github Pages\n\nIn this post, we will discuss how to create and publish a blog with [Next.js](https://nextjs.org/), write content with [MDX](https://mdxjs.com/), deploy static site to Github Pages, Image optimization to reduce the page load time and SEO for better page ranking.\n\n> Pre-requisites: Basic understanding of React and Markdown. \n\nBuilding a blog with Next.js is very easy and it is simple to understand, develop, and maintain the dynamic websites and credit goes to Next.js dynamic paging which lets the creation of dynamic URLs and routing. When I decided to start my blog then I searched and read about many frameworks like Vanilla React, Gatsby, Hugo, etc., After reading many blogs, comments, and reviews I felt Next.js would be the option I was looking for. \n\nNext.js offers everything need to create a blog:\n- Static site export support\n- Dynamic routing\n- MDX (markdown with JSX) support\n- Image optimization\n- SEO\n\nNow dive in to create a simple blog\n\n## Setup Next.js and MDX\nNext.js is a React framework to create SPA (single page applications) and enables both static websites and server-side rendering. Here we'll focus only on static website generation.\n\n### Install Next.js\n\n[Install Next.js](https://nextjs.org/docs/getting-started#setup) by typing any of the following commands\n\n```bash\nnpx create-next-app\n# or\nyarn create next-app\n```\n\n_create-next-app_ installs everything needed to start with. \n\nThe most important thing in Next.js is the **pages** directory. Every component exported from **.js**, **.jsx**, **.ts**, or **.tsx** in the pages folder is treated as a page and each page associates with a route based on its file name. In the pages folder, the **App** component from **\\_app.js** serves as the initialization of pages that can be edited for custom use like global style declaration, CDN's, etc., **index.js** is the starting point for adding content.\n\nTo write content in articles we use MDX, which lets us write JSX in Markdown (**.mdx** file). Writing in markdown is as beautiful as it is like writing in a text file and can render as HTML tags. Besides easy export and maintenance of articles, we can also reuse these files in another framework/platform which supports MDX without rewriting.\n\n### Install MDX\n\nInstall necessary plugins for MDX\n\n```bash\nyarn add @next/mdx gray-matter next-mdx-remote\n```\n\nWe installed _@next/mdx_ to handle **.mdx** files in pages directory, _gray-matter_ is to parse content from markdown and _next-mdx-remote_ for rendering markdown as HTML.\n\nNow create / open **next.config.js** (configuration file for Next.js) at the project root level and add the following to configure MDX and handle **.mdx** page extensions in the pages folder.\n\n```js\nconst withMDX = require('@next/mdx')({\n  extension: /\\.mdx?$/,\n})\nmodule.exports = withMDX({\n  pageExtensions: ['js', 'jsx', 'mdx'],\n  target: 'serverless',\n})\n``` \nAs Next.js only looks for **.js** or **.jsx** files and gives routing to these pages, the above configuration tells Next.js to treat **.md** or **.mdx** files as pages and provide routing.\n\nAs we are creating a static site, **target: 'serverless'** notifies Next.js to generate static files for us.\n\nOpen **package.json** file in the root directory and add **deploy** command to export all static files as a folder as **out** (can have a different name) at the root level. After installing plugins and adding values **package.json** might look like this\n\n```json\n{\n  \"name\": \"blog\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"export\": \"next export\",\n    \"deploy\": \"npm run build && npm run export\"\n  },\n  \"dependencies\": {\n    ---\n  }\n}\n\n```\n\nLet's give some break to configuration and take a turn to add some content.\n\n## Home Page\n\nAs said earlier **index.js** is the pivot file and also the Home page for our website. So let's edit our Home page and customize it like below.\n\n```js:pages/index.js\nexport default function Home() {\n  return (\n    <div className = 'info-container'>\n      <img src = 'batman.png' alt = 'Batman Logo'/>\n      <p className = 'info-description'>Hi I'm Batman, the saviour of Gotham City and I like to roam in nights to bash the bad guys.</p>\n      <p className = 'info-description'>But please don't call me as a source for <b>Corona Virus</b> and it could be the <b>Joker</b> who \n      might have started this mess.</p>\n\n      <style jsx>{`\n        .info-container {\n          margin: 0 5% 0 5%;\n        }\n\n        img {\n          width: 20%;\n          max-width: 20%;\n          height: auto;\n          margin-left: 40%;\n        }\n\n        .info-description {\n          font-size: 20px;\n        }\n      `}</style>\n    </div>\n  )\n}\n```\n\nIn the above snippet, **CSS** styles are provided inside the component. This is called **CSS-In-JS**, which is possible as Next.js bundles **styled-jsx**. There are many ways to add [CSS in Next.js](https://nextjs.org/docs/basic-features/built-in-css-support).\n\nIn the **img** tag above, **src** is provided with the name of the image only but not relative/absolute path. In Next.js we don't need to provide complete paths if we place any assets (like images, videos) in the **public** folder. Next.js automatically prepends the path at build time for assets in the public folder.\n\nNow to see changes, start localhost (default port is 3000) as a dev server\n```bash\n# starts localhost at port 8000\nyarn dev -p 8000\n```\n\nOpen any desktop browser and type URL http://localhost:port/ to see changes.\nFor the above code, the display is like below\n\n![First preview](blog-nextjs-mdx/nextjs-blog-display.jpg)\n\nWe have a home page with a welcome message. Now some create blog posts with MDX.\n\n## Write Blog Content with MDX\n\nCreate a directory to store our markdown posts at the root level or any accessible place. \n\n```shell\nmkdir posts\n```\n\nWrite some content in a markdown file and save it as '.mdx' inside the **posts** directory. I have created two posts and saved them as **batman-vs-superman.mdx** and **justice-league.mdx**.\n\n```markdown:posts/batman-vs-superman.mdx\n---\ntitle: \"Batman VS Superman\"\ndescription: \"An intense fight between two superheroes, me and Superman.\"\ndate: \"Mar 25, 2016\"\n---\n\n# Batman VS Superman\n\nI and Superman accidentally met (fight) and later realized there was a culprit (Lex Luthor) who we should fight.\n\nAs usual, it cost a whopping $250 million for this high-action story.\n```\n\n```markdown:posts/justice-league.mdx\n---\ntitle: \"Justice League\"\ndescription: \"Grand union with fellow superheroes which costs $300 million but received face slap from the audience.\"\ndate: \"Nov 17, 2017\"\n---\n\n# Justice League\n\nSuperheroes from the DC universe consisting of Superman, Wonder Woman, The Flash, Aquaman, and Cyborg and I met in 2017 to spoil the party plans of Steppenwolf who tried to steal Mother Boxes on Earth.\n\nIt's a very long story of how we met each other and all thanks to Avengers who had inspired me to search for other superheroes.\n```\n\nIn the above snippet content inside **---** is used as metadata to make routing for this **.mdx** file. We'll discuss this later.\n\n## Show blog posts on the Home page\n\n### Fetch posts data\n\nTo show our blog posts on the Home page, we have to fetch the **.mdx** files and parse content. We can also provide routing from the home page to any blog post. We write the logic to fetch the **.mdx** files to read the content inside and extract metadata useful to display posts on the Home page. These files should be separated from routing, so at the root level create a folder called **lib** where we store all program files to extract **.mdx** content. Inside **lib** create a file with name **getPostsData.js** which returns posts data like markdown content, title, path, etc.,\n\n```js:lib/getPostsData.js\nconst fs = require('fs');\nconst path = require('path');\nconst matter = require(\"gray-matter\");\n\n// current 'posts' directory\nconst postsDirectory = path.join(process.cwd(), 'posts');\nconst mdx_file_extention = '.mdx';\n\nfunction getAllFilesInDirectory() {\n  const fileNames = fs.readdirSync(postsDirectory);\n  return fileNames.map((fileName) => {\n    return path.parse(fileName)\n  })\n}\n\nfunction getMdxFiles() {\n  const allFiles = getAllFilesInDirectory();\n  return allFiles.filter(parsedFile => parsedFile.ext == mdx_file_extention);\n}\n\nexport function getAllPostsPath() {\n  const allMdxFiles = getMdxFiles();\n  return allMdxFiles.map((parsedFile) => {\n    return {\n      params: {\n        id: parsedFile.name\n      }\n    }\n  })\n}\n\nexport function getPostsMetaData() {\n  const allMdxFiles = getMdxFiles();\n\n  const postsMetaData = allMdxFiles.map((parsedFile) => {\n    const fullPath = path.join(postsDirectory, parsedFile.base);\n\n    // get MDX metadata and content\n    const fileContents = fs.readFileSync(fullPath, 'utf8');\n    // get metadata, content\n    const { data, content } = matter(fileContents);\n    let metadata = data;\n    metadata['id'] = parsedFile.name;\n    return metadata;\n  });\n  return postsMetaData;\n}\n\nexport function getPostData(id) {\n  const fullPath = path.join(postsDirectory, id + mdx_file_extention);\n\n  // get MDX metadata and content\n  const fileContents = fs.readFileSync(fullPath, 'utf8');\n  // get metadata, content\n  const { data, content } = matter(fileContents);\n\n  let metadata = data;\n  metadata['id'] = id;\n\n  return {'metadata': metadata, 'content': content};\n}\n```\n\n**getAllPostsPath** function returns all **.mdx** files path names to serve as URLs for dynamic routing of a page.\n\n**getPostsMetaData** function returns all **.mdx** files metadata (data inside **---**) which we use to gather information like title, description, etc., and function **getPostsData** returns both metadata and markdown content to render for a particular file we request through argument **id**. **gray-matter** parses the markdown file into metadata (data inside **---**) and markdown content to render.\n\nIf encountered error while accessing **fs** add the following to _next.config.js_\n\n```js:next.config.js\nconst withMDX = require('@next/mdx')({\n  extension: /\\.mdx?$/,\n})\n\nmodule.exports = withMDX({\n\twebpack: (config, { isServer }) => {\n\t\tif (!isServer) {\n\t  \tconfig.node = {\n\t    fs: 'empty'\n\t \t\t}\n\t\t}\n\treturn config\n\t},\n  pageExtensions: ['js', 'jsx', 'mdx'],\n  target: 'serverless',\n})\n```\n### Provide posts data to Home page\n\nWe have to call the **getallPostsData** function to get data. But how can we pass this data to the component in **pages/index.js**? Don't worry we can pass data as **props** to the component before rendering using the [getStaticProps](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation) function. **getStaticProps** allows us to fetch any dynamic data to provide before rendering the component. Change **pages/index.js** as \n\n```js:pages/index.js\nimport { getPostsMetaData } from '../lib/getPostsData.js';\n\nexport default function Home({ postsData }) {\n  return (\n    <div className = 'info-container'>\n      <img src = 'batman.png' alt = 'Batman Logo'/>\n      <p className = 'info-description'>Hi I'm Batman, the saviour of Gotham City and I like to roam in nights to bash the bad guys.</p>\n      <p className = 'info-description'>But please don't call me as a source for <b>Corona Virus</b> and it could be the <b>Joker</b> who \n      might have started this mess.</p>\n      <hr/>\n      {postsData.map((metadata) => {\n        return (\n          <div key = {metadata.id}>\n            <h2 className = 'post-title'>{metadata.title}</h2>\n            <p className = 'post-description'>{metadata.description}</p>\n          </div>\n          )\n        })}\n\n      <style jsx>{`\n        .info-container {\n          margin: 0 5% 0 5%;\n        }\n\n        img {\n          width: 20%;\n          max-width: 20%;\n          height: auto;\n          margin-left: 40%;\n        }\n\n        .info-description {\n          font-size: 20px;\n        }\n\n        .post-title {\n          font-size: 24px;\n          color: black;\n        }\n\n        .post-description {\n          font-size: 16px;\n          color: #000000e6;\n        }\n      `}</style>\n    </div>\n  )\n}\n\nexport async function getStaticProps() {\n  const postsData = getPostsMetaData();\n  return {\n    props: {\n      postsData: postsData,\n    }\n  }\n}\n```\n\nWhich displays as \n\n![MDX blog posts display on Home page](blog-nextjs-mdx/blog-posts-display-on-home-page.jpg)\n\n## Rendering MDX and providing dynamic routing\n\nSo far so good until we want to display **.mdx** files as individual webpages. Right now it is not possible because Next.js only treats components exported inside the **pages** folder as webpages and provides routing, to provide routing for our posts we must export content from the **posts** directory to the **pages** folder. This is where we should spend some time to serve markdown files as webpages. \n\nThe beauty of Next.js is that we can dynamically serve pages by fetching these **.mdx** files and provide routing inside the **pages** directory with having dynamic pages.\n\nCreate **blog** folder inside the **pages** folder and inside this **blog** folder create a file with name **[id].js**. Dynamic routes in Next.js are identified by **[]** (square brackets) in the filename. We can provide any query parameter to this **[]** page component which will end up as *http://localhost:8000/blog/post-name* for **post-name.js**. Now add following code to *pages/blog/**[id]**.js*\n\n```js:pages/blog/[id].js\nimport { serialize } from 'next-mdx-remote/serialize';\nimport { MDXRemote } from 'next-mdx-remote';\nimport { getAllPostsPath, getPostData } from '../../lib/getPostsData.js';\n\nconst components = {\n\th1: props => <h1 style = {{ \n\t\tfontSize: 'calc(1rem + 1.5vw)', \n\t\tcolor: 'black',\n\t\tmargin: '1vh 0 1vh 0', }} \n\t\t{...props} />,\n\n\tp: props => <p style = {{ \n\t\tfontSize: 'calc(1rem + 0.1vw)', \n\t\tcolor: '#000000e6',\n\t\tmargin: '0vh 0 1vh 0' }} \n\t\t{...props} />,\n}\n\nexport default function Blog({ postMetadata, postContent }) {\n\n\treturn (\n\t\t<div>\n\t\t\t<div className = 'blog-content'>\n\t\t\t\t<MDXRemote {...postContent} components = {components} /> \n\t\t\t</div>\n\n\t\t\t<style jsx>{`\n\t\t\t\t.blog-content {\n\t\t\t\t\tdisplay: flex;\n\t\t\t\t\tflex: 100%;\n\t\t\t\t\tflex-direction: column;\n\t\t\t\t\tmargin: 1vw 25vw 1vw 25vw;\n\t\t\t\t\twidth: 50vw;\n\t\t\t\t\tmax-width: 50vw;\n\t\t\t\t}\n\t\t  `}</style>\n\t\t\t\n\t\t</div>\n\t)\n}\n\nexport async function getStaticPaths() {\n\tconst paths = getAllPostsPath();\n\treturn {\n\t\tpaths,\n\t\tfallback: false,\n\t}\n}\n\nexport async function getStaticProps({ params }) {\n\tconst postData = await getPostData(params.id);\n\tconst mdxSource = await serialize(postData.content);\n\treturn {\n\t\tprops: {\n\t\t\tpostMetadata: postData.metadata,\n\t\t\tpostContent: mdxSource,\n\t\t\tid: params.id,\n\t\t}\n\t}\n}\n```\n\nIf any page provides dynamic routing we must provide all dynamic paths we want to serve to this page through the [getStaticPaths](https://nextjs.org/docs/basic-features/data-fetching#getstaticpaths-static-generation) function.\n\nWith **serialize** and **MDXRemote**, we parse markdown content to HTML string and render it as plain HTML. To style the HTML tags in markdown, we pass custom tags as components to the MDX loader which maps tags automatically. In the above file two tags, **h1** and **p** are customized and combined as components.\n\nNow, in the browser, hit URL *http://localhost:3000/blog/batman-vs-superman* or *http://localhost:3000/blog/justice-league* to see the post. You might see output similar to below\n\n![MDX Post Display](blog-nextjs-mdx/mdx-post-display.jpg)\n\n## Navigation from the Home page\n\nWhat if we want to navigate from the Home page to blog posts by clicking on the title of the post? For this Next.js provides a [next/link](https://nextjs.org/docs/api-reference/next/link) component that takes care of dynamic routing from any page to another by pre-pending the necessary path before the page to navigate like navigation to **batman-vs-superman** results as *http://localhost:3000/blog/batman-vs-superman*. We must navigate like this only if we are not pre-pending the base URL manually inside the website. Now change **pages/index.js** to get dynamic navigation\n\n```js\nimport Link from 'next/link';\n{ ... }\n\n{postsData.map((metadata) => {\n  return (\n    <div key = {metadata.id}>\n      <Link href={`/blog/${metadata.id}`} key = {metadata.title} >\n        <a className = 'post-title'>{metadata.title}</a>\n      </Link>\n      <p className = 'post-description'>{metadata.description}</p>\n    </div>\n    )\n  })}\n\n { ... }\n```\n\n## Image Optimization\n\nImages take a lot of space in a webpage which reduces page loading time results in poor performance if the user has a poor internet connection. Images can be optimized many ways like converting all PNG/JPEG files to Webp/JPEG2000 format, [responsive images](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images) for different screen dimensions by rescaling images, lazy loading, etc.,\n\nNext.js provides [next/image](https://nextjs.org/docs/api-reference/next/image) API for image optimization. But it needs the **next start** that runs on the node server which is not possible for static site generation. So we will use another plugin [next-optimized-images](https://github.com/cyrilwanner/next-optimized-images) which provides many options to optimize images.\n\nHere we will optimize images to serve in Webp format, to do so install **next-optimized-images**\n\n```shell\nnpm install next-optimized-images\n```\n\nBesides this install some additional plugins to convert PNG/JPEG to Webp format and loading Webp images.\n\n```shell\nnpm install imagemin-mozjpeg imagemin-optipng webp-loader\n```\n\nand change _next.config.js_ as\n\n```js:next.config.js\nconst withNextOptimizedImages = require('next-optimized-images');\n\nconst withMDX = require('@next/mdx')({\n  extension: /\\.mdx?$/,\n})\n\nmodule.exports = withNextOptimizedImages(\n\twithMDX({\n\t\twebpack: (config, { isServer }) => {\n\t\t\t\tif (!isServer) {\n\t\t  \t\tconfig.node = {\n\t\t    \tfs: 'empty'\n\t\t \t\t}\n\t\t\t}\n\t\t\treturn config\n\t\t},\n\t  pageExtensions: ['js', 'jsx', 'mdx'],\n\t  target: 'serverless',\n\t})\n)\n```\n\nIn build time **next-optimized-images** exports optimized images to **images** (custom name) folder inside _out/_next/static_. So create **images** directory at the root level and move images to this folder which needs optimization and provide relative paths now which were previously not required because of the **public** folder.\n\nChange the **img** tag in **pages/index.js** to\n\n```jsx\n<picture>\n  <source srcSet={require('../images/batman.png?webp')} type=\"image/webp\" />\n  <source srcSet={require('../images/batman.png')} type=\"image/png\" />\n  <img src={require('../images/batman.png')} alt = 'Batman Logo' />\n</picture>\n```\n\nThis will convert a PNG image to Webp format and loads Webp images. If the browser doesn't support Webp images **<picture\\>** will automatically load the normal PNG image.\n\nYou can more than this by exploring more about this plugin.\n\n## SEO in Next.js\n\nFor Single Application Websites (SPA) SEO is a major problem which Next.js takes care of this by providing API [next/head](https://nextjs.org/docs/api-reference/next/head) which behaves exactly like **<head\\>** in HTML. We can wrap meta properties, title, description, Open Graph (OG) properties, Twitter cards, etc., inside the **Head** component. For our Home page we can set title and description as \n\n![Seo in Next.js:=:80](blog-nextjs-mdx/seo-in-nextjs.jpg)\n\nIf you don't want to set meta properties, title, description, and others there are so many plugins like [next-seo](https://www.npmjs.com/package/next-seo) available which handle all of these manual adding for you.\n\n---\n\n## Deploy to Github pages\n\n### Export static files to deploy\n\nNow our website is ready to move from development to production. To host our site we can use the static-site-generator of Next.js to generate all pre-render pages bundled inside the **out** directory. Build and generate **out** directory by typing the below command in the terminal\n\n```shell\nyarn deploy\n```\n\nYou can find a new directory **out** at the root level which contains all dynamic pages pre-rendered and ready to serve as HTML pages on the client-side. We will use this folder to host our website on Github pages.\n\n### Set up Github Pages\n\nGithub Pages is a very great place to host static sites. But we need to push and configure deployment changes every time we add content to the website. This is where we utilize Github Actions which automates deployment actions according to the configuration file we provide. But first, create a repository in Github to store our code files and push source code to this repository on the **main** branch. We use the **gh-pages** branch to which Github Actions deploy static files for hosting. \n\nTo do this we must provide access for Github Actions to this repository to access source files. To provide access, go to [Github Settings -> tokens](https://github.com/settings/tokens) and create a new **personal access token** by checking **repo** scopes and others if you need and save as **GITHUB_TOKEN** (or any other name). Copy this **access code** and in the repository, move to the **secretes** tab in the **Settings** section and create a new secrete and copy this code. Remember the name of the secrete token you created in this repo for future purposes. \n\n![Github Repository Secretes Token:=:80](blog-nextjs-mdx/github-repo-secretes-token.jpg)\n\nIt's time to configure GitHub Actions. Create a directory called _.github/workflows_ at the root level locally. Create a file **integrate.yml** inside _.github/workflows_ and add the following configuration\n\n```yaml:.github/workflows/integrate.yml\nname: Build and Deploy\non: \n  push:\n    branches:\n      - master\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v2.3.1\n        with:\n          persist-credentials: false\n\n      - name: Cache\n        uses: actions/cache@v2\n        with:\n          path: ${{ github.workspace }}/.next/cache\n          key: ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}\n\n      - name: Install and Build\n        uses: actions/setup-node@v1\n      - run: npm install\n      - run: npm run build\n      - run: npm run export\n        env:\n            CI: true\n      - run: touch out/.nojekyll\n\n      - name: Deploy\n        uses: JamesIves/github-pages-deploy-action@3.7.1\n        with:\n          ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }}\n          BRANCH: gh-pages \n          FOLDER: out\n          CLEAN: true\n```\nYou may have to replace **ACCESS_TOKEN** with your custom name. This is what we configured\n\n1. Execute workflow action on every push to the **master** branch.\n2. Run commands *npm install && npm run build && npm run export* to build and export static version of our website.\n3. Deploy contents inside **out** folder to the **gh-pages** branch.\n4. Added *touch out/.nojekyll* to **gh-pages** because Github pages **Jekyll** to render static sites. **Jekyll** ignores files in the directory starting with **_** and it is an issue for us because all our static assets are created in **\\_next** folder. **.nojekyll** tells Github Pages not to run published files through **Jekyll**.\n\nPush all changes to Github repo\n\n```shell\ngit add .\ngit commit -m \"initial deployment of the blog\"\ngit push -u origin master\n```\n\nThis will push all your working source files to the Github repo and Github Actions starts a workflow to deploy static files in the **out** folder to **gh-pages**.\n\nYou can monitor the status of the Github Actions workflow after every push to the **master** branch in the **Actions** tab.\n\nEnable Github Pages in the **Settings** section of the repo and for source select the **gh-pages** branch.\n\nIf everything worked properly you can have your website hosted at *https://<username\\>.github.io/<repo\\>*. Here **<repo\\>** name is **blog**. \n\n---\n\n## Manage CSS, assets, and page links to work properly\n\nIf you host the website at *https://<username\\>.github.io/<repo\\>* you can observe CSS or other static assets and routing not working properly. This is because Next.js assumes **out** directory hosted at root level as *https://<username\\>.github.io/* and directs all routing, replaces assets and everything to this basepath. But we have hosted the **out** folder in **blog/out**, so we must add **subpath** **blog** to the **basepath** to manage assets linking and routing. We can do this by changing the configuration in **next.config.js**\n\n```js:next.config.js\nconst ghPages = process.env.DEPLOY_TARGET === 'gh-pages';\n\nconst withNextOptimizedImages = require('next-optimized-images');\n\nconst withMDX = require('@next/mdx')({\n  extension: /\\.mdx?$/,\n})\n\nmodule.exports = withNextOptimizedImages(\n\twithMDX({\n\t\twebpack: (config, { isServer }) => {\n\t\t\tif (!isServer) {\n\t\t  \tconfig.node = {\n\t\t    fs: 'empty'\n\t\t \t\t}\n\t\t\t}\n\t\t\treturn config\n\t\t},\n\t  pageExtensions: ['js', 'jsx', 'mdx'],\n\t  target: 'serverless',\n\t\tbasePath: ghPages? '/blog/' : '',\n\t\tassetPrefix: ghPages ? '/blog/' : '',\n\t})\n)\n```\n\nWhile developing it works fine everything, so we check the environment phase we are processing with **process.env** and **process.env.DEPLOY_TARGET** tells the current hosted environment. In local development, we run on the **node** server hosted on our machine so we don't need to manage any **basepath** or **subpath**. \n\n**basePath** specifies the base path of the application to manage linking pages. If we are on the **gh-pages**, the base path **/blog/** resolves to **username.github.io/blog/** where **/** is the home path.\n\n**assetPrefix** specifies where to look for assets (CSS, Images, etc.,).\n\n---\n\nAnd here we are with our personal blog on the internet and we can take our blog to next level by adding fancy CSS, custom components, and other pages like **about**, **contact**... I hope you find this articl useful to build your own blog. To check the source code of this website, you can find it at [github.com/santhalakshminarayana/santhalakshminarayana.github.io](https://github.com/santhalakshminarayana/santhalakshminarayana.github.io)."}]},"__N_SSG":true}