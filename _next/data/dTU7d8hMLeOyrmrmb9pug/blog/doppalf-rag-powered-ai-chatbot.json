{"pageProps":{"postMetadata":{"title":"Doppalf: RAG powered full-stack AI chatbot like ChatGPT","description":"Build a full-stack RAG-powered AI chatbot like ChatGPT to give LLM your personality with Python, FastAPI, Llamaindex, Cohere, Qdrant, Next.js (Typescript), and Tailwind CSS.","imgName":"doppalf-rag-powered-ai-chatbot/doppalf-rag-powered-ai-chatbot.jpg","date":"May 24, 2024","tags":["python","ai","next-js","react"],"keywords":["python","llm","next-js","llamaindex","tailwind-css","typescript","fastapi","rag","cohere","qdrant","cohere-ai","ai-chatbot","llm","chatbot","chatgpt"],"id":"doppalf-rag-powered-ai-chatbot"},"postContent":{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    blockquote: \"blockquote\",\n    code: \"code\",\n    em: \"em\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    h4: \"h4\",\n    h6: \"h6\",\n    hr: \"hr\",\n    img: \"img\",\n    li: \"li\",\n    p: \"p\",\n    pre: \"pre\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"doppalf-rag-powered-ai-chatbot/doppalf-rag-powered-ai-chatbot.jpg\",\n        alt: \"Doppalf: RAG powered fullstack AI chatbot like ChatGPT\"\n      })\n    }), \"\\n\", _jsxs(_components.h6, {\n      children: [\"Published on: \", _jsx(_components.strong, {\n        children: \"May 24, 2024\"\n      })]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Doppalf: RAG-powered fullstack AI chatbot like ChatGPT\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I have built an end-to-end full-stack AI chatbot web application like ChatGPT. It's powered with RAG (Retrieval Augmentation Generation) to give LLM my personality. Meaning, that LLM will behave like me and assume the character of \", _jsx(_components.strong, {\n        children: \"Lakshmi Narayana\"\n      }), \". I have built this application with LLamaindex, Cohere AI, and the Qdrant database. The full tech stack is:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"Docker\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"Nginx\"\n        })\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"UI\"\n        }), \":\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"Next.js (v14)\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Typescript\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Tailwind CSS\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"Backend\"\n        }), \":\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"Python (v3.12)\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"FastAPI\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Llamaindex\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Cohere AI\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"Qdrant Cloud\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"doppalf-rag-powered-ai-chatbot/doppalf-response.gif\",\n        alt: \"Doppalf AI:=:100:=:Doppalf AI streaming response\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Architecture\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"doppalf-rag-powered-ai-chatbot/doppalf-arch.png\",\n        alt: \"Doppalf Architecture:=:100:=:Doppalf High level Architecture\"\n      })\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"The whole project code can be found on GitHub for \", _jsx(_components.a, {\n          href: \"https://github.com/santhalakshminarayana/doppalf\",\n          children: \"Doppalf\"\n        }), \".\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For Doppalf, Docker has been used for container orchestration and Nginx as a reverse proxy. This application has a total three services (repos):\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"doppalf-rp (Nginx)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"doppalf-ui (Next.js)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"doppalf-ai (Python)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Each of the above repos has an individual \", _jsx(_components.strong, {\n        children: \"Dockerfile\"\n      }), \" with optimized configuration. The following are the Dockerfiles for individual services:\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"doppalf-ui (Next.js)\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-yaml:Dockerfile\",\n        children: \"FROM node:21-bullseye-slim AS deps\\nWORKDIR /app\\nCOPY package*.json ./\\nEXPOSE 3001\\nENV PORT 3001\\nENV HOSTNAME \\\"0.0.0.0\\\"\\nRUN npm ci\\n\\n# Development\\nFrom deps as dev\\nENV NODE_ENV=development\\nCOPY . .\\nCMD [\\\"npm\\\", \\\"run\\\", \\\"dev\\\"]\\n\\nFROM node:21-bullseye-slim AS builder\\nWORKDIR /app\\nCOPY --from=deps /app/node_modules ./node_modules\\nCOPY . .\\nRUN npm run build\\nRUN npm prune --production\\n\\n# Production\\nFROM node:21-bullseye-slim AS prod\\nWORKDIR /app\\nENV NODE_ENV production\\n# Add nextjs user\\nRUN addgroup --system --gid 1001 nodejs\\nRUN adduser --system --uid 1001 nextjs\\n# Set the permission for prerender cache\\nRUN mkdir .next\\nRUN chown nextjs:nodejs .next\\nUSER nextjs\\n# Automatically leverage output traces to reduce image size\\nCOPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static\\nCOPY --from=builder --chown=nextjs:nodejs /app/public ./public\\n\\nEXPOSE 3001\\nENV PORT 3001\\nENV HOSTNAME \\\"0.0.0.0\\\"\\n\\nCMD [\\\"npm\\\", \\\"start\\\"]\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The above \", _jsx(_components.strong, {\n        children: \"Dockerfile\"\n      }), \" has a multi-stage build config for both \", _jsx(_components.em, {\n        children: \"dev\"\n      }), \" and \", _jsx(_components.em, {\n        children: \"prod\"\n      }), \" environments. The exact build stage to be used will be determined by configuration from \", _jsx(_components.em, {\n        children: \"docker-compose.yaml\"\n      }), \". By default, the \", _jsx(_components.em, {\n        children: \"dev\"\n      }), \" stage is used. The above configuration for \", _jsx(_components.em, {\n        children: \"prod\"\n      }), \" is very optimal and reduces the final running docker image size due to Next.js optimizations.\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"doppalf-ai (Python)\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-yaml:Dockerfile\",\n        children: \"# Why bookworm? https://pythonspeed.com/articles/base-image-python-docker-images/\\nFROM python:3.12-slim-bookworm as base\\nWORKDIR /app\\nRUN apt-get update && \\\\\\n    apt-get install -y --no-install-recommends gcc\\nCOPY requirements.txt .\\nRUN pip wheel --no-cache-dir --no-deps --wheel-dir /app/wheels -r requirements.txt\\n\\nFROM python:3.12-slim-bookworm as build\\nENV PYTHONDONTWRITEBYTECODE=1\\nENV PYTHONUNBUFFERED=1\\nWORKDIR /app\\nCOPY --from=base /app/wheels /app/wheels\\nCOPY --from=base /app/requirements.txt .\\nRUN pip install --no-cache /app/wheels/*\\nCOPY . /app\\nEXPOSE 4001\\nCMD [\\\"python\\\", \\\"main.py\\\"]\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The above \", _jsx(_components.strong, {\n        children: \"Dockerfile\"\n      }), \" pulls Python 3.12 \", _jsx(_components.em, {\n        children: \"slim-bookworm\"\n      }), \" docker image as opposed to the common \", _jsx(_components.em, {\n        children: \"alpine\"\n      }), \" image. You can refer to the linked article for why. Here instead of normally installing requirements through \", _jsx(_components.em, {\n        children: \"pip\"\n      }), \", we install dependencies through \", _jsx(_components.em, {\n        children: \"wheels\"\n      }), \" which optimizes the docker image build speed.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The Next.js service will be running on PORT \", _jsx(_components.em, {\n        children: \"3001\"\n      }), \" and the Python service will run on \", _jsx(_components.em, {\n        children: \"4001\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"doppalf-rp (Nginx)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And finally, Nginx configuration for forwarding the traffic to individual services are done as\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-:includes/proxy.conf\",\n        children: \"proxy_set_header Host $host;\\nproxy_set_header X-Real-IP $remote_addr;\\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\\nproxy_set_header X-Forwarded-Proto $scheme;\\nproxy_set_header X-Forwarded-Host $server_name;\\nproxy_buffering off;\\nproxy_request_buffering off;\\nproxy_http_version 1.1;\\nproxy_intercept_errors on;\\n\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-yaml:Dockerfile\",\n        children: \"From nginx:stable-alpine\\nRUN mkdir -p /run/nginx\\nWORKDIR /run/nginx\\nCOPY ./nginx.conf /etc/nginx/conf.d/default.conf\\nCOPY ./includes /etc/nginx/includes/\\nEXPOSE 80\\nCMD [\\\"nginx\\\", \\\"-g\\\", \\\"daemon off;\\\"]\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Nginx configruation for forwarding rules for different services\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-:nginx.conf\",\n        children: \"server {\\n    listen 80 default_server;\\n    listen [::]:80 default_server;\\n    server_name _;\\n\\n    index index.html;\\n\\n    location / {\\n        proxy_pass http://doppalf-ui-service:3001;\\n    }\\n\\n    location /doppalf-ai/v1 {\\n        proxy_pass http://doppalf-ai-service:4001;\\n\\n        proxy_redirect off;\\n        # SSE connection config\\n        proxy_set_header Connection '';\\n        proxy_cache off;\\n    }\\n}\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So, the root \", _jsx(_components.em, {\n        children: \"/\"\n      }), \" request (127.0.0.1) will be forwarded to the Next.js UI service for the UI page, and any request with the prefix \", _jsx(_components.em, {\n        children: \"/doppalf-ai/v1\"\n      }), \" will be forwarded to the Python AI service.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Doppalf UI\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The UI has been built with Next.js (Typescript) and Tailwind CSS. It's a single-page application that mainly contains an input box for providing Query and the response will be generated like ChatGPT where the UI will show the user and system messages. The AI-generated answer will be streamed like ChatGPT and rendered as Markdown. This has been done by Streaming the text from the Backend as \", _jsx(_components.strong, {\n        children: \"SSE (Server Sent Events)\"\n      }), \" and reading those messages in Next.js using using Microsoft's \", _jsx(_components.a, {\n        href: \"https://www.npmjs.com/package/@microsoft/fetch-event-source\",\n        children: \"Fetch Event Source package\"\n      }), \" because normal browser SSE doesn't support \", _jsx(_components.em, {\n        children: \"POST\"\n      }), \" request.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"doppalf-rag-powered-ai-chatbot/doppalf-ui-query-response.png\",\n        alt: \"Doppalf UI Landing Page:=:100:=:Showing User and System Message\"\n      })\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"UI Features include:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Dark mode\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Streaming responses like ChatGPT\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Auto-scroll to the bottom while generating the answer\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"New chat session\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Doppalf AI\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The main part of this application is building the RAG pipeline and giving LLM a personal character that answers like me. For this, I have used Llamaindex for building the RAG pipeline, Cohere AI as LLM, and Qdrant Cloud for storing vector embeddings.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"This costs me nothing as they both offer free APIs, you can get free \", _jsx(_components.a, {\n        href: \"https://dashboard.cohere.com/api-keys\",\n        children: \"Cohere API trail Key\"\n      }), \" and 1 GB cluster for storing vectors in \", _jsx(_components.a, {\n        href: \"https://cloud.qdrant.io\",\n        children: \"Qdrant Cloud API Key and URL\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The web framework for providing APIs used was FastAPI and its support for streaming the response like SSE without using any extra configuration was a huge thumbs up for this kind of AI Chatbot application.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For building the RAG pipeline, I have followed the following pipeline process:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Load Documents\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Parse text into Sentences (as nodes) with Window size as 1\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Get vector embeddings for each node (sentences) with Cohere Embeddings\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Index the nodes and store the vector embeddings in the Qdrant cloud\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Persist the index for re-use further runtimes\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Build a Chat engine from the index with a retrieval strategy as \\\"Small-to-Big\\\" and with some buffered chat memory history\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Provide the retrieved context and use Cohere Rerank for reranking the retrieved nodes\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Synthesis the response using Cohere\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"doppalf-rag-powered-ai-chatbot/rag-pipeline.jpg\",\n        alt: \"RAG Pipeline:=:100:=:RAG pipeline\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The complete code for the RAG pipeline using Llamaindex is\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python:rag.py\",\n        children: \"from llama_index.core import load_index_from_storage\\nfrom llama_index.core.memory import ChatMemoryBuffer\\nfrom llama_index.core.node_parser import SentenceWindowNodeParser\\nfrom llama_index.core.postprocessor import MetadataReplacementPostProcessor\\nfrom llama_index.embeddings.cohere import CohereEmbedding\\nfrom llama_index.llms.cohere import Cohere\\nfrom llama_index.postprocessor.cohere_rerank import CohereRerank\\nfrom llama_index.vector_stores.qdrant import QdrantVectorStore\\nfrom qdrant_client import QdrantClient\\n\\nfrom src.config.env import ENV, env_keys\\nfrom src.config.logger import get_logger\\n\\nfrom .constants import CHAT_PROMPT\\n\\nenvk = ENV()\\nlogger = get_logger()\\n\\nindex = None\\nchat_engine = None\\n\\ndef load_rag() -> None:\\n    global index\\n    global chat_engine\\n\\n    cdir = os.getcwd()\\n    docs_dir = envk.get(env_keys.get(\\\"DOCS_DIR\\\"))\\n    docs_path = os.path.join(cdir, docs_dir)\\n\\n    # check if any documents are provided for index\\n    if not os.path.exists(docs_path):\\n        raise FileNotFoundError(f\\\"Documents dir at path: {docs_path} not exists.\\\")\\n    if not os.listdir(docs_dir):\\n        raise FileNotFoundError(f\\\"Provide documents inside directory: {docs_path} for indexing.\\\")\\n    \\n    storage_dir = envk.get(env_keys.get(\\\"INDEX_STORAGE_DIR\\\"))\\n    storage_path = os.path.join(cdir, storage_dir)\\n    \\n    cohere_api_key = envk.get(env_keys.get(\\\"COHERE_API_KEY\\\"))\\n    qdrant_api_key = envk.get(env_keys.get(\\\"QDRANT_API_KEY\\\"))\\n\\n    Settings.llm = Cohere(\\n        api_key=cohere_api_key,\\n        model=\\\"command-r-plus\\\", \\n    )\\n    Settings.embed_model = CohereEmbedding(\\n        cohere_api_key=cohere_api_key,\\n        model_name=\\\"embed-english-v3.0\\\",\\n        input_type=\\\"search_document\\\",\\n    )\\n    \\n    qd_client = QdrantClient(\\n        envk.get(env_keys.get(\\\"QDRANT_CLOUD_URL\\\")),\\n        api_key=qdrant_api_key,\\n    )\\n\\n    sentence_node_parser = SentenceWindowNodeParser.from_defaults(\\n        window_size=1,\\n        window_metadata_key=\\\"window\\\",\\n        original_text_metadata_key=\\\"original_text\\\", \\n    )\\n\\n    vector_store = QdrantVectorStore(\\n        client=qd_client, \\n        collection_name=envk.get(env_keys.get(\\\"COLLECTION_NAME\\\")),\\n    )\\n\\n    # index was previously persisted\\n    if os.path.exists(storage_path) and os.listdir(storage_path):\\n        logger.debug(\\\"Using existing index.\\\")\\n        storage_context = StorageContext.from_defaults(\\n            vector_store=vector_store, persist_dir=storage_path\\n        )\\n        \\n        index = load_index_from_storage(storage_context)\\n\\n    else:\\n        logger.debug(\\\"Creating new index for documents.\\\")\\n        reader = SimpleDirectoryReader(input_dir=docs_path)\\n        \\n        all_docs = []\\n        for docs in reader.iter_data():\\n            all_docs.extend(docs)\\n        \\n        for doc in all_docs:\\n            logger.debug(f\\\"id: {doc.doc_id}\\\\nmetada: {doc.metadata}\\\")\\n\\n        nodes = sentence_node_parser.get_nodes_from_documents(all_docs)\\n        \\n        storage_context = StorageContext.from_defaults(vector_store=vector_store)\\n        \\n        index = VectorStoreIndex(nodes, storage_context=storage_context)\\n\\n        index.storage_context.persist(persist_dir=storage_path)\\n\\n\\n    chat_engine = index.as_chat_engine(\\n        chat_mode=\\\"condense_plus_context\\\",\\n        memory=ChatMemoryBuffer.from_defaults(token_limit=int(envk.get(env_keys.get(\\\"MAX_BUFFER_MEMORY_TOKENS\\\")))),\\n        context_prompt=CHAT_PROMPT,\\n        similarity_top_k=3, \\n        node_postprocessors=[\\n            MetadataReplacementPostProcessor(target_metadata_key=\\\"window\\\"),\\n            CohereRerank(api_key=cohere_api_key, top_n=3),\\n        ],\\n        verbose=False,\\n    )\\n\\n\\ndef chat(query: str):\\n    global chat_engine\\n    \\n    response = chat_engine.stream_chat(query)\\n    for res in response.response_gen:\\n        yield f\\\"data: {json.dumps({\\\"message\\\":res})}\\\\n\\\\n\\\"\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The above \", _jsx(_components.em, {\n        children: \"load_rag()\"\n      }), \" function will first check if any previously stored index exists for re-using else it will build one. If no index is stored in the given \", _jsx(_components.em, {\n        children: \"storage_path\"\n      }), \" directory, it will build the index by loading the documents from the \", _jsx(_components.em, {\n        children: \"docs_dir\"\n      }), \" directory. \", _jsx(_components.em, {\n        children: \"SentenceWindowNodeParser\"\n      }), \" is used for parsing the sentences into nodes with a window size of 1. This window size makes the post-retrieval context have surrounding sentences also part of it for better answer synthesis.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For created nodes, get the vector embeddings from the Cohere embeddings and store them in the Qdrant Cloud. And finally store the index for skipping this whole process again when the application restarts.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"From the index, build the chat engine with some memory (4096 tokens here) for memorizing past conversations with the user and provide Cohere Re-ranker as post node retrieval processer for reranking the nodes based on the query relevancy. This chat engine retrieves the surrounding context for each retrieved node for more information and finally sends the whole retrieved-context and the query to the LLM for answer generation as a prompt. I have used a custom prompt for making LLM answer as me.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python:/src/generate/constants.py\",\n        children: \"CHAT_PROMPT=(\\n    \\\"You are impersonating the human 'Lakshmi Narayana' and so your name.\\\"\\n    \\\"So you are Lakshmi Narayana and answers in first person.When asked any question about you, you will answer as if Lakshmi Narayana is answering.\\\"\\n    \\\"You will answer politely and take the help of the following context for more relevant answers.\\\"\\n    \\\"If you don't have any sufficient information from the context, use your knowledge to answer.\\\"\\n    \\\"Or don't hallucinate if you are sure you cannot answer.\\\"\\n    \\\"Here are the relevant documents for the context:\\\\n{context_str}\\\\n\\\"\\n    \\\"Instruction: Use the previous chat history, or the context above, to interact and help the user and answer as if you are Lakshmi Narayana.\\\"\\n    \\\"Don't add any additional data if the answer can be derived from context.\\\"\\n    \\\"Generate the response in markdown format.\\\"\\n)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"LLamaindex uses this prompt for context ingestion and sends this to LLM for answer generation.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Finally, the chat generation API is exposed for streaming the response using FastAPI as follows\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"language-python:api.py\",\n        children: \"from fastapi import APIRouter, HTTPException\\nfrom pydantic import BaseModel\\nfrom starlette.responses import StreamingResponse\\n\\nfrom .rag import chat\\n\\n\\nclass GenerateModel(BaseModel):\\n    message: str\\n    message_id: str\\n    role: str\\n    timestamp: str\\n\\n\\ngrouter = APIRouter(tags=[\\\"generate\\\"])\\n\\n\\n@grouter.post(\\\"\\\")\\nasync def generate(data: GenerateModel):\\n    try:\\n        return StreamingResponse(\\n            chat(data.message), \\n            media_type='text/event-stream',\\n        )\\n    except Exception as e:\\n        raise HTTPException(status_code=500, detail=e)\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And final interactivity with LLM that answers about me like I am talking as\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"doppalf-rag-powered-ai-chatbot/query-response-history.png\",\n        alt: \"LLM answering as me:=:100:=:LLM answering like me with history\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"New Chat session\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"doppalf-rag-powered-ai-chatbot/new-chat.gif\",\n        alt: \"New Chat Session:=:100:=:New Chat Session\"\n      })\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n      children: \"I will some more features in the future like:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Adding or removing the documents dynamically from the UI\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Voice cloning for speaking out the answer as a character\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Enhance the LLM answering with more RAG strategies\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Please check out the complete project code in my Github repository for \", _jsx(_components.a, {\n        href: \"https://github.com/santhalakshminarayana/doppalf\",\n        children: \"Doppalf\"\n      }), \".\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"id":"doppalf-rag-powered-ai-chatbot"},"__N_SSG":true}